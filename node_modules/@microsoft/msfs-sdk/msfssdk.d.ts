/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/baseinstrument" />
/// <reference types="@microsoft/msfs-types/js/netbingmap" />
/// <reference types="@microsoft/msfs-types/js/types" />
/// <reference types="@microsoft/msfs-types/js/simplane" />
/// <reference types="@microsoft/msfs-types/js/common" />
/** The acceptable priority types for a given annunciation. */
declare enum AnnunciationType {
    Warning = 0,
    Caution = 1,
    Advisory = 2,
    SafeOp = 3
}
/** The main logic for a cabin annunciation. */
declare class Annunciation {
    /** The priority type of the annunciation. */
    readonly type: AnnunciationType;
    /** An identifier tying every suffix for a given annunciation together. */
    readonly uuid: string;
    /** The text to show when we are displayed. */
    readonly text: string;
    /** An XML logic element that will show when we are active. */
    readonly condition: CompositeLogicXMLElement;
    /** An optional text suffix to put on the alert text. */
    readonly suffix: string | undefined;
    /**
     * Creates an instance of Annunciation.
     * @param type The type of annuniciaton this is.
     * @param text The text label to show.
     * @param condition The logic condition for setting it.
     * @param suffix Any suffix text to past to the end.
     * @param uuid A preset UUID, or one will be generated.
     */
    constructor(type: AnnunciationType, text: string, condition: CompositeLogicXMLElement, suffix: string | undefined, uuid: string | undefined);
}

/** Create a list of annunciations from the instrument XML config. */
declare class XMLAnnunciationFactory {
    private instrument;
    /**
     * Create an XMLAnnunciationFactory.
     * @param instrument The instrument that holds this engine display.
     */
    constructor(instrument: BaseInstrument);
    /**
     * Parse an panel.xml configuration
     * @param document The configuration as an XML document.
     * @returns An array of Annunciations.
     */
    parseConfig(document: Document): Array<Annunciation>;
}

/**
 * A readonly version of a {@link Float64Array}.
 */
declare type ReadonlyFloat64Array = Readonly<Omit<Float64Array, 'set' | 'copyWithin' | 'sort'>>;
/**
 * 2D vector mathematical operations.
 */
declare class Vec2Math {
    /**
     * Creates a 2D vector initialized to `[0, 0]`.
     * @returns A new 2D vector initialized to `[0, 0]`.
     */
    static create(): Float64Array;
    /**
     * Creates a 2D vector with specified x- and y- components.
     * @param x The x-component of the new vector.
     * @param y The y-component of the new vector.
     * @returns A new 2D vector with the specified components.
     */
    static create(x: number, y: number): Float64Array;
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec: ReadonlyFloat64Array): number;
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x: number, y: number, vec: Float64Array): Float64Array;
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r: number, theta: number, vec: Float64Array): Float64Array;
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array): number;
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1: ReadonlyFloat64Array, scalar: number, out: Float64Array): Float64Array;
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1: ReadonlyFloat64Array): number;
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1: ReadonlyFloat64Array, out: Float64Array, counterClockwise?: boolean): Float64Array;
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): number;
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): boolean;
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     */
    static copy(from: ReadonlyFloat64Array, to: Float64Array): Float64Array;
    /**
     * Checks if a point is within a polygon.
     * @param polygon The polygon to check against.
     * @param point The point to test.
     * @returns True if the point is within or on the polygon, false otherwise.
     * @throws An error if first and last points in a polygon are not the same.
     */
    static pointWithinPolygon(polygon: ReadonlyFloat64Array[], point: Float64Array): boolean | undefined;
}
/**
 * 3D vector mathematical operations.
 */
declare class Vec3Math {
    /**
     * Creates a 3D vector initialized to `[0, 0, 0]`.
     * @returns A new 3D vector initialized to `[0, 0, 0]`.
     */
    static create(): Float64Array;
    /**
     * Creates a 3D vector with specified x-, y-, and z- components.
     * @param x The x-component of the new vector.
     * @param y The y-component of the new vector.
     * @param z The z-component of the new vector.
     * @returns A new 3D vector with the specified components.
     */
    static create(x: number, y: number, z: number): Float64Array;
    /**
     * Gets the spherical angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle theta of the vector.
     */
    static theta(vec: ReadonlyFloat64Array): number;
    /**
     * Gets the spherical angle phi of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle phi of the vector.
     */
    static phi(vec: ReadonlyFloat64Array): number;
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param z - the new z-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x: number, y: number, z: number, vec: Float64Array): Float64Array;
    /**
     * Sets the spherical components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new spherical angle theta, in radians.
     * @param phi - the new spherical angle phi, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromSpherical(r: number, theta: number, phi: number, vec: Float64Array): Float64Array;
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array): number;
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1: ReadonlyFloat64Array, scalar: number, out: Float64Array): Float64Array;
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1: ReadonlyFloat64Array): number;
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): number;
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): boolean;
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from: ReadonlyFloat64Array, to: Float64Array): Float64Array;
}
/**
 * N-dimensional vector mathematical operations.
 */
declare class VecNMath {
    /**
     * Creates an N-dimensional vector with all components initialized to `0`.
     * @param length The length of the new vector.
     * @returns A new N-dimensional vector with the specified length and all components initialized to `0`.
     */
    static create(length: number): Float64Array;
    /**
     * Creates an N-dimensional vector with specified components.
     * @param length The length of the new vector.
     * @param components The components of the new vector.
     * @returns A new N-dimensional vector with the specified length and components.
     */
    static create(length: number, ...components: number[]): Float64Array;
    /**
     * Sets the components of a vector.
     * @param vec The vector to change.
     * @param components The new components.
     * @returns The vector after it has been changed.
     */
    static set(vec: Float64Array, ...components: number[]): Float64Array;
    /**
     * Gets the magnitude of a vector.
     * @param vec The vector to get the magnitude for.
     * @returns The vector's magnitude.
     */
    static abs(vec: ReadonlyFloat64Array): number;
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     * @throws Error if the two vectors are of unequal lengths.
     */
    static dot(v1: ReadonlyFloat64Array, v2: ReadonlyFloat64Array): number;
    /**
     * Normalizes a vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns The normalized vector.
     */
    static normalize(v1: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1: ReadonlyFloat64Array, vec2: ReadonlyFloat64Array): boolean;
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     * @throws Error if the vectors are of unequal lengths.
     */
    static copy(from: ReadonlyFloat64Array, to: Float64Array): Float64Array;
}

/**
 * A subscription to a source of notifications.
 *
 * Subscriptions can be freely paused and resumed. Paused subscriptions do not receive notifications from its source.
 *
 * Subscriptions that have reached the end of their useful life can be destroyed, after which they will no longer
 * receive notifications and cannot be paused or resumed.
 */
interface Subscription {
    /**
     * Whether this subscription is alive. Live subscriptions can be freely paused and resumed. Dead subscriptions no
     * longer receive notifications from their sources and will throw an error when attempting to pause or resume them.
     */
    readonly isAlive: boolean;
    /**
     * Whether this subscription is paused. Paused subscriptions do not receive notifications from their sources until
     * they are resumed.
     */
    readonly isPaused: boolean;
    /**
     * Whether this subscription supports initial notifications on resume.
     */
    readonly canInitialNotify: boolean;
    /**
     * Pauses this subscription. Once paused, this subscription will not receive notifications from its source until it
     * is resumed.
     * @returns This subscription, after it has been paused.
     * @throws Error if this subscription is not alive.
     */
    pause(): this;
    /**
     * Resumes this subscription. Once resumed, this subscription will receive notifications from its source.
     * @param initialNotify Whether to immediately send a notification to this subscription's handler when it is resumed
     * if this subscription supports initial notifications. Defaults to `false`.
     * @returns This subscription, after it has been resumed.
     * @throws Error if this subscription is not alive.
     */
    resume(initialNotify?: boolean): this;
    /**
     * Destroys this subscription. Once destroyed, this subscription will no longer receive notifications from its
     * source and will throw an error when attempting to pause or resume it.
     */
    destroy(): void;
}

/**
 * An item which allows others to subscribe to be notified of changes in its state.
 */
interface Subscribable<T> {
    /** Flags this object as a Subscribable. */
    readonly isSubscribable: true;
    /**
     * Gets the state of this subscribable.
     * @returns the state of this subscribable.
     */
    get(): T;
    /**
     * Subscribes to changes in this subscribable's state.
     * @param handler A function which is called when this subscribable's state changes.
     * @param initialNotify Whether to immediately invoke the callback function with this subscribable's current state.
     * Defaults to `false`. This argument is ignored if the subscription is initialized as paused.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    sub(handler: (value: T) => void, initialNotify?: boolean, paused?: boolean): Subscription;
    /**
     * Unsubscribes a callback function from this subscribable.
     * @param handler The function to unsubscribe.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.sub()`
     * to manage subscriptions.
     */
    unsub(handler: (value: T) => void): void;
    /**
     * Maps this subscribable to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubscribable<M>;
    /**
     * Maps this subscribable to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubscribable<M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this subscribable's state and pipes a mapped version to a mutable subscribable. Whenever an update
     * of this subscribable's state is received through the subscription, it will be transformed by the specified mapping
     * function, and the transformed state will be used as an input to change the other subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (fromVal: T, toVal: M) => M, paused?: boolean): Subscription;
}
/**
 * A subscribable which is mapped from another subscribable.
 */
interface MappedSubscribable<T> extends Subscribable<T> {
    /**
     * Whether the subscription to the parent subscribable is alive. While alive, this subscribable will update its state
     * based on its parent's state, unless it is paused. Once dead, this subscribable will no longer update its state,
     * and cannot be resumed again.
     */
    readonly isAlive: boolean;
    /**
     * Whether the subscription to the parent subscribable is paused. While paused, this subscribable will not update its
     * state until it is resumed.
     */
    readonly isPaused: boolean;
    /**
     * Pauses the subscription to the parent subscribable. Once paused, this subscribable will not update its state until
     * it is resumed.
     * @returns This subscribable, after it has been paused.
     * @throws Error if the subscription to the parent subscribable is not alive.
     */
    pause(): this;
    /**
     * Resumes the subscription to the parent subscribable. Once resumed, this subscribable will immediately begin to
     * update its state based its parent's state.
     * @returns This subscribable, after it has been resumed.
     * @throws Error if the subscription to the parent subscribable is not alive.
     */
    resume(): this;
    /**
     * Destroys the subscription to the parent subscribable.
     */
    destroy(): void;
}
/**
 * A subscribable which can accept inputs to change its state. The state of the subscribable may be derived from the
 * inputs directly or from transformed versions of the inputs.
 */
interface MutableSubscribable<T, I = T> extends Subscribable<T> {
    /** Flags this object as a MutableSubscribable. */
    readonly isMutableSubscribable: true;
    /**
     * Sets the state of this subscribable.
     * @param value The input used to change the state.
     */
    set(value: I): void;
}
/**
 * Utility type to retrieve the value type of a {@link Subscribable}.
 */
declare type SubscribableType<S> = S extends Subscribable<infer T> ? T : never;
/**
 * Utility type to convert a type of Subject into a {@link Subscribable}.
 */
declare type ToSubscribable<S> = S extends Subscribable<infer T> ? Subscribable<T> : never;
/**
 * Utility type to retrieve the input value of a {@link MutableSubscribable}.
 */
declare type MutableSubscribableInputType<S> = S extends MutableSubscribable<any, infer I> ? I : never;

/**
 * Types of subscribable array change event.
 */
declare enum SubscribableArrayEventType {
    /** An element was added. */
    Added = "Added",
    /** An element was removed. */
    Removed = "Removed",
    /** The array was cleared. */
    Cleared = "Cleared"
}
/**
 * A function which handles changes in a {@link SubscribableArray}'s state.
 */
declare type SubscribableArrayHandler<T> = (index: number, type: SubscribableArrayEventType, item: T | readonly T[] | undefined, array: readonly T[]) => void;
/**
 * An array which allows others to subscribe to be notified of changes in its state.
 */
interface SubscribableArray<T> {
    /** The length of this array. */
    readonly length: number;
    /**
     * Retrieves an element from this array.
     * @param index The index of the element.
     * @returns the element at the specified index.
     * @throws Error if index is out of bounds.
     */
    get(index: number): T;
    /**
     * Attempts to retrieve an element from this array.
     * @param index The index of the element.
     * @returns the element at the specified index, or undefined if index is out of bounds.
     */
    tryGet(index: number): T | undefined;
    /**
     * Gets a read-only version of this array.
     * @returns a read-only version of this array.
     */
    getArray(): readonly T[];
    /**
     * Subscribes to changes in this array's state.
     * @param handler A function which is called when this array's state changes.
     * @param initialNotify Whether to immediately invoke the callback function with this array's current state.
     * Defaults to `false`. This argument is ignored if the subscription is initialized as paused.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    sub(handler: SubscribableArrayHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /**
     * Unsubscribes a callback function from this array.
     * @param handler The function to unsubscribe.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.sub()`
     * to manage subscriptions.
     */
    unsub(handler: SubscribableArrayHandler<T>): void;
}

/**
 * Types of changes made to {@link SubscribableSet}.
 */
declare enum SubscribableSetEventType {
    /** A key was added. */
    Added = "Added",
    /** A key was deleted. */
    Deleted = "Deleted"
}
/**
 * A function which handles changes in a {@link SubscribableSet}'s state.
 */
declare type SubscribableSetHandler<T> = (set: ReadonlySet<T>, type: SubscribableSetEventType, key: T) => void;
/**
 * A set which allows others to subscribe to be notified of changes in its state.
 */
interface SubscribableSet<T> {
    /** Flags this object as a SubscribableSet. */
    readonly isSubscribableSet: true;
    /** The number of elements contained in this set. */
    readonly size: number;
    /**
     * Gets a read-only version of this set.
     * @returns A read-only version of this set.
     */
    get(): ReadonlySet<T>;
    /**
     * Checks whether this set contains a key.
     * @param key The key to check.
     * @returns Whether this set contains the specified key.
     */
    has(key: T): boolean;
    /**
     * Subscribes to changes in this set's state.
     * @param handler A function which is called when this set's state changes.
     * @param initialNotify Whether to immediately invoke the callback function with this set's current state.
     * Defaults to `false`. This argument is ignored if the subscription is initialized as paused.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    sub(handler: SubscribableSetHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /**
     * Subscribes to and pipes this set's state to a mutable subscribable set. Whenever a key added or removed event is
     * received through the subscription, the same key will be added to or removed from the other set.
     * @param to The mutable subscribable set to which to pipe this set's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribableSet<T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this set's state and pipes a mapped version to a mutable subscribable set. Whenever a key added
     * event is received through the subscription, the key will be transformed by the specified mapping
     * function, and the transformed key will be added to the other set. Whenever a key removed event is received, the
     * transformed key is removed from the other set if and only if no remaining key in this set maps to the same
     * transformed key.
     * @param to The mutable subscribable to which to pipe this set's mapped state.
     * @param map The function to use to transform keys.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribableSet<M>, map: (input: T) => M, paused?: boolean): Subscription;
}
/**
 * A subscribable set which can accept inputs to add or remove keys.
 */
interface MutableSubscribableSet<T> extends SubscribableSet<T> {
    /** Flags this object as a MutableSubscribableSet. */
    readonly isMutableSubscribableSet: true;
    /**
     * Adds a key to this set.
     * @param key The key to add.
     * @returns This set, after the key has been added.
     */
    add(key: T): this;
    /**
     * Removes a key from this set.
     * @param key The key to remove.
     * @returns Whether the key was removed.
     */
    delete(key: T): boolean;
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key: T): boolean;
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @param force The state of the key to force. If `true`, the key will be added to this set. If `false`, the key will
     * be removed from this set.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key: T, force: boolean): boolean;
    /**
     * Removes all keys from this set.
     */
    clear(): void;
}

/**
 * An interface that describes a virtual DOM node.
 */
interface VNode {
    /** The created instance of the node. */
    instance: NodeInstance;
    /**
     * The root DOM node of this VNode
     * @type {Node}
     * @memberof VNode
     */
    root?: Node;
    /** Any properties to apply to the node. */
    props: any;
    /** The children of this node. */
    children: VNode[] | null;
}
/** A union of possible types of a VNode instance. */
declare type NodeInstance = HTMLElement | SVGElement | DisplayComponent<any> | string | number | null | Subscribable<any>;
/** A union of possible child element types. */
declare type DisplayChildren = VNode | string | number | Subscribable<any> | (VNode | string | number | Subscribable<any>)[] | null;
/** A releative render position. */
declare enum RenderPosition {
    Before = 0,
    After = 1,
    In = 2
}
/** Mapped length undefined tuple to a tuple of Contexts. */
declare type ContextTypes<T extends unknown[]> = {
    [Index in keyof T]: Context<T[Index]>;
};
/** Mapped length undefined tuple to a tuple of context subscriptions. */
declare type ContextSubcriptions<T extends unknown[]> = {
    [Index in keyof T]: Subscribable<T[Index]>;
};
/**
 * A display component in the component framework.
 * @typedef P The type of properties for this component.
 * @typedef C The type of context that this component might have.
 */
declare abstract class DisplayComponent<P, Contexts extends unknown[] = []> {
    /** The properties of the component. */
    props: P & ComponentProps;
    /** The context on this component, if any. */
    context?: [...ContextSubcriptions<Contexts>];
    /** The type of context for this component, if any. */
    readonly contextType?: readonly [...ContextTypes<Contexts>];
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props: P);
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender(): void;
    /**
     * A callback that is called after the component is rendered.
     * @param node The component's VNode.
     */
    onAfterRender(node: VNode): void;
    /**
     * Renders the component.
     * @returns A JSX element to be rendered.
     */
    abstract render(): VNode | null;
    /**
     * Destroys this component.
     */
    destroy(): void;
    /**
     * Gets a context data subscription from the context collection.
     * @param context The context to get the subscription for.
     * @returns The requested context.
     * @throws An error if no data for the specified context type could be found.
     */
    protected getContext(context: ContextTypes<Contexts>[number]): ContextSubcriptions<Contexts>[number];
}
/**
 * Base properties for display components.
 */
declare class ComponentProps {
    /** The children of the display component. */
    children?: DisplayChildren[];
    /** A reference to the display component. */
    ref?: NodeReference<any>;
}
/**
 * A constructor signature for a DisplayComponent.
 */
declare type DisplayComponentFactory<P extends ComponentProps, Contexts extends Context<unknown>[] = []> = new (props: P) => DisplayComponent<P, Contexts>;
/**
 * A type for the Fragment function.
 */
declare type FragmentFactory = (props: ComponentProps) => DisplayChildren[] | undefined;
/**
 * A reference to a component or element node.
 */
declare class NodeReference<T extends (DisplayComponent<any> | HTMLElement | SVGElement)> {
    /** The internal reference instance. */
    private _instance;
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance(): T;
    /**
     * Sets the value of the instance.
     */
    set instance(val: T);
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault(): T | null;
}
/**
 * Provides a context of data that can be passed down to child components via a provider.
 */
declare class Context<T> {
    readonly defaultValue: T;
    /**
     * The provider component that can be set to a specific context value.
     * @param props The props of the provider component.
     * @returns A new context provider.
     */
    readonly Provider: (props: ContextProviderProps<T>) => ContextProvider<T>;
    /**
     * Creates an instance of a Context.
     * @param defaultValue The default value of this context.
     */
    constructor(defaultValue: T);
}
/**
 * Props on the ContextProvider component.
 */
interface ContextProviderProps<T> extends ComponentProps {
    /** The value of the context underneath this provider. */
    value: T;
}
/**
 * A provider component that can be set to a specific context value.
 */
declare class ContextProvider<T> extends DisplayComponent<ContextProviderProps<T>> {
    readonly parent: Context<T>;
    /**
     * Creates an instance of a ContextProvider.
     * @param props The props on the component.
     * @param parent The parent context instance for this provider.
     */
    constructor(props: ContextProviderProps<T>, parent: Context<T>);
    /** @inheritdoc */
    render(): VNode | null;
}
/**
 * The FS component namespace.
 */
declare namespace FSComponent {
    /**
     * Definitions for JSX transpilation.
     */
    namespace JSX {
        /**
         * The intrinsic DOM elements that can be defined.
         */
        interface IntrinsicElements {
            [elemName: string]: any;
            /** A reference to the HTML element node. */
            ref?: NodeReference<any>;
        }
    }
    /**
     * A fragment of existing elements with no specific root.
     * @param props The fragment properties.
     * @returns The fragment children.
     */
    function Fragment(props: ComponentProps): DisplayChildren[] | undefined;
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    function buildComponent<T extends DisplayComponentFactory<P> | keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap | FragmentFactory, P extends ComponentProps>(type: T, props: P | null, ...children: DisplayChildren[]): VNode | null;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent: VNode, children: DisplayChildren[]): VNode[] | null;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content: string | number): VNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node: VNode, element: HTMLElement | SVGElement | null, position?: RenderPosition): void;
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node: VNode, element: HTMLElement | SVGElement | null): void;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node: VNode, element: HTMLElement | SVGElement | null): void;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element: HTMLElement | SVGElement | null): void;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef<T extends (DisplayComponent<any, any> | HTMLElement | SVGElement)>(): NodeReference<T>;
    /**
     * Creates a new context to hold data for passing to child components.
     * @param defaultValue The default value of this context.
     * @returns A new context.
     */
    function createContext<T>(defaultValue: T): Context<T>;
    /**
     * Visits VNodes with a supplied visitor function within the given children tree.
     * @param node The node to visit.
     * @param visitor The visitor function to inspect VNodes with. Return true if the search should stop at the visited
     * node and not proceed any further down the node's children.
     */
    function visitNodes(node: VNode, visitor: (node: VNode) => boolean): void;
    /**
     * Parses a space-delimited CSS class string into an array of CSS classes.
     * @param classString A space-delimited CSS class string.
     * @param filter A function which filters parsed classes. For each class, the function should return `true` if the
     * class should be included in the output array and `false` otherwise.
     * @returns An array of CSS classes derived from the specified CSS class string.
     */
    function parseCssClassesFromString(classString: string, filter?: (cssClass: string) => boolean): string[];
    /**
     * Binds a {@link MutableSubscribableSet} to a subscribable set of CSS classes. CSS classes added to and removed from
     * the subscribed set will also be added to and removed from the bound set, with the exception of a set of reserved
     * classes. The presence or absence of any of the reserved classes in the bound set is not affected by the subscribed
     * set; these reserved classes may be freely added to and removed from the bound set.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A set of CSS classes to which to subscribe.
     * @param reservedClasses An iterable of reserved classes.
     * @returns The newly created subscription to the subscribed CSS class set.
     */
    function bindCssClassSet(setToBind: MutableSubscribableSet<string>, classesToSubscribe: SubscribableSet<string>, reservedClasses: Iterable<string>): Subscription;
    /**
     * Traverses a VNode tree in depth-first order and destroys the first {@link DisplayComponent} encountered in each
     * branch of the tree.
     * @param root The root of the tree to traverse.
     */
    function shallowDestroy(root: VNode): void;
    /**
     * An empty callback handler.
     */
    const EmptyHandler: () => void;
}
/**
 * A system that handles the registration and boostrapping of plugin scripts.
 */
declare class PluginSystem<T extends AvionicsPlugin<B>, B> {
    private readonly scripts;
    private readonly plugins;
    /** The avionics specific plugin binder to inject into each plugin. */
    binder?: B;
    /** An event subscribable that publishes when a new component is about to be created. */
    readonly creatingHandlers: ((constructor: DisplayComponentFactory<any>, props: any) => DisplayComponent<any> | undefined)[];
    /** An event subscribable that publishes when a new component is created. */
    readonly createdHandlers: ((component: DisplayComponent<any>) => void)[];
    /** An event subscribable that publishes when a component has finished rendering. */
    readonly renderedHandlers: ((node: VNode) => void)[];
    private pluginViewListener;
    private readonly initViewListenerPromise;
    /**
     * Ctor
     */
    constructor();
    /**
     * Adds plugin scripts to load to the system.
     * @param document The panel.xml document to load scripts from.
     * @param instrumentId The ID of the instrument.
     * @param globalPluginTargetFunc A function that returns true if a global plugin should be loaded.
     * @example
     * await this.pluginSystem.addScripts(this.instrument.xmlConfig, this.instrument.templateID, (target) => {
     *   return target === this.instrument.templateID;
     * });
     */
    addScripts(document: XMLDocument, instrumentId: string, globalPluginTargetFunc: (target: string) => boolean): Promise<void>;
    /**
     * Starts the plugin system with the included avionics specific plugin binder.
     * @param binder The plugin binder to pass to the individual plugins.
     */
    startSystem(binder: B): Promise<void>;
    /**
     * Adds a plugin to the plugin system.
     * @param plugin The plugin to add.
     */
    addPlugin(plugin: T): void;
    /**
     * Runs the provided function on all of the registered plugins.
     * @param fun The function to run.
     */
    callPlugins(fun: (plugin: T) => void): void;
    /**
     * Subscribes a handler to the component creating hook.
     * @param handler The handler to subscribe.
     */
    subscribeOnComponentCreating(handler: (constructor: DisplayComponentFactory<any>, props: any) => DisplayComponent<any> | undefined): void;
    /**
     * A hook that allows plugins to replace components that are about to be created with their own implementations.
     * @param constructor The display component constructor that is going to be used.
     * @param props The component props that will be passed into the component.
     * @returns Returns either the display component that will replace, or undefined if the component should not be replaced.
     */
    onComponentCreating(constructor: DisplayComponentFactory<any>, props: any): DisplayComponent<any> | undefined;
    /**
     * Subscribes a handler to the component created hook.
     * @param handler The handler to subscribe.
     */
    subscribeOnComponentCreated(handler: (component: DisplayComponent<any>) => void): void;
    /**
     * A hook that allows plugins to observe components as they are created.
     * @param component The component that was created.
     */
    onComponentCreated(component: DisplayComponent<any>): void;
    /**
     * Subscribes a handler to the component rendered hook.
     * @param handler The handler to subscribe.
     */
    subscribeOnComponentRendered(handler: (node: VNode) => void): void;
    /**
     * A hook that allows plugins to observe built VNodes after they are rendered.
     * @param node The node that was rendered.
     */
    onComponentRendered(node: VNode): void;
}
/**
 * A plugin that is created and managed by the plugin system.
 */
declare abstract class AvionicsPlugin<T> {
    protected readonly binder: T;
    /**
     * Creates an instance of a Plugin.
     * @param binder The avionics specific plugin binder to accept from the system.
     */
    constructor(binder: T);
    /**
     * A callback run when the plugin has been installed.
     */
    abstract onInstalled(): void;
    /**
     * An optional hook called when a component is about to be created. Returning a component causes
     * that component to be used instead of the one that was to be created, and returning undefined
     * will cause the original component to be created. If this hook is present, it will be called
     * for EVERY component instantiation, so be sure to ensure that this code is well optimized.
     */
    onComponentCreating?: (constructor: DisplayComponentFactory<any>, props: any) => DisplayComponent<any> | undefined;
    /**
     * An optional hook called when a component is created. If this hook is present,
     * it will be called for EVERY component instantiation, so be sure to ensure
     * that this code is well optimized.
     */
    onComponentCreated?: (component: DisplayComponent<any>) => void;
    /**
     * An optional hook called when a component has completed rendering. If this hook
     * is present, it will be called for EVERY component render completion, so be sure
     * to ensure that this code is well optimized.
     */
    onComponentRendered?: (node: VNode) => void;
    /**
     * Loads a CSS file into the instrument.
     * @param uri The URI to the CSS file.
     */
    protected loadCss(uri: string): Promise<void>;
}
/**
 * Registers a plugin with the plugin system.
 * @param plugin The plugin to register.
 */
declare function registerPlugin<T>(plugin: new (binder: T) => AvionicsPlugin<T>): void;
declare const Fragment: typeof FSComponent.Fragment;

/**
 * Weather radar mode data for the BingComponent.
 */
interface WxrMode {
    /** The weather mode. */
    mode: EWeatherRadar;
    /** The size of the weather radar arc in front of the plane, in radians. */
    arcRadians: number;
}
/**
 * Component props for the MapComponent.
 */
interface BingComponentProps extends ComponentProps {
    /** The unique ID to assign to this Bing component. */
    id: string;
    /** The mode of the Bing component. */
    mode: EBingMode;
    /** A callback to call when the Bing component is bound. */
    onBoundCallback?: (component: BingComponent) => void;
    /** The internal resolution for the Bing component, as `[width, height]` in pixels. Defaults to 1024x1024 pixels. */
    resolution?: Subscribable<ReadonlyFloat64Array>;
    /**
     * The earth colors for the Bing component. Index 0 defines the water color, and indexes 1 to the end of the array
     * define the terrain colors. Each color should be expressed as `R + G * 256 + B * 256^2`. If not defined, all colors
     * default to black.
     */
    earthColors?: SubscribableArray<number>;
    /**
     * The elevation range over which to assign the earth terrain colors, as `[minimum, maximum]` in feet. The terrain
     * colors are assigned at regular intervals over the entire elevation range, starting with the first terrain color at
     * the minimum elevation and ending with the last terrain color at the maximum elevation. Terrain below and above the
     * minimum and maximum elevation are assigned the first and last terrain colors, respectively. Defaults to
     * `[0, 30000]`.
     */
    earthColorsElevationRange?: Subscribable<ReadonlyFloat64Array>;
    /**
     * The sky color for the Bing component. The sky color is only visible in synthetic vision (`EBingMode.HORIZON`)
     * mode. The color should be expressed as `R + G * 256 + B * 256^2`. Defaults to black.
     */
    skyColor?: Subscribable<number>;
    /** The reference mode for the Bing component. Defaults to `EBingReference.SEA`. */
    reference?: Subscribable<EBingReference>;
    /** The weather radar mode for the Bing component. Defaults to `EWeatherRadar.NONE`. */
    wxrMode?: Subscribable<WxrMode>;
    /**
     * The weather radar colors for the Bing component. Each entry `E_i` of the array is a tuple `[color, rate]` that
     * defines a color stop, where `color` is an RGBA color expressed as `R + G * 256 + B * 256^2 + A * 256^3` and `rate`
     * is a precipitation rate in millimeters per hour.
     *
     * In general, the color defined by `E_i` is applied to precipitation rates ranging from the rate defined by `E_i-1`
     * to the rate defined by `E_i`. There are two special cases. The color defined by `E_0` is applied to the
     * precipitation rates from zero to the rate defined by `E_0`. The color defined by `E_n-1`, where `n` is the length
     * of the array, is applied to the precipitation rates from the rate defined by `E_n-2` to positive infinity.
     *
     * If not defined, the colors default to {@link BingComponent.DEFAULT_WEATHER_COLORS}.
     */
    wxrColors?: SubscribableArray<readonly [number, number]>;
    /** Whether isolines should be shown. Defaults to `false`. */
    isoLines?: Subscribable<boolean>;
    /**
     * How long to delay binding the map in ms. Defaults to 3000.
     */
    delay?: number;
    /** CSS class(es) to add to the Bing component's image. */
    class?: string | SubscribableSet<string>;
}
/**
 * A FSComponent that displays the MSFS Bing Map, weather radar, and 3D terrain.
 */
declare class BingComponent extends DisplayComponent<BingComponentProps> {
    /** The default resolution of the Bing Map along both horizontal and vertical axes, in pixels. */
    static readonly DEFAULT_RESOLUTION = 1024;
    static readonly DEFAULT_WEATHER_COLORS: readonly (readonly [number, number])[];
    private static readonly POSITION_RADIUS_INHIBIT_FRAMES;
    private readonly modeFlags;
    private mapListener;
    private isListenerRegistered;
    private readonly imgRef;
    private binder?;
    private uid;
    private _isBound;
    private _isAwake;
    private isDestroyed;
    private pos;
    private radius;
    private readonly resolution;
    private readonly earthColors;
    private readonly earthColorsElevationRange;
    private readonly skyColor;
    private readonly reference;
    private readonly wxrMode;
    private readonly wxrColors;
    private readonly isoLines;
    private readonly wxrColorsArray;
    private readonly wxrRateArray;
    private gameStateSub?;
    private resolutionSub?;
    private earthColorsSub?;
    private earthColorsElevationRangeSub?;
    private skyColorSub?;
    private referenceSub?;
    private wxrModeSub?;
    private wxrColorsSub?;
    private isoLinesSub?;
    private readonly resolutionHandler;
    private readonly earthColorsHandler;
    private readonly earthColorsElevationRangeHandler;
    private readonly skyColorHandler;
    private readonly referenceHandler;
    private readonly wxrModeHandler;
    private readonly wxrColorsHandler;
    private readonly isoLinesHandler;
    private setCurrentMapParamsTimer;
    private positionRadiusInhibitFramesRemaining;
    private isPositionRadiusPending;
    private readonly positionRadiusInhibitTimer;
    private readonly processPendingPositionRadius;
    /**
     * Checks whether this Bing component has been bound.
     * @returns whether this Bing component has been bound.
     */
    isBound(): boolean;
    /**
     * Checks whether this Bing component is awake.
     * @returns whether this Bing component is awake.
     */
    isAwake(): boolean;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Registers this component's Bing map listener.
     */
    private registerListener;
    /**
     * A callback called when this component's Bing map listener is registered.
     */
    private onListenerRegistered;
    /**
     * A callback called when the listener is fully bound.
     * @param binder The binder from the listener.
     * @param uid The unique ID of the bound map.
     */
    private onListenerBound;
    /**
     * A callback called when the map image is updated.
     * @param uid The unique ID of the bound map.
     * @param imgSrc The img tag src attribute to assign to the bing map image.
     */
    private onMapUpdate;
    /**
     * Calls the position and radius set function to set map parameters.
     */
    private setCurrentMapParams;
    /**
     * Wakes this Bing component. Upon awakening, this component will synchronize its state from when it was put to sleep
     * to the Bing instance to which it is bound.
     */
    wake(): void;
    /**
     * Puts this Bing component to sleep. While asleep, this component cannot make changes to the Bing instance to which
     * it is bound.
     */
    sleep(): void;
    /**
     * Sets the center position and radius.
     * @param pos The center position.
     * @param radius The radius, in meters.
     */
    setPositionRadius(pos: LatLong, radius: number): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
    /**
     * Resets the img element's src attribute.
     */
    resetImgSrc(): void;
    /**
     * Converts an HTML hex color string to a numerical RGB value, as `R + G * 256 + B * 256^2`.
     * @param hexColor The hex color string to convert.
     * @returns The numerical RGB value equivalent of the specified hex color string, as `R + G * 256 + B * 256^2`.
     */
    static hexaToRGBColor(hexColor: string): number;
    /**
     * Converts a numerical RGB value to an HTML hex color string.
     * @param rgb The numerical RGB value to convert, as `R + G * 256 + B * 256^2`.
     * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
     * @returns The HTML hex color string equivalent of the specified numerical RGB value.
     */
    static rgbToHexaColor(rgb: number, poundPrefix?: boolean): string;
    /**
     * Converts RGB color components to a numerical RGB value, as `R + G * 256 + B * 256^2`.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @returns The numerical RGB value of the specified components, as `R + G * 256 + B * 256^2`.
     */
    static rgbColor(r: number, g: number, b: number): number;
    /**
     * Converts an HTML hex color string to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param hexColor The hex color string to convert.
     * @returns The numerical RGBA value equivalent of the specified hex color string, as
     * `R + G * 256 + B * 256^2 + A * 256^3`.
     */
    static hexaToRGBAColor(hexColor: string): number;
    /**
     * Converts a numerical RGBA value to an HTML hex color string.
     * @param rgba The numerical RGBA value to convert, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
     * @returns The HTML hex color string equivalent of the specified numerical RGBA value.
     */
    static rgbaToHexaColor(rgba: number, poundPrefix?: boolean): string;
    /**
     * Converts RGBA color components to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @param a The alpha component, from 0 to 255.
     * @returns The numerical RGBA value of the specified components, as `R + G * 256 + B * 256^2 + A * 256^3`.
     */
    static rgbaColor(r: number, g: number, b: number, a: number): number;
    /**
     * Creates a full Bing component earth colors array. The earth colors array will contain the specified water color
     * and terrain colors (including interpolated values between the explicitly defined ones, as necessary).
     * @param waterColor The desired water color, as a hex string with the format `#hhhhhh`.
     * @param terrainColors An array of desired terrain colors at specific elevations. Elevations should be specified in
     * feet and colors as hex strings with the format `#hhhhhh`.
     * @param minElevation The minimum elevation to which to assign a color, in feet. Defaults to 0.
     * @param maxElevation The maximum elevation to which to assign a color, in feet. Defaults to 30000.
     * @param stepCount The number of terrain color steps. Defaults to 61.
     * @returns a full Bing component earth colors array.
     */
    static createEarthColorsArray(waterColor: string, terrainColors: {
        elev: number;
        color: string;
    }[], minElevation?: number, maxElevation?: number, stepCount?: number): number[];
}

/**
 * Utility type to get the family of a unit type.
 */
declare type FamilyOfUnit<U extends Unit<string>> = U extends Unit<infer T> ? T : never;
/**
 * Utility type to get the Unit type from a NumberUnit type.
 */
declare type UnitOfNumber<N extends NumberUnitInterface<string>> = N extends NumberUnitInterface<string, infer U> ? U : never;
/**
 * A numeric value with unit type.
 */
interface NumberUnitInterface<F extends string, U extends Unit<F> = Unit<F>> {
    /** This NumberUnit's numeric value. */
    number: number;
    /** This NumberUnit's unit type. */
    unit: U;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale<OU extends Unit<F>>(factor: number, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @returns The ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: NumberUnitInterface<F>): number;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns the ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: number, unit: Unit<F>): number;
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs<OU extends Unit<F>>(out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: NumberUnitInterface<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: number, unit?: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is equal to another value. Two values are considered equal if and only if their
     * unit types are interconvertable and when converted to the same unit type, their numeric values are equal to each
     * other or both equal to `NaN`.
     * @param value The other value.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: NumberUnitInterface<string>): boolean;
    /**
     * Checks whether this NumberUnit is equal to another value. Two values are considered equal if and only if their
     * unit types are interconvertable and when converted to the same unit type, their numeric values are equal to each
     * other or both equal to `NaN`.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: number, unit?: Unit<string>): boolean;
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN(): boolean;
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy(): NumberUnit<F, U>;
}
/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
declare class NumberUnit<F extends string, U extends Unit<F> = Unit<F>> implements NumberUnitInterface<F, U> {
    private _number;
    private _unit;
    readonly readonly: NumberUnitReadOnly<F, U>;
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number: number, unit: U);
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number(): number;
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit(): U;
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    private toNumberOfThisUnit;
    /**
     * Sets this NumberUnit's numeric value. This method will not change this NumberUnit's unit type. If the supplied
     * value cannot be converted to this NumberUnit's unit type, this NumberUnit will not be changed and this method will
     * return undefined.
     * @param value - the new value.
     * @returns this NumberUnit, after it has been changed, or undefined if the operation could not be carried out.
     */
    set(value: NumberUnitInterface<F>): this;
    /**
     * Sets this NumberUnit's numeric value. This method will not change this NumberUnit's unit type.
     * @param value - the new value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type.
     * @returns this NumberUnit, after it has been changed.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    set(value: number, unit?: Unit<F>): this;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Adds a value to this NumberUnit in place and returns the result.
     * @param value The other value.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add(value: NumberUnitInterface<F>): this;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Adds a value to this NumberUnit in place and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add(value: number, unit: Unit<F>): this;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit in place and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result. Defaults to this NumberUnit.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract(value: NumberUnitInterface<F>): this;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit in place and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract(value: number, unit: Unit<F>): this;
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale<OU extends Unit<F>>(factor: number, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Scales this NumberUnit by a unit-less factor in place and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale(factor: number): this;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @returns The ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: NumberUnitInterface<F>): number;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns the ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: number, unit: Unit<F>): number;
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs<OU extends Unit<F>>(out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Calculates the absolute value of this NumberUnit in place and returns the result.
     * @returns The absolute value.
     */
    abs(): this;
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: NumberUnitInterface<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: number, unit?: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is equal to another value. Two values are considered equal if and only if their
     * unit types are interconvertable and when converted to the same unit type, their numeric values are equal to each
     * other or both equal to `NaN`.
     * @param value The other value.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: NumberUnitInterface<string>): boolean;
    /**
     * Checks whether this NumberUnit is equal to another value. Two values are considered equal if and only if their
     * unit types are interconvertable and when converted to the same unit type, their numeric values are equal to each
     * other or both equal to `NaN`.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: number, unit?: Unit<string>): boolean;
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN(): boolean;
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy(): NumberUnit<F, U>;
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
declare class NumberUnitReadOnly<F extends string, U extends Unit<F> = Unit<F>> implements NumberUnitInterface<F, U> {
    private readonly source;
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source: NumberUnit<F, U>);
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number(): number;
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit(): U;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Adds a value to this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The sum.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    add<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: NumberUnitInterface<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Subtracts a value from this NumberUnit and returns the result.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @param out The NumberUnit to which to write the result.
     * @returns The difference.
     * @throws Error if the supplied value cannot be converted to this NumberUnit's unit type.
     */
    subtract<OU extends Unit<F>>(value: number, unit: Unit<F>, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale<OU extends Unit<F>>(factor: number, out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @returns The ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: NumberUnitInterface<F>): number;
    /**
     * Finds the ratio of this NumberUnit to another value.
     * @param value The other value.
     * @param unit The unit type of the other value.
     * @returns the ratio.
     * @throws Error if the other value cannot be converted to this NumberUnit's unit type.
     */
    ratio(value: number, unit: Unit<F>): number;
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs<OU extends Unit<F>>(out: NumberUnit<F, OU>): NumberUnit<F, OU>;
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: NumberUnitInterface<F>): number;
    /**
     * Checks whether this NumberUnit is greater than, equal to, or less than another value.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns 0 if this NumberUnit is equal to the other value, -1 if this number is less, 1 if this number is greater.
     * @throws Error if this NumberUnit cannot be compared to the other value.
     */
    compare(value: number, unit?: Unit<F>): number;
    /**
     * Checks whether this NumberUnit is equal to another value. Two values are considered equal if and only if their
     * unit types are interconvertable and when converted to the same unit type, their numeric values are equal to each
     * other or both equal to `NaN`.
     * @param value The other value.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: NumberUnitInterface<string>): boolean;
    /**
     * Checks whether this NumberUnit is equal to another value. Two values are considered equal if and only if their
     * unit types are interconvertable and when converted to the same unit type, their numeric values are equal to each
     * other or both equal to `NaN`.
     * @param value The other value.
     * @param unit The unit type of the other value. Defaults to this NumberUnit's unit type.
     * @returns Whether this NumberUnit is equal to the other value.
     */
    equals(value: number, unit?: Unit<string>): boolean;
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN(): boolean;
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy(): NumberUnit<F, U>;
}
/**
 * A unit of measurement.
 */
interface Unit<F extends string> {
    /** This unit's family. */
    readonly family: F;
    /** This unit's name. */
    readonly name: string;
    /**
     * Checks whether conversions between this unit and another unit are possible.
     * @param otherUnit The other unit.
     * @returns Whether conversions between this unit and another unit are possible.
     */
    canConvert(otherUnit: Unit<string>): boolean;
    /**
     * Converts a value of this unit to another unit.
     * @param value The value to convert.
     * @param toUnit The unit to which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertTo(value: number, toUnit: Unit<F>): number;
    /**
     * Converts a value of another unit to this unit.
     * @param value The value to convert.
     * @param fromUnit The unit from which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertFrom(value: number, fromUnit: Unit<F>): number;
    /**
     * Creates a NumberUnit with a specified initial value of this unit type.
     * @param value The numeric value of the new NumberUnit.
     * @returns A NumberUnit of this unit type.
     */
    createNumber(value: number): NumberUnit<F, this>;
    /**
     * Checks whether this unit is equal to another unit. Returns true if and only if the other unit belongs to the same
     * family and has the same name as this unit.
     * @param other The other unit to which to compare.
     * @returns Whether this unit is equal to the comparison.
     */
    equals(other: Unit<string>): boolean;
}
/**
 * A unit type that can be compounded.
 */
interface CompoundableUnit<F extends string> extends Unit<F> {
    /** The relative linear scale of this unit compared to the standard unit of the same family. */
    readonly scaleFactor: number;
}
/**
 * A unit of measurement.
 */
declare abstract class AbstractUnit<F extends string> implements Unit<F> {
    readonly name: string;
    abstract readonly family: F;
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name: string);
    /** @inheritdoc */
    canConvert(otherUnit: Unit<string>): boolean;
    /** @inheritdoc */
    abstract convertTo(value: number, toUnit: Unit<F>): number;
    /** @inheritdoc */
    abstract convertFrom(value: number, fromUnit: Unit<F>): number;
    /** @inheritdoc */
    createNumber(value: number): NumberUnit<F, this>;
    /** @inheritdoc */
    equals(other: Unit<string>): boolean;
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
declare class SimpleUnit<F extends string> extends AbstractUnit<F> implements CompoundableUnit<F> {
    readonly family: F;
    readonly scaleFactor: number;
    readonly zeroOffset: number;
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family: F, name: string, scaleFactor: number, zeroOffset?: number);
    /** @inheritdoc */
    canConvert(otherUnit: Unit<string>): boolean;
    /** @inheritdoc */
    convertTo(value: number, toUnit: Unit<F>): number;
    /** @inheritdoc */
    convertFrom(value: number, fromUnit: Unit<F>): number;
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
declare class CompoundUnit<F extends string> extends AbstractUnit<F> {
    readonly family: F;
    private readonly numerator;
    private readonly denominator;
    protected readonly scaleFactor: number;
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(family: F, numerator: CompoundableUnit<string>[], denominator: CompoundableUnit<string>[], name?: string);
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    private getScaleFactor;
    /** @inheritdoc */
    canConvert(otherUnit: Unit<string>): boolean;
    /** @inheritdoc */
    convertTo(value: number, toUnit: Unit<F>): number;
    /** @inheritdoc */
    convertFrom(value: number, fromUnit: Unit<F>): number;
}
/**
 * Predefined unit families.
 */
declare enum UnitFamily {
    Distance = "distance",
    Angle = "angle",
    Duration = "duration",
    Weight = "weight",
    Volume = "volume",
    Pressure = "pressure",
    Temperature = "temperature",
    TemperatureDelta = "temperature_delta",
    Speed = "speed",
    Acceleration = "acceleration",
    WeightFlux = "weight_flux",
    VolumeFlux = "volume_flux"
}
/**
 * Predefined unit types.
 */
declare class UnitType {
    static readonly METER: SimpleUnit<UnitFamily.Distance>;
    static readonly FOOT: SimpleUnit<UnitFamily.Distance>;
    static readonly KILOMETER: SimpleUnit<UnitFamily.Distance>;
    /** Statute mile. */
    static readonly MILE: SimpleUnit<UnitFamily.Distance>;
    /** Nautical mile. */
    static readonly NMILE: SimpleUnit<UnitFamily.Distance>;
    /** Great-arc radian. The average radius of Earth. */
    static readonly GA_RADIAN: SimpleUnit<UnitFamily.Distance>;
    static readonly RADIAN: SimpleUnit<UnitFamily.Angle>;
    static readonly DEGREE: SimpleUnit<UnitFamily.Angle>;
    static readonly ARC_MIN: SimpleUnit<UnitFamily.Angle>;
    static readonly ARC_SEC: SimpleUnit<UnitFamily.Angle>;
    static readonly MILLISECOND: SimpleUnit<UnitFamily.Duration>;
    static readonly SECOND: SimpleUnit<UnitFamily.Duration>;
    static readonly MINUTE: SimpleUnit<UnitFamily.Duration>;
    static readonly HOUR: SimpleUnit<UnitFamily.Duration>;
    static readonly KILOGRAM: SimpleUnit<UnitFamily.Weight>;
    static readonly POUND: SimpleUnit<UnitFamily.Weight>;
    static readonly TON: SimpleUnit<UnitFamily.Weight>;
    static readonly TONNE: SimpleUnit<UnitFamily.Weight>;
    /** Weight equivalent of one liter of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly LITER_FUEL: SimpleUnit<UnitFamily.Weight>;
    /** Weight equivalent of one gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly GALLON_FUEL: SimpleUnit<UnitFamily.Weight>;
    /** Weight equivalent of one imperial gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly IMP_GALLON_FUEL: SimpleUnit<UnitFamily.Weight>;
    static readonly LITER: SimpleUnit<UnitFamily.Volume>;
    static readonly GALLON: SimpleUnit<UnitFamily.Volume>;
    /** Hectopascal. */
    static readonly HPA: SimpleUnit<UnitFamily.Pressure>;
    /** Atmosphere. */
    static readonly ATM: SimpleUnit<UnitFamily.Pressure>;
    /** Inch of mercury. */
    static readonly IN_HG: SimpleUnit<UnitFamily.Pressure>;
    /** Millimeter of mercury. */
    static readonly MM_HG: SimpleUnit<UnitFamily.Pressure>;
    static readonly KELVIN: SimpleUnit<UnitFamily.Temperature>;
    static readonly CELSIUS: SimpleUnit<UnitFamily.Temperature>;
    static readonly FAHRENHEIT: SimpleUnit<UnitFamily.Temperature>;
    static readonly RANKINE: SimpleUnit<UnitFamily.Temperature>;
    /** Change in degrees Celsius. */
    static readonly DELTA_CELSIUS: SimpleUnit<UnitFamily.TemperatureDelta>;
    /** Change in degrees Fahrenheit. */
    static readonly DELTA_FAHRENHEIT: SimpleUnit<UnitFamily.TemperatureDelta>;
    static readonly KNOT: CompoundUnit<UnitFamily.Speed>;
    /** Kilometer per hour. */
    static readonly KPH: CompoundUnit<UnitFamily.Speed>;
    /** Miles per hour. */
    static readonly MPH: CompoundUnit<UnitFamily.Speed>;
    /** Meter per minute. */
    static readonly MPM: CompoundUnit<UnitFamily.Speed>;
    /** Meter per second. */
    static readonly MPS: CompoundUnit<UnitFamily.Speed>;
    /** Foot per minute. */
    static readonly FPM: CompoundUnit<UnitFamily.Speed>;
    /** Foot per second. */
    static readonly FPS: CompoundUnit<UnitFamily.Speed>;
    /** Meter per minute per second. */
    static readonly MPM_PER_SEC: CompoundUnit<UnitFamily.Acceleration>;
    /** Meter per second per second. */
    static readonly MPS_PER_SEC: CompoundUnit<UnitFamily.Acceleration>;
    /** Foot per minute per second. */
    static readonly FPM_PER_SEC: CompoundUnit<UnitFamily.Acceleration>;
    /** Foot per second per second. */
    static readonly FPS_PER_SEC: CompoundUnit<UnitFamily.Acceleration>;
    /** Average gravitational acceleration on Earth at sea level. */
    static readonly G_ACCEL: CompoundUnit<UnitFamily.Acceleration>;
    /** Kilogram per hour. */
    static readonly KGH: CompoundUnit<UnitFamily.WeightFlux>;
    /** Pound per hour. */
    static readonly PPH: CompoundUnit<UnitFamily.WeightFlux>;
    /** Weight equivalent of one liter of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly LPH_FUEL: CompoundUnit<UnitFamily.WeightFlux>;
    /** Weight equivalent of one gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly GPH_FUEL: CompoundUnit<UnitFamily.WeightFlux>;
    /** Weight equivalent of one imperial gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
    static readonly IGPH_FUEL: CompoundUnit<UnitFamily.WeightFlux>;
}

/**
 * Component props for AbstractNumberUnitDisplay.
 */
interface AbstractNumberUnitDisplayProps<F extends string> extends ComponentProps {
    /** The {@link NumberUnitInterface} value to display, or a subscribable which provides it. */
    value: NumberUnitInterface<F> | Subscribable<NumberUnitInterface<F>>;
    /**
     * The unit type in which to display the value, or a subscribable which provides it. If the unit is `null`, then the
     * native type of the value is used instead.
     */
    displayUnit: Unit<F> | null | Subscribable<Unit<F> | null>;
}
/**
 * A component which displays a number with units.
 */
declare abstract class AbstractNumberUnitDisplay<F extends string, P extends AbstractNumberUnitDisplayProps<F> = AbstractNumberUnitDisplayProps<F>> extends DisplayComponent<P> {
    /** A subscribable which provides the value to display. */
    protected readonly value: Subscribable<NumberUnitInterface<F>>;
    /** A subscribable which provides the unit type in which to display the value. */
    protected readonly displayUnit: Subscribable<Unit<F> | null>;
    private valueSub?;
    private displayUnitSub?;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * A callback which is called when this component's bound value changes.
     * @param value The new value.
     */
    protected abstract onValueChanged(value: NumberUnitInterface<F>): void;
    /**
     * A callback which is called when this component's bound display unit changes.
     * @param displayUnit The new display unit.
     */
    protected abstract onDisplayUnitChanged(displayUnit: Unit<F> | null): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for DigitScroller.
 */
interface DigitScrollerProps extends ComponentProps {
    /** The value to which the scroller is bound. */
    value: Subscribable<number>;
    /** The number base used by the scroller. Must be an integer greater than or equal to `3`. */
    base: number;
    /**
     * The factor represented by the scroller's digit. The factor relates the digit to its nominal value as
     * `value = digit * factor`. Cannot be `0`.
     */
    factor: number;
    /**
     * The amount the scroller's value must deviate from the current displayed digit's nominal value before the digit
     * begins to scroll. Defaults to `0`.
     */
    scrollThreshold?: number;
    /**
     * A function which renders each digit of the scroller to a text string. If not defined, each digit will be rendered
     * using the `Number.toString()` method.
     */
    renderDigit?: (digit: number) => string;
    /** The string to render when the scroller's value is `NaN`. Defaults to `–`. */
    nanString?: string;
    /** CSS class(es) to apply to the root of the digit scroller. */
    class?: string | SubscribableSet<string>;
}
/**
 * A scrolling digit display.
 */
declare class DigitScroller extends DisplayComponent<DigitScrollerProps> {
    private readonly digitCount;
    private readonly translationPerDigit;
    private readonly tapeStyle;
    private readonly nanTextStyle;
    private readonly digitPlaceFactor;
    private readonly scrollThreshold;
    private readonly translateY;
    private valueSub?;
    private cssClassSub?;
    /** @inheritdoc */
    constructor(props: DigitScrollerProps);
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * Updates this display.
     * @param value This display's value.
     */
    private update;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Renders text for each of this display's individual digits.
     * @returns This display's individual digit text, as an array of VNodes.
     */
    private renderDigits;
    /** @inheritdoc */
    destroy(): void;
}

declare enum DurationDisplayFormat {
    /** hh:mm:ss. */
    hh_mm_ss = 0,
    /** hh:mm. */
    hh_mm = 1,
    /** mm:ss. */
    mm_ss = 2,
    /** hh:mm if value is greater or equal to 1 hour, otherwise mm:ss. */
    hh_mm_or_mm_ss = 3
}
declare enum DurationDisplayDelim {
    /** Colon (`:`). */
    Colon = 0,
    /** `:` if hh:mm:ss or mm:ss, `+` if hh:mm. */
    ColonOrCross = 1,
    /** Space (` `). */
    Space = 2
}
/**
 * Formatting options for DurationDisplay.
 */
declare type DurationDisplayOptions = {
    /** The format with which to display values. */
    format: DurationDisplayFormat;
    /** The delimiter to insert between parts of formatted values. */
    delim: DurationDisplayDelim;
    /** The number of digits to which to pad the first part of formatted values with leading zeroes. */
    pad: number;
    /** A function used to format the last part of formatted values. */
    numberFormatter: (value: number) => string;
    /** Whether to show units. */
    showUnits: boolean;
    /** A function used to format units. */
    unitFormatter: (value: number, unit: Unit<UnitFamily.Duration>) => string;
    /** Whether to use a minus sign (`−`) in place of a dash (`-`) in front of negative numbers. */
    useMinusSign: boolean;
    /** Whether to force the display of a positive sign. */
    forceSign: boolean;
    /** The string to display when the value is NaN. */
    nanString: string;
};
/**
 * Component props for DurationDisplay.
 */
interface DurationDisplayProps extends ComponentProps {
    /** The duration to display, or a subscribable which provides it. */
    value: NumberUnitInterface<UnitFamily.Duration> | Subscribable<NumberUnitInterface<UnitFamily.Duration>>;
    /**
     * Formatting options. Options not explicitly defined will be set to the following default values:
     * * `pad = 0`
     * * `format = DurationDisplayFormat.hh_mm_ss`
     * * `delim = DurationDisplayDelim.Colon`
     * * `showUnits = false`
     * * `useMinusSign = false`
     * * `forceSign = false`
     * * `nanString = ''`
     */
    options?: Partial<Readonly<DurationDisplayOptions>>;
    /** CSS class(es) to add to the root of the icon component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A component which displays duration values.
 */
declare class DurationDisplay extends DisplayComponent<DurationDisplayProps> {
    /** Default formatting options. */
    static readonly DEFAULT_OPTIONS: Readonly<DurationDisplayOptions>;
    private readonly value;
    private valueSub?;
    private readonly options;
    private readonly delim;
    private readonly negativeSign;
    private readonly positiveSign;
    private readonly text;
    /** @inheritdoc */
    constructor(props: DurationDisplayProps);
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * A callback which is called when this component's bound value changes.
     * @param value The new value.
     */
    private onValueChanged;
    /**
     * Displays this component's current value.
     * @param value The current value.
     */
    private setDisplay;
    /**
     * Pads the integer part of a string which represents a number.
     * @param str A string which represents a number.
     * @param maxLength The length to which the integer part of the string will be padded.
     * @param fillString The string with which to pad the original string.
     * @returns a new string which is the result of padding the original string.
     */
    private static padIntegerPart;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A set of latitude/longitude coordinates.
 */
interface LatLonInterface {
    /** The latitude, in degrees. */
    lat: number;
    /** The longitude, in degrees. */
    lon: number;
}
/**
 * A set of latitude/longitude coordinates.
 */
interface LatLongInterface {
    /** The latitude, in degrees. */
    lat: number;
    /** The longitude, in degrees. */
    long: number;
}

/**
 * A representation of a point on Earth's surface.
 */
interface GeoPointInterface {
    /** The latitude of the point. */
    lat: number;
    /** The longitude of the point. */
    lon: number;
    /**
     * Calculates the great-circle distance between this point and another point.
     * @param other The point to which to calculate the distance.
     * @returns The great-circle distance to the other point, in great-arc radians.
     */
    distance(other: LatLonInterface): number;
    /**
     * Calculates the great-circle distance between this point and another point.
     * @param lat The latitude of the point to which to calculate the distance.
     * @param lon The longitude of the point to which to calculate the distance.
     * @returns The great-circle distance to the other point, in great-arc radians.
     */
    distance(lat: number, lon: number): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param other The other point.
     * @returns The rhumb-line distance to the other point, in great-arc radians.
     */
    distanceRhumb(other: LatLonInterface): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @returns The rhumb-line distance to the other point, in great-arc radians.
     */
    distanceRhumb(lat: number, lon: number): number;
    /**
     * Calculates the initial true bearing (forward azimuth) from this point to another point along the great circle
     * connecting the two.
     * @param other The other point.
     * @returns The initial true bearing to the other point, in degrees.
     */
    bearingTo(other: LatLonInterface): number;
    /**
     * Calculates the initial true bearing (forward azimuth) from this point to another point along the great circle
     * connecting the two.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @returns The initial true bearing to the other point, in degrees.
     */
    bearingTo(lat: number, lon: number): number;
    /**
     * Calculates the final true bearing from another point to this point (i.e. the back azimuth from this point to the
     * other point) along the great circle connecting the two.
     * @param other The other point.
     * @returns The final true bearing from the other point, in degrees.
     */
    bearingFrom(other: LatLonInterface): number;
    /**
     * Calculates the final true bearing from another point to this point (i.e. the back azimuth from this point to the
     * other point) along the great circle connecting the two.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @returns The final true bearing from the other point, in degrees.
     */
    bearingFrom(lat: number, lon: number): number;
    /**
     * Calculates the constant true bearing from this point to another point along the rhumb line connecting the two.
     * @param other The other point.
     * @returns The constant true bearing to the other point, in degrees.
     */
    bearingRhumb(other: LatLonInterface): number;
    /**
     * Calculates the constant true bearing from this point to another point along the rhumb line connecting the two.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @returns The constant true bearing to the other point, in degrees.
     */
    bearingRhumb(lat: number, lon: number): number;
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result.
     * @returns The offset point.
     */
    offset(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result.
     * @returns The offset point.
     */
    offsetRhumb(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint to which to write the result.
     * @returns The antipode of this point.
     */
    antipode(out?: GeoPoint): GeoPoint;
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out: Float64Array): Float64Array;
    /**
     * Checks whether this point is equal to another point. Two points are considered equal if and only if the great-
     * circle distance between them is less than or equal to a specified tolerance or if the latitude and longitude
     * components of both points are equal to `NaN`.
     * @param other The other point.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians.
     * @returns Whether this point is equal to the other point.
     */
    equals(other: LatLonInterface, tolerance?: number): boolean;
    /**
     * Checks whether this point is equal to another point. Two points are considered equal if and only if the great-
     * circle distance between them is less than or equal to a specified tolerance or if the latitude and longitude
     * components of both points are equal to `NaN`.
     * @param lat The latitude of the other point, in degrees.
     * @param lon The longitude of the other point, in degrees.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians.
     * @returns Whether this point is equal to the other point.
     */
    equals(lat: number, lon: number, tolerance?: number): boolean;
    /**
     * Copies this point.
     * @param to An optional point to which to copy this point. If this argument is not supplied, a new GeoPoint object
     * will be created.
     * @returns A copy of this point.
     */
    copy(to?: GeoPoint): GeoPoint;
}
/**
 * A read-only wrapper for a GeoPoint.
 */
declare class GeoPointReadOnly implements GeoPointInterface, LatLonInterface {
    private readonly source;
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source: GeoPoint);
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat(): number;
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon(): number;
    /** @inheritdoc */
    distance(other: LatLonInterface): number;
    /** @inheritdoc */
    distance(lat: number, lon: number): number;
    /** @inheritdoc */
    distanceRhumb(other: LatLonInterface): number;
    /** @inheritdoc */
    distanceRhumb(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingTo(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingTo(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingFrom(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingFrom(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingRhumb(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingRhumb(lat: number, lon: number): number;
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offset(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offsetRhumb(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint ot which to write the result.
     * @returns The antipode of this point.
     * @throws Error if argument `out` is undefined.
     */
    antipode(out?: GeoPoint): GeoPoint;
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out: Float64Array): Float64Array;
    /** @inheritdoc */
    equals(other: LatLonInterface, tolerance?: number): boolean;
    /** @inheritdoc */
    equals(lat: number, lon: number, tolerance?: number): boolean;
    /** @inheritdoc */
    copy(to?: GeoPoint): GeoPoint;
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
declare class GeoPoint implements GeoPointInterface, LatLonInterface {
    /**
     * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
     * radians.
     */
    static readonly EQUALITY_TOLERANCE = 1e-7;
    private static readonly tempVec3;
    private static readonly tempGeoPoint;
    private _lat;
    private _lon;
    readonly readonly: GeoPointReadOnly;
    /**
     * Constructor.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     */
    constructor(lat: number, lon: number);
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat(): number;
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon(): number;
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns A LatLonInterface.
     */
    private static asLatLonInterface;
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns A 3D vector.
     */
    private static asVec3;
    /**
     * Sets this point's latitude/longitude values.
     * @param other The point from which to take the new latitude/longitude values.
     * @returns This point, after it has been changed.
     */
    set(other: LatLonInterface): this;
    /**
     * Sets this point's latitude/longitude values.
     * @param lat The new latitude, in degrees.
     * @param lon The new longitude, in degrees.
     * @returns This point, after it has been changed.
     */
    set(lat: number, lon: number): this;
    /**
     * Sets this point's coordinate values from a cartesian position vector. By convention, in the cartesian coordinate
     * system the origin is at the center of the Earth, the positive x-axis passes through 0 degrees N, 0 degrees E, and
     * the positive z-axis passes through the north pole.
     * @param vec A position vector defining the new coordinates.
     * @returns This point, after it has been changed.
     */
    setFromCartesian(vec: ReadonlyFloat64Array): this;
    /**
     * Sets this point's coordinate values from a cartesian position vector. By convention, in the cartesian coordinate
     * system the origin is at the center of the Earth, the positive x-axis passes through 0 degrees N, 0 degrees E, and
     * the positive z-axis passes through the north pole.
     * @param x The x component of a position vector defining the new coordinates.
     * @param y The y component of a position vector defining the new coordinates.
     * @param z The z component of a position vector defining the new coordinates.
     * @returns This point, after it has been changed.
     */
    setFromCartesian(x: number, y: number, z: number): this;
    /** @inheritdoc */
    distance(other: LatLonInterface): number;
    /** @inheritdoc */
    distance(lat: number, lon: number): number;
    /** @inheritdoc */
    distanceRhumb(other: LatLonInterface): number;
    /** @inheritdoc */
    distanceRhumb(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingTo(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingTo(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingFrom(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingFrom(lat: number, lon: number): number;
    /** @inheritdoc */
    bearingRhumb(other: LatLonInterface): number;
    /** @inheritdoc */
    bearingRhumb(lat: number, lon: number): number;
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offset(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offsetRhumb(bearing: number, distance: number, out?: GeoPoint): GeoPoint;
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The antipode of this point.
     */
    antipode(out?: GeoPoint): GeoPoint;
    /** @inheritdoc */
    toCartesian(out: Float64Array): Float64Array;
    /** @inheritdoc */
    equals(other: LatLonInterface, tolerance?: number): boolean;
    /** @inheritdoc */
    equals(lat: number, lon: number, tolerance?: number): boolean;
    /** @inheritdoc */
    copy(to?: GeoPoint): GeoPoint;
    /**
     * Calculates the cartesian (x, y, z) representation of a point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param point The point to convert.
     * @param out The vector array to which to write the result.
     * @returns the cartesian representation of the point.
     */
    static sphericalToCartesian(point: LatLonInterface, out: Float64Array): Float64Array;
    /**
     * Calculates the cartesian (x, y, z) representation of a point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param lat The latitude of the point to convert, in degrees.
     * @param lon The longitude of the point to convert, in degrees.
     * @param out The vector array to which to write the result.
     * @returns the cartesian representation of the point.
     */
    static sphericalToCartesian(lat: number, lon: number, out: Float64Array): Float64Array;
    /**
     * Checks whether two points are equal.
     * @param lat1 The latitude of the first point, in degrees.
     * @param lon1 The longitude of the first point, in degrees.
     * @param lat2 The latitude of the second point, in degrees.
     * @param lon2 The longitude of the second point, in degrees.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians. Defaults to `GeoPoint.EQUALITY_TOLERANCE`.
     * @returns Whether the two points are equal.
     */
    static equals(lat1: number, lon1: number, lat2: number, lon2: number, tolerance?: number): boolean;
    /**
     * Checks whether two points are equal.
     * @param point1 The first point.
     * @param point2 The second point.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians. Defaults to `GeoPoint.EQUALITY_TOLERANCE`.
     * @returns Whether the two points are equal.
     */
    static equals(point1: LatLonInterface, point2: LatLonInterface, tolerance?: number): boolean;
    /**
     * Checks whether two points are equal.
     * @param point1 The first point, in cartesian form.
     * @param point2 The second point, in cartesian form.
     * @param tolerance The tolerance of the equality check, defined as the maximum allowed distance between two equal
     * points in great-arc radians. Defaults to `GeoPoint.EQUALITY_TOLERANCE`.
     * @returns Whether the two points are equal.
     */
    static equals(point1: ReadonlyFloat64Array, point2: ReadonlyFloat64Array, tolerance?: number): boolean;
    /**
     * Calculates the great-circle distance between two points.
     * @param lat1 The latitude of the first point, in degrees.
     * @param lon1 The longitude of the first point, in degrees.
     * @param lat2 The latitude of the second point, in degrees.
     * @param lon2 The longitude of the second point, in degrees.
     * @returns The great-circle distance between the two points, in great-arc radians.
     */
    static distance(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Calculates the great-circle distance between two points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The great-circle distance between the two points, in great-arc radians.
     */
    static distance(point1: LatLonInterface, point2: LatLonInterface): number;
    /**
     * Calculates the great-circle distance between two points.
     * @param point1 The first point, in cartesian form.
     * @param point2 The second point, in cartesian form.
     * @returns The great-circle distance between the two points, in great-arc radians.
     */
    static distance(point1: ReadonlyFloat64Array, point2: ReadonlyFloat64Array): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param lat1 The latitude of the first point, in degrees.
     * @param lon1 The longitude of the first point, in degrees.
     * @param lat2 The latitude of the second point, in degrees.
     * @param lon2 The longitude of the second point, in degrees.
     * @returns The distance along the rhumb line connecting the two points, in great-arc radians.
     */
    static distanceRhumb(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The distance along the rhumb line connecting the two points, in great-arc radians.
     */
    static distanceRhumb(point1: LatLonInterface, point2: LatLonInterface): number;
    /**
     * Calculates the distance along the rhumb line connecting this point with another point.
     * @param point1 The first point, in cartesian form.
     * @param point2 The second point, in cartesian form.
     * @returns The distance along the rhumb line connecting the two points, in great-arc radians.
     */
    static distanceRhumb(point1: ReadonlyFloat64Array, point2: ReadonlyFloat64Array): number;
    /**
     * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
     * the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static initialBearing(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Calculates the final true bearing from one point to another along the great circle connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static finalBearing(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
     * connecting the two.
     */
    static bearingRhumb(lat1: number, lon1: number, lat2: number, lon2: number): number;
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle An angle in degrees.
     * @returns The angle's equivalent in the range [-180, 180).
     */
    private static toPlusMinus180;
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    private static deltaPsi;
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi The difference in isometric latitude beween the two latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The rhumb correction factor between the two latitudes.
     */
    private static rhumbCorrection;
}

/**
 * Component props for WaypointComponent.
 */
interface LatLonDisplayProps extends ComponentProps {
    /** A subscribable which provides a location to bind. */
    location: Subscribable<GeoPointInterface>;
    /** CSS class(es) to add to the root of the icon component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A component which displays lat/lon coordinates.
 */
declare class LatLonDisplay extends DisplayComponent<LatLonDisplayProps> {
    private locationSub?;
    private readonly latPrefix;
    private readonly latNum;
    private readonly lonPrefix;
    private readonly lonNum;
    private readonly formatter;
    /** @inheritdoc */
    onAfterRender(): void;
    /**
     * A callback which is called when this component's bound location changes.
     * @param location The new location.
     */
    private onLocationChanged;
    /**
     * Displays the formatted lat/lon coordinates of a location.
     * @param location A location.
     */
    private setDisplay;
    /**
     * Sets coordinate subjects for a given set of coordinate values.
     * @param prefixSub The coordinate prefix subject.
     * @param numSub The coordinate number subject.
     * @param coordValues The DMS values of the coordinate.
     * @param padDeg The number of digits to which to pad the degrees value.
     */
    private setCoordSub;
    /**
     * Displays the blank default value.
     */
    private clearDisplay;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A handler for events emitted by UiControl2.
 * @template T The type of event sources.
 * @template Args A tuple type describing additional arguments for an event after the source control. Defaults to an
 * empty (zero-length) tuple.
 */
declare type UiControlEventHandler<T extends HardwareUiControl<any, any>, Args extends any[] = []> = (source: T, ...args: Args) => boolean;
/** A requested scroll direction. */
declare type ScrollDirection = 'forward' | 'backward';
/**
 * Maps an event definition type to an event handler interface. Each event in the definition type is mapped to a
 * handler with the name `on[Event]`.
 */
declare type UiControlEventHandlers<Events> = {
    [Event in keyof Events as `on${Event & string}`]: Events[Event];
};
/**
 * Maps an event definition type to a prop event handler interface. Each event in the definition type is mapped to an
 * optional handler with the name `on[Event]`.
 */
declare type UiControlPropEventHandlers<Events> = Partial<UiControlEventHandlers<Events>>;
/** Properties on the UiControl2 component. */
interface HardwareUiControlProps extends ComponentProps {
    /** Whether or not the inner FMS knob scrolls also by default. */
    innerKnobScroll?: boolean;
    /**
     * When enabled, scroll commands will not propagate from this control to its parent while
     * the control is focused.
     */
    isolateScroll?: boolean;
    /** Whether the control requires one of its child controls to be focused for itself to be focused. */
    requireChildFocus?: boolean;
    /** An event called when the control is focused. */
    onFocused?: (source: HardwareUiControl) => void;
    /** An event called when the control loses focus. */
    onBlurred?: (source: HardwareUiControl) => void;
    /** An event called when the control is disabled. */
    onDisabled?: (source: HardwareUiControl) => void;
    /** An event called when the control is enabled. */
    onEnabled?: (source: HardwareUiControl) => void;
    /** A function which returns how the control should focus its children when it is focused from a scroll. */
    getFocusPositionOnScroll?: (direction: ScrollDirection) => FocusPosition;
    /** An event called when the control is scrolled. */
    onScroll?: (direction: ScrollDirection) => boolean;
    /** An event called when the scroll operation has completed. */
    onAfterScroll?: (control: HardwareUiControl, index: number) => void;
    /** An event called when a control is registered with this control. */
    onRegistered?: (source: HardwareUiControl) => void;
    /** An event called when a control is unregistered with this control. */
    onUnregistered?: (source: HardwareUiControl) => void;
    /** An event called when the control is destroyed. */
    onDestroyed?: (source: HardwareUiControl) => void;
    /**
     * A function which reconciles the focus state of the control's children when the control is focused with no focused
     * children after a child has been blurred.
     * @param index The index of the child control that was blurred.
     * @param child The child control that was blurred.
     * @returns The index of the child to focus, or a blur reconciliation strategy.
     */
    reconcileChildBlur?: (index: number, child: HardwareUiControl) => number | BlurReconciliation;
}
/**
 * The item position to focus a component's children when performing a focus operation.
 */
declare enum FocusPosition {
    /** The component's most recently focused descendants will be focused. */
    MostRecent = "MostRecent",
    /** The first focus-able child at each node in the descendant tree will be focused. */
    First = "First",
    /** The last focus-able child at each node in the descendant tree will be focused. */
    Last = "Last",
    /** No child components will be focused. */
    None = "None"
}
/**
 * A strategy to focus a component's children as part of a blur reconciliation operation.
 */
declare enum BlurReconciliation {
    /** The component's first focus-able child will be focused. */
    First = "First",
    /** The component's last focus-able child will be focused. */
    Last = "Last",
    /**
     * The component's next focus-able child after the child that was blurred will be focused. If no such child exists,
     * then the last focus-able child before the child that was blurred will be focused.
     */
    Next = "Next",
    /**
     * The component's last focus-able child before the child that was blurred will be focused. If no such child exists,
     * then the next focus-able child after the child that was blurred will be focused.
     */
    Prev = "Prev",
    /** No child components will be focused. */
    None = "None"
}
/**
 * An abstract implementation of a component that forms the base of a Garmin-like UI control system. Subclasses should
 * implement an appropriate event handler interface (using the utility type `UiControlEventHandlers<Events>`) and have
 * their props implement the corresponding prop event handler interface (using the utility type
 * `UiControlPropEventHandlers<Events>`).
 * @template E An event definition type for events supported by this control.
 * @template P The component prop type for this control.
 */
declare abstract class HardwareUiControl<E extends Record<string, any> = Record<string, any>, P extends HardwareUiControlProps = HardwareUiControlProps> extends DisplayComponent<P> {
    protected registeredControls: HardwareUiControl<E>[] | undefined;
    protected focusedIndex: number;
    private parent;
    private _isDisabled;
    private _isFocused;
    private _isIsolated;
    private readonly _UICONTROL_;
    /**
     * Creates an instance of a HardwareUiControl.
     * @param props The props for this component.
     */
    constructor(props: P);
    /**
     * Gets the current number of registered child controls.
     * @returns The current number of registered child controls.
     */
    get length(): number;
    /**
     * Gets whether or not the control is currently disabled.
     * @returns True if disabled, false otherwise.
     */
    get isDisabled(): boolean;
    /**
     * Gets whether or not the control is currently focused.
     * @returns True if disabled, false otherwise.
     */
    get isFocused(): boolean;
    /**
     * Gets whether or not the control is currently in scroll isolation.
     * @returns True if currently in scroll isolation, false otherwise.
     */
    get isIsolated(): boolean;
    /**
     * An event called when the control receives focus.
     * @param source The control that emitted this event.
     */
    protected onFocused(source: HardwareUiControl<E>): void;
    /**
     * An event called when the control is blurred.
     * @param source The control that emitted this event.
     */
    protected onBlurred(source: HardwareUiControl<E>): void;
    /**
     * An event called when the control is enabled.
     * @param source The control that emitted this event.
     */
    protected onEnabled(source: HardwareUiControl<E>): void;
    /**
     * An event called when the control is disabled.
     * @param source The control that emitted this event.
     */
    protected onDisabled(source: HardwareUiControl<E>): void;
    /**
     * An event called when a control is registered with this control.
     * @param source The control that emitted this event.
     */
    protected onRegistered(source: HardwareUiControl<E>): void;
    /**
     * An event called when a control is unregistered from this control.
     * @param source The control that emitted this event.
     */
    protected onUnregistered(source: HardwareUiControl<E>): void;
    /**
     * Gets the focus position to apply when this control is focused from a scroll.
     * @param direction The direction of the scroll.
     * @returns The focus position to apply when this control is focused from a scroll.
     */
    protected getFocusPositionOnScroll(direction: ScrollDirection): FocusPosition;
    /**
     * An event called when the control is scrolled.
     * @param direction The direction that is being requested to scroll.
     * @returns True if this control handled this event, false otherwise.
     */
    protected onScroll(direction: ScrollDirection): boolean;
    /**
     * An event called when a scroll operation has completed.
     * @param control The control that was scrolled to.
     * @param index The index of the control in the collection of registered controls.
     */
    protected onAfterScroll(control: HardwareUiControl<E>, index: number): void;
    /**
     * Scrolls the currently focused control in the supplied direction.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    scroll(direction: ScrollDirection): boolean;
    /**
     * Attempts to perform a scroll operation on the control, propagating the operation
     * upward in the tree if the control does not handle the operation.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    private tryPerformScroll;
    /**
     * A method which is called when this control receives an interaction event.
     * @param event The event.
     * @returns True if the event was handled, false otherwise.
     */
    abstract onInteractionEvent(event: keyof E): boolean;
    /**
     * Triggers an event on this control. The event will first be routed to the deepest focused descendent of this
     * control and will propagate up the control tree until it is handled or there are no more controls to which to
     * propagate.
     * @param event The event to trigger.
     * @param source The source of the event. Defaults to this if not supplied.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    triggerEvent(event: keyof E, source: HardwareUiControl, ...args: any[]): boolean;
    /**
     * Propagates an event up the control tree.
     * @param event The event to propagate.
     * @param source The source of the event.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    private propagateEvent;
    /**
     * Validates that the control can be focused by checking if any ancestors in the
     * control tree are disabled.
     * @returns True if there are no disabled ancestors, false otherwise.
     */
    private canBeFocused;
    /**
     * Brings focus to the control. Focusing the control will also blur the currently
     * focused control, if any.
     * @param focusPosition The focus position to activate for descendents of this control.
     * @returns Whether this control was successfully focused.
     */
    focus(focusPosition: FocusPosition): boolean;
    /**
     * Gets the path from this control to the deepest descendent control that is focused. If this control is not focused,
     * then the path is empty.
     * @param path The stack of control nodes defining the path to the currently
     * focused descendent control.
     * @returns A stack of nodes that defines the path to the deepest focused descendent
     * node, in order of deepest descendent first.
     */
    private getFocusedComponentPath;
    /**
     * Gets the path from this control to its deepest ancestor that is focused (including itself). If none of this
     * control's ancestors are focused, the path will contain this control and all of its ancestors up to and including
     * the root of its control tree.
     * @param path An array in which to store the path.
     * @returns A stack of controls that defines the path from this control to its deepest focused ancestor, ordered
     * from descendents to ancestors (the control at the shallowest tree depth is located at the top of the stack).
     */
    private getDeepestFocusedAncestorPath;
    /**
     * Builds the path of controls to focus from this control downward in children based on the provided default focus
     * position. If this control cannot be focused, the path will be empty.
     * @param focusPosition The focus position to use to build the path.
     * @param focusStack The stack in which to store the path.
     * @returns A stack of components that defines the path from the deepest descendent to focus to this control if this
     * control were to be focused with the specified focus position, ordered from descendents to ancestors (the control
     * at the shallowest tree depth is located at the top of the stack).
     */
    private buildFocusPath;
    /**
     * Blurs, or removes focus, from the component.
     */
    blur(): void;
    /**
     * Handles the case where this control is left focused with no focused child control after a child control is
     * blurred.
     * @param indexBlurred The index of the child control that was blurred. If the child is no longer registered, then
     * this is the index of the child prior to being unregistered.
     * @param childBlurred The child control that was blurred.
     */
    private handleNoFocusedChild;
    /**
     * Reconciles the focus state of this control's children when this control is focused with no focused children after
     * a child has been blurred.
     * @param index The index of the child control that was blurred. If the child is no longer registered, then this is
     * the index of the child prior to being unregistered.
     * @param child The child control that was blurred.
     * @returns The index of the child control to focus.
     */
    protected reconcileChildBlur(index: number, child: HardwareUiControl<E>): number | BlurReconciliation;
    /**
     * Sets the component to be disabled, removing the ability for the component to scroll. Setting
     * a component to disabled will also blur the component and its children, if necessary.
     * @param isDisabled Whether or not the component is disabled.
     */
    setDisabled(isDisabled: boolean): void;
    /**
     * Registers a child control with this control.
     * @param control The control to register.
     * @param index The index at which to register the control. If none is provided,
     * the control will be registered at the end of the collection of child controls.
     */
    register(control: HardwareUiControl<E>, index?: number): void;
    /**
     * Unregisters a child control with this control.
     * @param item The child control or index of a child control to unregister. If a
     * child control is provided, it will attempt to be located in the control's
     * child registry and then removed. If an index is provided, the child control
     * at that registered index will be removed.
     */
    unregister(item: HardwareUiControl<E> | number): void;
    /**
     * Clears the list of registered components.
     */
    clearRegistered(): void;
    /**
     * Gets the current focused index in the registered controls collection.
     * @returns The index of the focused control in the collection of registered controls.
     */
    getFocusedIndex(): number;
    /**
     * Gets the most recent focused index (including the current focused index, if one exists) in the registered controls
     * collection.
     * @returns The index of the most recently focused control in the collection of registered controls.
     */
    getMostRecentFocusedIndex(): number;
    /**
     * Sets the current most recently focused child control index. If this control is focused and has children
     * that have focus, this will also switch child focus to the new index.
     * @param index The index of the child control to set most recent focus for.
     * @param focusPosition The focus position to focus the child for, if required.
     */
    setFocusedIndex(index: number, focusPosition?: FocusPosition): void;
    /**
     * Gets a child control at the specified index.
     * @param index The index of the child control to get.
     * @returns The specified child control.
     */
    getChild(index: number): HardwareUiControl<E> | undefined;
    /**
     * Gets the index of a specified child control within the registered
     * child controls collection.
     * @param child The child to get the index of.
     * @returns The index of the child, or -1 if not found.
     */
    indexOf(child: HardwareUiControl<E>): number;
    /**
     * Sets the parent of this control.
     * @param parent The parent to set.
     */
    setParent(parent: HardwareUiControl<E>): void;
    /**
     * Sets whether or not this control is in scroll isolation. While scroll isolation
     * is enabled, scroll events will not propagate to the control's parent when the
     * control has focus.
     * @param isolated Whether or not the control is isolated.
     */
    setIsolated(isolated: boolean): void;
    /** @inheritdoc */
    onAfterRender(thisNode: VNode): void;
    /**
     * Renders the control.
     * @returns The component VNode.
     */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Properties on the ControlList component.
 */
interface HardwareControlListProps<T> extends HardwareUiControlProps {
    /** The data associated with this list component. */
    data: SubscribableArray<T>;
    /** A function that renders a single data item into the list. */
    renderItem: (data: T, index: number) => VNode;
    /** A callback called when an item in the list is selected. */
    onItemSelected?: (data: T | null, node: HardwareUiControl | null, index: number) => void;
    /** Indicates that the list should be ordered by a specified function. */
    orderBy?: (a: T, b: T) => number;
    /** The size, in pixels, of each item in the list. */
    itemSize?: number;
    /** The max number of items to display in the list. */
    numItems?: number;
    /** Whether or not to hide the list scrollbar. */
    hideScrollbar?: boolean;
    /** The CSS class to apply to this list container. */
    class?: string;
    /** An alternate HTML element to scroll to ensure the selected element is in view. */
    scrollContainer?: NodeReference<HTMLElement>;
    /** Disables automatically ensuring that the container scrolls to the focused item. */
    disableContainerScroll?: boolean;
}
/**
 * A component that displays a collection of UiControls in a list format.
 */
declare abstract class HardwareUiControlList<T, E extends Record<string, any> = Record<string, never>, P extends HardwareControlListProps<T> = HardwareControlListProps<T>> extends HardwareUiControl<E, P> {
    private readonly el;
    private readonly itemsContainer;
    private dataToControlMap;
    private controlToElementMap;
    private controlToDataMap;
    private currentControlOrder;
    /**
     * Creates an instance of a ControlList.
     * @param props The props on the ControlList component.
     */
    constructor(props: P);
    /** @inheritdoc */
    onAfterRender(node: VNode): void;
    /**
     * A callback fired when the array subject data changes.
     * @param index The index of the change.
     * @param type The type of change.
     * @param data The item that was changed.
     */
    private onDataChanged;
    /**
     * An event called when data is added to the subscription.
     * @param index The index that the data was added at.
     * @param data The data that was added.
     */
    private onDataAdded;
    /**
     * Adds a data item to the control list and performs the required rendering and
     * ordering operations.
     * @param dataItem The data item to add to the list.
     * @param indexToAdd The index to add the item at.
     * @param currentItemElement The current DOM element that resides at the location to add to.
     */
    private addDataItem;
    /**
     * An event called when data is removed from the subscription.
     * @param index The index that the data was removed at.
     * @param data The data that was removed;
     */
    private onDataRemoved;
    /**
     * Removes a data item from the control list.
     * @param data The data item to remove.
     * @param index The index of the data that was removed.
     */
    private removeDataItem;
    /**
     * An event called when the data is cleared in the subscription.
     */
    private onDataCleared;
    /**
     * Adds a data item to element order tracking information.
     * @param control The index to add the data item at.
     * @param data The data to add tracking information for.
     * @param element The DOM element to associate with this data item.
     */
    private addToOrderTracking;
    /**
     * Removes a data item from element order tracking information.
     * @param data The data item to remove order tracking information for.
     */
    private removeFromOrderTracking;
    /**
     * Clears all data item element order tracking information.
     */
    private clearOrderTracking;
    /**
     * Updates the order of data items in the list by the props supplied
     * comparison function, if one exists.
     */
    updateOrder(): void;
    /**
     * Checks whether or not the control order is the same as it was previously.
     * @returns True if the order is the same, false otherwise.
     */
    private orderUnchanged;
    /**
     * Sorts the registered controls by the provided ordering comparison function.
     * @param a The first control to compare.
     * @param b The second control to compare.
     * @returns Negative if the first control is less than, zero if equal, positive if greater than.
     */
    private sortControls;
    /**
     * Removes a dom node from the collection at the specified index.
     * @param index The index to remove.
     */
    private removeDomNode;
    /**
     * Adds a list rendered dom node to the collection.
     * @param node Item to render and add.
     * @param index The index to add at.
     * @param el The element to add to.
     * @returns The created DOM element.
     */
    private renderToDom;
    /**
     * Scrolls to an item.
     * @param index is the index of the list item to scroll to.
     * @param focusPosition The focus position to apply to children of the item being scrolled to.
     */
    scrollToIndex(index: number, focusPosition?: FocusPosition): void;
    /**
     * Ensures an indexed list item is in view.
     * @param index The index of the list item.
     * @param pinDirection The end of the container which the element should be pinned to.
     */
    ensureIndexInView(index: number, pinDirection?: 'none' | 'top' | 'bottom'): void;
    /**
     * Gets an element at the specified data/control index.
     * @param index The data/control index to get the element for.
     * @returns The request HTML element.
     */
    private getElement;
    /**
     * Gets the data object related to the selected DOM element.
     * @param index The index of the data to get.
     * @returns The selected item, if found.
     */
    getData(index: number): T | null;
    /**
     * Get the selected HTMLElement.
     * @returns The selected element, if found.
     */
    getSelectedElement(): HTMLElement | null;
    /**
     * Gets the index of the currently selected element.
     * @returns Selected element index. Returns -1 if nothing found.
     */
    getSelectedIndex(): number;
    /**
     * Gets the instance of the node at the specified index.
     * @param index The index to get the instance for.
     * @returns The node instance of specified type.
     */
    getChildInstance<TControl extends HardwareUiControl<E>>(index: number): TControl | null;
    /** @inheritdoc */
    protected onBlurred(source: HardwareUiControl<E, P>): void;
    /**
     * Responds to when a list item is focused.
     */
    private onItemFocused;
    /**
     * Renders the complete list of data items as control components.
     */
    private renderList;
    /**
     * Renders the control list scroll bar.
     */
    protected abstract renderScrollbar(): VNode;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * A parameter object for HorizonProjection.
 */
declare type HorizonProjectionParameters = {
    /** The position of the airplane. */
    readonly position?: LatLonInterface;
    /** The altitude of the airplane, in meters above mean sea level. */
    readonly altitude?: number;
    /** The true heading of the airplane, in degrees. */
    readonly heading?: number;
    /** The pitch of the airplane, in degrees. */
    readonly pitch?: number;
    /** The roll of the airplane, in degrees. */
    readonly roll?: number;
    /**
     * The offset of the projection camera relative to the airplane, as `[x, y, z]` in meters using the airplane's
     * coordinate system. The positive z axis points in the forward direction of the airplane, the positive x axis points
     * in the upward direction, and the positive y axis points to the right.
     */
    readonly offset?: ReadonlyFloat64Array;
    /** The size of the projected window, as `[x, y]` in pixels. */
    readonly projectedSize?: ReadonlyFloat64Array;
    /** The field of view, in degrees. */
    readonly fov?: number;
    /**
     * The projected endpoints at which to measure the field of view, as `[x1, y1, x2, y2]`, with each component
     * expressed relative to the width or height of the projected window.
     */
    readonly fovEndpoints?: ReadonlyFloat64Array;
    /** The offset of the center of the projection, as `[x, y]` in pixels. */
    readonly projectedOffset?: ReadonlyFloat64Array;
};
/**
 * The different types of horizon projection changes.
 */
declare enum HorizonProjectionChangeType {
    Position = 1,
    Altitude = 2,
    Heading = 4,
    Pitch = 8,
    Roll = 16,
    Offset = 32,
    ProjectedSize = 64,
    Fov = 128,
    FovEndpoints = 256,
    ScaleFactor = 512,
    ProjectedOffset = 1024,
    OffsetCenterProjected = 2048
}
/**
 * A change listener callback for a HorizonProjection.
 */
interface HorizonProjectionChangeListener {
    (source: HorizonProjection, changeFlags: number): void;
}
/**
 * A perspective projection from the point of view of an airplane.
 */
declare class HorizonProjection {
    private static readonly vec2Cache;
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private readonly position;
    private altitude;
    private heading;
    private roll;
    private pitch;
    private readonly offset;
    private readonly projectedSize;
    private fov;
    private readonly fovEndpoints;
    private scaleFactor;
    private readonly projectedOffset;
    private readonly offsetCenterProjected;
    private readonly positionAngleTransforms;
    private readonly altitudeTransform;
    private readonly positionAltitudeTransforms;
    private readonly positionTransform;
    private readonly planeAngles;
    private readonly planeAngleTransforms;
    private readonly planeTransform;
    private readonly cameraPos;
    private readonly surfacePos;
    private readonly perspectiveTransform;
    private readonly oldParameters;
    private readonly queuedParameters;
    private updateQueued;
    private readonly changeEvent;
    /**
     * Constructor.
     * @param projectedWidth The initial projected width of the projection, in pixels.
     * @param projectedHeight The initial projected height of the projection, in pixels.
     * @param fov The initial field of view of the projection, in degrees.
     */
    constructor(projectedWidth: number, projectedHeight: number, fov: number);
    /**
     * Gets the position of this projection.
     * @returns The position of this projection.
     */
    getPosition(): GeoPointReadOnly;
    /**
     * Gets the altitude of this projection, in meters above mean sea level.
     * @returns The altitude of this projection, in meters above mean sea level.
     */
    getAltitude(): number;
    /**
     * Gets the true heading of this projection, in degrees.
     * @returns The true heading of this projection, in degrees.
     */
    getHeading(): number;
    /**
     * Gets the pitch of this projection, in degrees.
     * @returns The pitch of this projection, in degrees.
     */
    getPitch(): number;
    /**
     * Gets the roll of this projection, in degrees.
     * @returns The roll of this projection, in degrees.
     */
    getRoll(): number;
    /**
     * Gets the size of the projected window, as `[width, height]` in pixels.
     * @returns The size of the projected window, as `[width, height]` in pixels.
     */
    getProjectedSize(): ReadonlyFloat64Array;
    /**
     * Gets the field of view of this projection, in degrees.
     * @returns The field of view of this projection, in degrees.
     */
    getFov(): number;
    /**
     * Gets the projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each component
     * expressed relative to the width or height of the projected window.
     * @returns The projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each
     * component expressed relative to the width or height of the projected window.
     */
    getFovEndpoints(): ReadonlyFloat64Array;
    /**
     * Gets the focal length of this projection, in meters. The focal length is set such that one meter at a distance
     * from the camera equal to the focal length subtends an angle equal to the field of view.
     * @returns The focal length of this projection, in meters.
     */
    getFocalLength(): number;
    /**
     * Gets the nominal scale factor of this projection. At a distance from the camera equal to the focal length, one
     * meter will be projected to a number of pixels equal to the nominal scale factor.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor(): number;
    /**
     * Gets the projected offset of this projection's center, as `[x, y]` in pixels.
     * @returns The projected offset of this projection's center, as `[x, y]` in pixels.
     */
    getProjectedOffset(): ReadonlyFloat64Array;
    /**
     * Gets the projected center of this projection, including offset, as `[x, y]` in pixels.
     * @returns The projected center of this projection, including offset, as `[x, y]` in pixels.
     */
    getOffsetCenterProjected(): ReadonlyFloat64Array;
    /**
     * Recomputes this projection's computed parameters.
     */
    private recompute;
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters: HorizonProjectionParameters): void;
    /**
     * Sets the projection parameters to be applied when `applyQueued()` is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters: HorizonProjectionParameters): void;
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued(): void;
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    private storeParameters;
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    private computeChangeFlags;
    /**
     * Computes change flags for derived parameters given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags for derived parameters based on the specified old parameters.
     */
    private computeDerivedChangeFlags;
    /**
     * Subscribes a change listener to this projection. The listener will be called every time this projection changes.
     * A listener can be subscribed multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to subscribe.
     * @returns The new subscription.
     */
    onChange(listener: HorizonProjectionChangeListener): Subscription;
    /**
     * Projects a point represented by a set of lat/lon coordinates and altitude.
     * @param position The lat/lon coordinates of the point to project.
     * @param altitude The altitude of the point to project, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    project(position: LatLonInterface, altitude: number, out: Float64Array): Float64Array;
    /**
     * Projects a point relative to the position of the airplane in spherical space.
     * @param bearing The true bearing from the airplane to the point to project, in degrees.
     * @param distance The geodetic horizontal distance from the point to project to the airplane, in meters.
     * @param height The geodetic height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeSpherical(bearing: number, distance: number, height: number, out: Float64Array): Float64Array;
    /**
     * Projects a point relative to the position of the airplane in Euclidean space. The coordinate system is defined at
     * the position of the airplane, with the vertical axis perpendicular to the surface of the Earth and the horizontal
     * plane parallel to the Earth's surface at the point directly underneath the airplane.
     * @param bearing The true bearing from the airplane to the point to project, in degrees.
     * @param distance The Euclidean horizontal distance from the point to project to the airplane, in meters.
     * @param height The Euclidean height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeEuclidean(bearing: number, distance: number, height: number, out: Float64Array): Float64Array;
    /**
     * Projects a 3D vector defined relative to the airplane, as `[x, y, z]` in meters with the coordinate system
     * defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param out The 2D vector to which to write the result.
     * @returns The projected vector.
     */
    private projectRelativeVec;
    /**
     * Projects a point relative to the position of the projection camera in Euclidean space. The coordinate system is
     * defined at the position of the camera, with the vertical axis perpendicular to the surface of the Earth and the
     * horizontal plane parallel to the Earth's surface at the point directly underneath the airplane.
     * @param bearing The true bearing from the camera to the point to project, in degrees.
     * @param distance The Euclidean horizontal distance from the point to project to the camera, in meters.
     * @param height The Euclidean height of the point to project relative to the camera, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectCameraRelativeEuclidean(bearing: number, distance: number, height: number, out: Float64Array): Float64Array;
    private static readonly cameraRelativeVec3Cache;
    /**
     * Projects a 3D vector defined relative to the camera, as `[x, y, z]` in meters with the coordinate system
     * defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param out The 2D vector to which to write the result.
     * @returns The projected vector.
     */
    private projectCameraRelativeVec;
    /**
     * Checks whether a point falls within certain projected bounds.
     * @param point The lat/lon coordinates of the point to check.
     * @param altitude The altitude of the point to check, in meters.
     * @param bounds The bounds to check against, expressed as `[left, top, right, bottom]` in pixels. Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point: LatLonInterface, altitude: number, bounds?: ReadonlyFloat64Array): boolean;
    /**
     * Checks whether a projected point falls within certain projected bounds.
     * @param point The projected point to check, as `[x, y]` in pixels.
     * @param bounds The bounds to check against, expressed as `[left, top, right, bottom]` in pixels. Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point: ReadonlyFloat64Array, bounds?: ReadonlyFloat64Array): boolean;
}

/**
 * Component props for HorizonLayer.
 */
interface HorizonLayerProps extends ComponentProps {
    /** The layer's horizon projection. */
    projection: HorizonProjection;
    /**
     * A subscribable which provides the maximum update frequency of the layer, in hertz. Note that the actual update
     * frequency will not exceed the update frequency of the layer's parent map. If not defined, the frequency will
     * default to that of the layer's parent map.
     */
    updateFreq?: Subscribable<number>;
}
/**
 * A base component for horizon layers.
 */
declare abstract class HorizonLayer<P extends HorizonLayerProps = HorizonLayerProps> extends DisplayComponent<P> {
    private _isAttached;
    private _isVisible;
    /**
     * Checks whether this layer is attached to a horizon component.
     * @returns Whether this layer is attached to a horizon component.
     */
    protected isAttached(): boolean;
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible(): boolean;
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val: boolean): void;
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    protected onVisibilityChanged(isVisible: boolean): void;
    /**
     * This method is called when this layer is attached to its parent horizon component.
     */
    onAttached(): void;
    /**
     * This method is called when this layer's parent horizon component is awakened.
     */
    onWake(): void;
    /**
     * This method is called when this layer's parent horizon component is put to sleep.
     */
    onSleep(): void;
    /**
     * This method is called when this layer's horizon projection changes.
     * @param projection This layer's horizon projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /**
     * This method is called once every update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time: number, elapsed: number): void;
    /**
     * This method is called when this layer is detached from its parent horizon component.
     */
    onDetached(): void;
}

/**
 * Component props for HorizonComponent.
 */
interface HorizonComponentProps extends ComponentProps {
    /** The size, as `[width, height]` in pixels, of the horizon component's projected window. */
    projectedSize: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The field of view, in degrees, of the horizon component's projected window. */
    fov: number | Subscribable<number>;
    /**
     * The projected endpoints at which to measure the field of view as `[x1, y1, x2, y2]` with each component expressed
     * relative to the width or height of the projected window. Defaults to `[0.5, 0, 0.5, 1]`.
     */
    fovEndpoints?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The projected offset of the center of the projection, as `[x, y]` in pixels. Defaults to `[0, 0]`. */
    projectedOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** A projection to inject. A default will be used if none is provided. */
    projection?: HorizonProjection;
    /** CSS class(es) to apply to the root of the horizon component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A component which displays an artificial horizon. A horizon tracks the position, altitude, heading, pitch, and roll
 * of an airplane and uses a persepctive projection to project points in space to a planar pixel grid. Each horizon
 * component maintains a {@link HorizonComponent} instance which handles the details of the projection.
 * {@link HorizonLayer} objects added to the horizon as children determine what is drawn in the horizon window.
 */
declare class HorizonComponent<P extends HorizonComponentProps = HorizonComponentProps> extends DisplayComponent<P> {
    /**
     * This horizon component's projection.
     */
    readonly projection: HorizonProjection;
    private readonly layerEntries;
    private readonly projectedSize;
    private readonly fov;
    private readonly fovEndpoints?;
    private readonly projectedOffset?;
    private lastUpdateTime;
    private _isAwake;
    private projectedSizeSub?;
    private fovSub?;
    private fovEndpointsSub?;
    private projectedOffsetSub?;
    /** @inheritdoc */
    constructor(props: P);
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize(): ReadonlyFloat64Array;
    /**
     * Whether this horizon is awake.
     */
    get isAwake(): boolean;
    /**
     * Puts this horizon to sleep. While asleep, this horizon will not be updated.
     */
    sleep(): void;
    /**
     * Wakes this horizon, allowing it to be updated.
     */
    wake(): void;
    /**
     * Sets this horizon's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this horizon's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    private setAwakeState;
    /** @inheritdoc */
    onAfterRender(thisNode: VNode): void;
    /**
     * Scans this component's VNode sub-tree for HorizonLayer components and attaches them when found. Only the top-most
     * level of HorizonLayer components are attached; layers that are themselves children of other layers are not
     * attached.
     * @param thisNode This component's VNode.
     */
    protected attachLayers(thisNode: VNode): void;
    /**
     * This method is called when this horizon is awakened.
     */
    protected onWake(): void;
    /**
     * Calls the onWake() method of this horizon's layers.
     */
    protected wakeLayers(): void;
    /**
     * This method is called when this horizon is put to sleep.
     */
    protected onSleep(): void;
    /**
     * Calls the onSleep() method of this horizon's layers.
     */
    protected sleepLayers(): void;
    /**
     * This method is called when this horizon's projection changes.
     * @param projection This horizon's projection.
     * @param changeFlags The types of changes made to the projection.
     */
    protected onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
    /**
     * This method is called when the size of this horizon's projected window changes.
     */
    protected onProjectedSizeChanged(): void;
    /**
     * Attaches a layer to this horizon component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    protected attachLayer(layer: HorizonLayer): void;
    /**
     * Detaches a layer from this horizon component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    protected detachLayer(layer: HorizonLayer): boolean;
    /**
     * Updates this horizon.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time: number): void;
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    protected onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this horizon's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    protected updateLayers(time: number, elapsed: number): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Properties for a MapCanvasLayer.
 */
interface HorizonCanvasLayerProps extends HorizonLayerProps {
    /** Whether to include an offscreen buffer. False by default. */
    useBuffer?: boolean;
    /** CSS class(es) to apply to the canvas element. */
    class?: string | SubscribableSet<string>;
}
/**
 * An instance of a canvas within a MapCanvasLayer.
 */
interface HorizonCanvasLayerCanvasInstance {
    /** This instance's canvas element. */
    readonly canvas: HTMLCanvasElement;
    /** This instance's canvas 2D rendering context. */
    readonly context: CanvasRenderingContext2D;
    /** Whether this instance's canvas is displayed. */
    readonly isDisplayed: boolean;
    /** Clears this canvas. */
    clear(): void;
    /**
     * Resets this instance's canvas. This will erase the canvas of all drawn pixels, reset its state (including all
     * styles, transformations, and cached paths), and clear the Coherent GT command buffer associated with it.
     */
    reset(): void;
}
/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
declare class HorizonCanvasLayerCanvasInstanceClass implements HorizonCanvasLayerCanvasInstance {
    readonly canvas: HTMLCanvasElement;
    readonly context: CanvasRenderingContext2D;
    readonly isDisplayed: boolean;
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean);
    /** @inheritdoc */
    clear(): void;
    /** @inheritdoc */
    reset(): void;
}
/**
 * A layer which uses a canvas to draw graphics.
 */
declare class HorizonCanvasLayer<P extends HorizonCanvasLayerProps = HorizonCanvasLayerProps, C extends HorizonCanvasLayerCanvasInstance = HorizonCanvasLayerCanvasInstance> extends HorizonLayer<P> {
    private readonly displayCanvasRef;
    private width;
    private height;
    private displayCanvasContext;
    private _display?;
    private _buffer?;
    protected isInit: boolean;
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display(): C;
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer(): C;
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay(): C | undefined;
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer(): C | undefined;
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth(): number;
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight(): number;
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width: number): void;
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height: number): void;
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay(): void;
    /**
     * A callback called after the component renders.
     */
    onAfterRender(): void;
    /** @inheritdoc */
    protected onVisibilityChanged(): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes this layer's canvas instances.
     */
    private initCanvasInstances;
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    protected createCanvasInstance(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean): C;
    /**
     * Updates the canvas element's size.
     */
    protected updateCanvasSize(): void;
    /**
     * Updates the visibility of the display canvas.
     */
    private updateCanvasVisibility;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * A canvas horizon layer whose size and position is synced with the horizon projection window.
 */
declare class HorizonSyncedCanvasLayer extends HorizonCanvasLayer<HorizonCanvasLayerProps> {
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Updates this layer according to the current size of the horizon projected window.
     * @param projectedSize The size of the horizon projected window.
     */
    private updateFromProjectedSize;
    /** @inheritdoc */
    onProjectionChanged(projection: HorizonProjection, changeFlags: number): void;
}

/**
 * A {@link Subscription} which executes a handler function every time it receives a notification.
 */
declare class HandlerSubscription<HandlerType extends (...args: any[]) => void> implements Subscription {
    readonly handler: HandlerType;
    private readonly initialNotifyFunc?;
    private readonly onDestroy?;
    private _isAlive;
    /** @inheritdoc */
    get isAlive(): boolean;
    private _isPaused;
    /** @inheritdoc */
    get isPaused(): boolean;
    /** @inheritdoc */
    readonly canInitialNotify: boolean;
    /**
     * Constructor.
     * @param handler This subscription's handler. The handler will be called each time this subscription receives a
     * notification from its source.
     * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
     * subscription will not support initial notifications.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(handler: HandlerType, initialNotifyFunc?: ((sub: HandlerSubscription<HandlerType>) => void) | undefined, onDestroy?: ((sub: HandlerSubscription<HandlerType>) => void) | undefined);
    /**
     * Sends an initial notification to this subscription.
     * @throws Error if this subscription is not alive.
     */
    initialNotify(): void;
    /** @inheritdoc */
    pause(): this;
    /** @inheritdoc */
    resume(initialNotify?: boolean): this;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A consumer of events which optionally filters event data before passing the consumed events to handlers.
 */
interface Consumer<T> {
    /** Flags this object as a Consumer. */
    readonly isConsumer: true;
    /**
     * Handles an event using the provided event handler.
     * @param handler The event handler for the event.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns A new subscription for the provided handler.
     */
    handle(handler: Handler<T>, paused?: boolean): Subscription;
    /**
     * Disables handling of the event.
     * @param handler The handler to disable.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.handle()` to manage subscriptions.
     */
    off(handler: Handler<T>): void;
    /**
     * Caps the event subscription to a specified frequency, in Hz.
     * @param frequency The frequency, in Hz, to cap to.
     * @param immediateFirstPublish Whether to fire once immediately before throttling.
     * @returns A new consumer with the applied frequency filter.
     */
    atFrequency(frequency: number, immediateFirstPublish?: boolean): Consumer<T>;
    /**
     * Quantizes the numerical event data to consume only at the specified decimal precision.
     * @param precision The decimal precision to snap to.
     * @returns A new consumer with the applied precision filter.
     */
    withPrecision(precision: number): Consumer<T>;
    /**
     * Filter the subscription to consume only when the value has changed by a minimum amount.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChangedBy(amount: number): Consumer<T>;
    /**
     * Filter the subscription to consume only if the value has changed. At all.  Really only
     * useful for strings or other events that don't change much.
     * @returns A new consumer with the applied change threshold filter.
     */
    whenChanged(): Consumer<T>;
    /**
     * Filters events by time such that events will not be consumed until a minimum duration
     * has passed since the previous event.
     * @param deltaTime The minimum delta time between events.
     * @returns A new consumer with the applied change threshold filter.
     */
    onlyAfter(deltaTime: number): Consumer<T>;
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
declare class EventSubscriber<E> {
    private bus;
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus: EventBus);
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on<K extends keyof E & string>(topic: K): Consumer<E[K]>;
}

/** A handler for handling subscription data. */
declare type Handler<T> = (data: T) => void;
/** A handler for handling wildcard multiple subscription data. */
declare type WildcardHandler = (topic: string, data: any) => void;
/**
 * Meta-events published for event bus happenings.
 */
interface EventBusMetaEvents {
    /** General event bus topic, currently only used for resync requests. */
    event_bus: string;
    /** Notification that a topic has had a subscripiton.  */
    event_bus_topic_first_sub: string;
}
/**
 * An indexed event type. Indexed events have keys of the form `event_[index]`.
 */
declare type IndexedEventType<T extends string> = `${T}_${number}`;
/**
 * Mock event types.
 */
interface MockEventTypes {
    /** A random number event. */
    randomNumber: number;
}
/**
 * An interface that describes an event publisher.
 */
interface Publisher<E> {
    /**
     * Publishes an event with data to a topic.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param sync Whether or not to sync the data on the bus.
     * @param isCached Whether or not this event should be cached for retrieval.
     */
    pub<K extends keyof E>(topic: K, data: E[K], sync?: boolean, isCached?: boolean): void;
}
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
declare class EventBus {
    private _topicSubsMap;
    private _wildcardSubs;
    private _notifyDepthMap;
    private _wildcardNotifyDepth;
    private _eventCache;
    private _busSync;
    private _busId;
    protected readonly onWildcardSubDestroyedFunc: (sub: HandlerSubscription<WildcardHandler>) => void;
    /**
     * Creates an instance of an EventBus.
     * @param useAlternativeEventSync Whether or not to use generic listener event sync (default false).
     * If true, FlowEventSync will only work for gauges.
     * @param shouldResync Whether the eventbus should ask for a resync of all previously cached events (default true)
     */
    constructor(useAlternativeEventSync?: boolean, shouldResync?: boolean);
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(topic: string, handler: Handler<any>, paused?: boolean): Subscription;
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(topic: string, handler: Handler<any>): void;
    /**
     * Subscribes to all topics.
     * @param handler The handler to subscribe to all events.
     * @returns The new subscription.
     */
    onAll(handler: WildcardHandler): Subscription;
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.onAll()` to manage subscriptions.
     */
    offAll(handler: WildcardHandler): void;
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic: string, data: any, sync?: boolean, isCached?: boolean): void;
    /**
     * Responds to when a wildcard subscription is destroyed.
     * @param sub The destroyed subscription.
     */
    private onWildcardSubDestroyed;
    /**
     * Re-sync all synced events
     */
    private resyncEvents;
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    private syncEvent;
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher<E>(): Publisher<E>;
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber<E>(): EventSubscriber<E>;
    /**
     * Get the number of subscribes for a given topic.
     * @param topic The name of the topic.
     * @returns The number of subscribers.
     **/
    getTopicSubscriberCount(topic: string): number;
    /**
     * Executes a function once for each topic with at least one subscriber.
     * @param fn The function to execute.
     */
    forEachSubscribedTopic(fn: (topic: string, subscriberCount: number) => void): void;
}

/** A noop interface for global type guards */
interface EventTypes {
}
/**
 * A generic class for injecting pacing logic into a publisher.
 */
interface PublishPacer<E extends EventTypes> {
    canPublish<K extends keyof E>(topic: K, data: E[K]): boolean;
}
/**
 * A PublishPacer that only allows publishing on an interval.
 */
declare class IntervalPacer<E> {
    private interval;
    private lastPublished;
    /**
     * Create an IntervalPacer.
     * @param msec Time to wait between publishs in ms
     */
    constructor(msec: number);
    /**
     * Determine whether the data can be published based on the time since its
     * prior publish.
     * @param topic The topic data would be sent on.
     * @param data The data which would be sent.
     * @returns A bool indicating if the data should be published.
     */
    canPublish<K extends keyof E>(topic: keyof E, data: E[K]): boolean;
}
/**
 * A PublishPacer that only allows publishing when a value has changed
 * by a specifed amount from the prior publish.
 */
declare class DeltaPacer<E> {
    private delta;
    private lastPublished;
    /**
     * Create a DeltaPacer.
     * @param delta The difference required for publishing to be allowed.
     */
    constructor(delta: number);
    /**
     * Determine whether the data can be published based on its delta from the
     * pror publish.
     * @param topic The topic data would be sent on.
     * @param data The data which would be sent.
     * @returns A bool indicating if the data should be published.
     */
    canPublish<K extends keyof E>(topic: keyof E, data: number): boolean;
}

/**
 * Filters an event type record to only those topics that are associated with a given data type.
 */
declare type EventTopicDataTypeFilter<Events, DataType> = {
    [Topic in keyof Events as Events[Topic] extends DataType ? Topic : never]: Events[Topic];
};
/**
 * Republishes event bus topics.
 */
declare class EventRepublisher<SourceEvents, TargetEvents> {
    private readonly bus;
    private readonly metaEvents;
    private readonly sourceSubscriber;
    private readonly publisher;
    private readonly republishes;
    private republishId;
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Starts republishing data from a source topic to a target topic. Republishing will begin as soon as the target
     * topic has at least one subscriber, or immediately if the target topic data is synced across instruments.
     * @param sourceTopic The source topic.
     * @param targetTopic The target topic.
     * @param sync Whether the target topic should be synced across instruments.
     * @param cache Whether the target topic data should be cached.
     * @returns A unique ID associated with the republish.
     */
    startRepublish<Source extends keyof SourceEvents & string, Target extends keyof EventTopicDataTypeFilter<TargetEvents, SourceEvents[Source]>>(sourceTopic: Source, targetTopic: Target, sync: boolean, cache: boolean): number;
    /**
     * Starts republishing data from a source topic to a target topic after the data has been transformed by a mapping
     * function. Republishing will begin as soon as the target topic has at least one subscriber, or immediately if the
     * target topic data is synced across instruments.
     * @param sourceTopic The source topic.
     * @param targetTopic The target topic.
     * @param sync Whether the target topic should be synced across instruments.
     * @param cache Whether the target topic data should be cached.
     * @param map A mapping function to use to transform the source data.
     * @returns A unique ID associated with the republish.
     */
    startRepublish<Source extends keyof SourceEvents & string, Target extends keyof TargetEvents & string>(sourceTopic: Source, targetTopic: Target, sync: boolean, cache: boolean, map: (sourceData: SourceEvents[Source]) => TargetEvents[Target]): number;
    /**
     * Stops a republish handled by this publisher.
     * @param id The unique ID associated with the republish to stop.
     * @returns Whether the requested republish was stopped.
     */
    stopRepublish(id: number): boolean;
    /**
     * Clears all republishes from this publisher.
     */
    clearRepublishes(): void;
    /**
     * Registers a republish.
     * @param id A unique ID to associate with the republish.
     * @param sourceTopic The source topic.
     * @param targetTopic The target topic.
     * @param sync Whether the target topic should be synced across instruments.
     * @param cache Whether the target topic data should be cached.
     * @param map A mapping function to use to transform the source data.
     */
    private registerRepublish;
}

/**
 * Captures the state of a value from a consumer.
 */
declare class ConsumerValue<T> {
    private readonly consumerHandler;
    private value;
    private sub?;
    private _isPaused;
    /**
     * Whether event consumption is currently paused. While paused, this object's value will not update.
     */
    get isPaused(): boolean;
    private isDestroyed;
    /**
     * Creates an instance of a ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     */
    private constructor();
    /**
     * Gets the current value.
     * @returns The current value.
     */
    get(): T;
    /**
     * Sets the consumer from which this object derives its value. If the consumer is null, this object's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This object, after its consumer has been set.
     */
    setConsumer(consumer: Consumer<T> | null): this;
    /**
     * Pauses consuming events for this object. Once paused, this object's value will not be updated.
     * @returns This object, after it has been paused.
     */
    pause(): this;
    /**
     * Resumes consuming events for this object. Once resumed, this object's value will be updated from consumed
     * events.
     * @returns This object, after it has been resumed.
     */
    resume(): this;
    /**
     * Destroys this object. Once destroyed, it will no longer consume events to update its value.
     */
    destroy(): void;
    /**
     * Creates a new ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     * @returns The created ConsumerValue.
     */
    static create<T>(consumer: Consumer<T> | null, initialValue: T): ConsumerValue<T>;
}

/**
 * A basic implementation of {@link Consumer}.
 */
declare class BasicConsumer<T> implements Consumer<T> {
    private readonly subscribe;
    private state;
    private readonly currentHandler?;
    /** @inheritdoc */
    readonly isConsumer = true;
    private readonly activeSubs;
    /**
     * Creates an instance of a Consumer.
     * @param subscribe A function which subscribes a handler to the source of this consumer's events.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(subscribe: (handler: Handler<T>, paused: boolean) => Subscription, state?: any, currentHandler?: ((data: T, state: any, next: Handler<T>) => void) | undefined);
    /** @inheritdoc */
    handle(handler: Handler<T>, paused?: boolean): Subscription;
    /** @inheritdoc */
    off(handler: Handler<T>): void;
    /** @inheritdoc */
    atFrequency(frequency: number, immediateFirstPublish?: boolean): Consumer<T>;
    /**
     * Gets a handler function for a 'atFrequency' filter.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A handler function for a 'atFrequency' filter.
     */
    private getAtFrequencyHandler;
    /** @inheritdoc */
    withPrecision(precision: number): Consumer<T>;
    /**
     * Gets a handler function for a 'withPrecision' filter.
     * @param precision The decimal precision to snap to.
     * @returns A handler function for a 'withPrecision' filter.
     */
    private getWithPrecisionHandler;
    /** @inheritdoc */
    whenChangedBy(amount: number): Consumer<T>;
    /**
     * Gets a handler function for a 'whenChangedBy' filter.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A handler function for a 'whenChangedBy' filter.
     */
    private getWhenChangedByHandler;
    /** @inheritdoc */
    whenChanged(): Consumer<T>;
    /**
     * Gets a handler function for a 'whenChanged' filter.
     * @returns A handler function for a 'whenChanged' filter.
     */
    private getWhenChangedHandler;
    /** @inheritdoc */
    onlyAfter(deltaTime: number): Consumer<T>;
    /**
     * Gets a handler function for an 'onlyAfter' filter.
     * @param deltaTime The minimum delta time between events.
     * @returns A handler function for an 'onlyAfter' filter.
     */
    private getOnlyAfterHandler;
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    private with;
}

/**
 * Valid type arguments for Set/GetSimVarValue
 */
declare enum SimVarValueType {
    Number = "number",
    Percent = "percent",
    Degree = "degrees",
    Knots = "knots",
    Feet = "feet",
    Meters = "meters",
    FPM = "feet per minute",
    Radians = "radians",
    InHG = "inches of mercury",
    MB = "Millibars",
    Bool = "bool",
    Celsius = "celsius",
    MHz = "MHz",
    KHz = "KHz",
    NM = "nautical mile",
    String = "string",
    RPM = "Rpm",
    PPH = "Pounds per hour",
    GPH = "gph",
    Farenheit = "farenheit",
    PSI = "psi",
    GAL = "gallons",
    LBS = "pounds",
    Hours = "Hours",
    Volts = "Volts",
    Amps = "Amperes",
    Seconds = "seconds",
    Enum = "enum",
    LLA = "latlonalt",
    MetersPerSecond = "meters per second",
    Mach = "mach",
    Pounds = "pounds",
    SlugsPerCubicFoot = "slug per cubic foot"
}
/**
 * The definition of a simvar and associated value type.
 */
declare type SimVarDefinition = {
    /** The name of the simvar. */
    name: string;
    /** The value to be used to retrieve this simvar. */
    type: SimVarValueType;
};

/**
 * A basic event-bus publisher.
 */
declare class BasePublisher<E extends Record<string, any>> {
    protected readonly bus: EventBus;
    protected readonly publisher: Publisher<E>;
    protected publishActive: boolean;
    protected readonly pacer: PublishPacer<E> | undefined;
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<E> | undefined);
    /**
     * Start publishing.
     */
    startPublish(): void;
    /**
     * Stop publishing.
     */
    stopPublish(): void;
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing(): boolean;
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate(): void;
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced to other instruments. Defaults to `false`.
     * @param isCached Whether or not the event should be cached. Defaults to `true`.
     */
    protected publish<K extends keyof E>(topic: K, data: E[K], sync?: boolean, isCached?: boolean): void;
}
/**
 * A publisher that sends a constant stream of random numbers.
 */
declare class RandomNumberPublisher extends BasePublisher<MockEventTypes> {
    /**
     * Start publishing random numbers.
     */
    startPublish(): void;
    /**
     * Async thread that publishes random numbers
     * @param ms - Milliseconds to sleep between publishes
     */
    private publishRandomNumbers;
}
/**
 * An entry for a sim var publisher topic.
 */
declare type SimVarPublisherEntry<T> = SimVarDefinition & {
    /**
     * A function which maps the raw simvar value to the value to be published to the event bus. If not defined, the
     * raw simvar value will be published to the bus as-is.
     */
    map?: (value: any) => T;
    /**
     * Whether the simvar is indexed. Indexes are positive integers. If the simvar is indexed, then the indexed simvars -
     * with the index replacing the `#index#` macro in the simvar name - will published to topics suffixed with
     * `_[index]`. The index-1 version of the simvar will be published to the unsuffixed topic in addition to the topic
     * suffixed with index 1.
     */
    indexed?: boolean;
};
/**
 * An entry for a fully resolved sim var publisher topic.
 */
declare type ResolvedSimVarPublisherEntry<T> = Omit<SimVarPublisherEntry<T>, 'indexed'>;
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
declare class SimVarPublisher<E extends Record<string, any>> extends BasePublisher<E> {
    protected static readonly INDEXED_REGEX: RegExp;
    protected readonly resolvedSimVars: Map<keyof E & string, ResolvedSimVarPublisherEntry<any>>;
    protected readonly indexedSimVars: Map<keyof E & string, SimVarPublisherEntry<any>>;
    protected readonly subscribed: Set<keyof E & string>;
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap: Map<keyof E & string, SimVarPublisherEntry<any>>, bus: EventBus, pacer?: PublishPacer<E>);
    /**
     * Checks if a subscribed topic matches one of this publisher's indexed topics, and if so resolves and starts
     * publishing the indexed topic.
     * @param topic The subscribed topic to check.
     */
    protected tryMatchIndexedSubscribedTopic(topic: string): void;
    /**
     * Resolves an indexed topic with an index, generating a version of the topic which is mapped to an indexed simvar.
     * The resolved indexed topic can then be published.
     * @param topic The topic to resolve.
     * @param entry The entry of the topic to resolve.
     * @param index The index with which to resolve the topic. If not defined, the topic will resolve to itself (without
     * a suffix) and will be mapped the index-1 version of its simvar.
     * @returns The resolved indexed topic.
     */
    protected resolveIndexedSimVar(topic: keyof E & string, entry: SimVarPublisherEntry<any>, index?: number): string;
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    protected onTopicSubscribed(topic: keyof E & string): void;
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    subscribe(data: keyof E): void;
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    unsubscribe(data: keyof E): void;
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate(): void;
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    protected publishTopic(topic: keyof E & string): void;
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    protected getValue<K extends keyof E & string>(topic: K): E[K] | undefined;
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    private getSimVarValue;
}
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
declare class GameVarPublisher<E extends Record<string, any>> extends BasePublisher<E> {
    protected readonly simvars: Map<keyof E & string, SimVarPublisherEntry<any>>;
    protected readonly subscribed: Set<keyof E & string>;
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap: Map<keyof E & string, SimVarDefinition>, bus: EventBus, pacer?: PublishPacer<E>);
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    protected onTopicSubscribed(topic: keyof E & string): void;
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    subscribe(data: keyof E): void;
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    unsubscribe(data: keyof E): void;
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate(): void;
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    protected publishTopic(topic: keyof E & string): void;
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    protected getValue<K extends keyof E & string>(topic: K): E[K] | undefined;
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    private getGameVarValue;
}

/**
 * H:Event events from the EventBus.
 */
declare type HEvent = {
    /** An H:Event event. */
    hEvent: string;
};
/**
 * A publisher for publishing H:Events on the bus.
 */
declare class HEventPublisher extends BasePublisher<HEvent> {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent: string, sync?: boolean): void;
}

/**
 * Events published by the StallWarningPublisher.
 */
interface StallWarningEvents {
    /** Whether or not the stall warning is on. */
    'stall_warning_on': boolean;
}
/**
 * A publisher than handles publishing a debounced stall warning event based on an input AoA.
 */
declare class StallWarningPublisher extends BasePublisher<StallWarningEvents> {
    private readonly aoaThreshold;
    private readonly debounceMs;
    private readonly aoa;
    private readonly onGround;
    private readonly stallAoA;
    private stallWarningOn;
    private debounceTimeRemaining;
    private previousTime;
    /**
     * Creates an instance of the StallWarningPublisher. Requires the `aoa` (if not provided) and `on_ground` events from `AdcEvents``.
     * @param bus The event bus to use with this instance.
     * @param aoaThreshold The AoA stall warning threshold, where 1 is 100% of stall AoA.
     * @param debounceMs The amount of time, in milliseconds, to debounce the stall warning. Defaults to 500 ms.
     * @param aoa An optional subscribable that provides the AoA value, in degrees.
     */
    constructor(bus: EventBus, aoaThreshold: number, debounceMs?: number, aoa?: Subscribable<number>);
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Sets whether the stall warning is on or not.
     * @param isOn Whether the stall warning is on.
     */
    private setStallWarningOn;
}

/**
 * Base events related to air data computer information.
 */
interface BaseAdcEvents {
    /** The airplane's indicated airspeed, in knots. */
    ias: number;
    /** The airplane's true airspeed, in knots. */
    tas: number;
    /** The airplane's indicated altitude, in feet. */
    indicated_alt: number;
    /** The airplane's pressure altitude, in feet. */
    pressure_alt: number;
    /** The airplane's vertical speed, in feet per minute. */
    vertical_speed: number;
    /** The airplane's radio altitude, in feet. */
    radio_alt: number;
    /** The current altimeter baro setting, in inches of mercury. */
    altimeter_baro_setting_inhg: number;
    /** The current altimeter baro setting, in millibars. */
    altimeter_baro_setting_mb: number;
    /** The current preselected altimeter baro setting, in inches of mercury. */
    altimeter_baro_preselect_inhg: number;
    /** The current preselected altimeter baro setting, in millibars. */
    altimeter_baro_preselect_mb: number;
    /** The current preselected altimeter baro setting, in raw units (1/16th millibar). */
    altimeter_baro_preselect_raw: number;
    /** Whether the altimeter baro setting is set to STD (true=STD, false=set pressure). */
    altimeter_baro_is_std: boolean;
    /** The ambient temperature, in degrees Celsius. */
    ambient_temp_c: number;
    /** The ambient pressure, in inches of mercury. */
    ambient_pressure_inhg: number;
    /** The current ISA temperature, in degrees Celsius. */
    isa_temp_c: number;
    /** The current ram air temperature, in degrees Celsius. */
    ram_air_temp_c: number;
    /** The ambient wind velocity, in knots. */
    ambient_wind_velocity: number;
    /** The ambient wind direction, in degrees true. */
    ambient_wind_direction: number;
    /** Whether the plane is on the ground. */
    on_ground: boolean;
    /** The angle of attack, in degrees. */
    aoa: number;
    /** The stall angle of attack of the current aircraft configuration, in degrees. */
    stall_aoa: number;
    /** The zero-lift angle of attack of the current aircraft configuration, in degrees. */
    zero_lift_aoa: number;
    /** The speed of the aircraft in mach. */
    mach_number: number;
    /**
     * The conversion factor from mach to knots indicated airspeed in the airplane's current environment. In other
     * words, the speed of sound in knots indicated airspeed.
     */
    mach_to_kias_factor: number;
}
/**
 * Topics indexed by airspeed indicator.
 */
declare type AdcAirspeedIndexedTopics = 'ias' | 'tas' | 'mach_to_kias_factor';
/** Topics indexed by altimeter. */
declare type AdcAltimeterIndexedTopics = 'indicated_alt' | 'altimeter_baro_setting_inhg' | 'altimeter_baro_setting_mb' | 'altimeter_baro_preselect_inhg' | 'altimeter_baro_preselect_mb' | 'altimeter_baro_preselect_raw' | 'altimeter_baro_is_std';
/**
 * Topics related to air data computer information that are indexed.
 */
declare type AdcIndexedTopics = AdcAirspeedIndexedTopics | AdcAltimeterIndexedTopics;
/**
 * Indexed events related to air data computer information.
 */
declare type AdcIndexedEvents = {
    [P in keyof Pick<BaseAdcEvents, AdcIndexedTopics> as IndexedEventType<P>]: BaseAdcEvents[P];
};
/**
 * Events related to air data computer information.
 */
interface AdcEvents extends BaseAdcEvents, AdcIndexedEvents {
}
/**
 * A publisher for air data computer information.
 */
declare class AdcPublisher extends SimVarPublisher<AdcEvents> {
    private mach;
    private needUpdateMach;
    /**
     * Creates an AdcPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<AdcEvents>);
    /** @inheritdoc */
    protected onTopicSubscribed(topic: keyof AdcEvents): void;
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * Base events related to attitude and heading of the airplane.
 */
interface BaseAhrsEvents {
    /** The indicated heading of the airplane, in degrees magnetic. */
    hdg_deg: number;
    /** The indicated heading of the airplane, in degrees true. */
    hdg_deg_true: number;
    /** The indicated pitch of the airplane, in degrees. Positive values indicate downward pitch. */
    pitch_deg: number;
    /** The indicated roll (bank) of the airplane, in degrees. Positive values indicate leftward roll. */
    roll_deg: number;
    /** A turn coordinator ball value. */
    turn_coordinator_ball: number;
    /** The turn rate of the airplane, in degrees per second. */
    delta_heading_rate: number;
    /** The actual heading of the airplane, in degrees magnetic. */
    actual_hdg_deg: number;
    /** The actual heading of the airplane, in degrees true. */
    actual_hdg_deg_true: number;
    /** The actual pitch of the airplane, in degrees. Positive values indicate downward pitch. */
    actual_pitch_deg: number;
    /** The actual roll (bank) of the airplane, in degrees. Positive values indicate leftward roll. */
    actual_roll_deg: number;
}
/**
 * Topics that are indexed by attitude indicator.
 */
declare type AhrsAttitudeIndexedTopics = 'pitch_deg' | 'roll_deg';
/**
 * Topics that are indexed by direction indicator.
 */
declare type AhrsDirectionIndexedTopics = 'hdg_deg' | 'hdg_deg_true' | 'delta_heading_rate';
/**
 * All topics related to attitude and heading of the airplane that are indexed.
 */
declare type AhrsIndexedTopics = AhrsAttitudeIndexedTopics | AhrsDirectionIndexedTopics;
/**
 * Indexed events related to attitude and heading of the airplane.
 */
declare type AhrsIndexedEvents = {
    [P in keyof Pick<BaseAhrsEvents, AhrsIndexedTopics> as IndexedEventType<P>]: BaseAhrsEvents[P];
};
/**
 * Events related to attitude and heading of the airplane.
 */
interface AhrsEvents extends BaseAhrsEvents, AhrsIndexedEvents {
}
/**
 * A publisher for AHRS information.
 */
declare class AhrsPublisher extends SimVarPublisher<AhrsEvents> {
    private magVar;
    private needUpdateMagVar;
    /**
     * Creates an AhrsPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<AhrsEvents>);
    /** @inheritdoc */
    protected onTopicSubscribed(topic: keyof AhrsEvents): void;
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * Non-indexed events related to the anti-ice systems.
 */
interface AntiIceNonIndexedEvents {
    /** Whether the structural anti-ice switch is in the on position. */
    anti_ice_structural_switch_on: boolean;
    /** Whether the windshield anti-ice switch is in the on position. */
    anti_ice_windshield_switch_on: boolean;
}
/**
 * Anti-ice topics indexed by engine.
 */
interface AntiIceEngineIndexedTopics {
    /** Whether an engine anti-ice switch is in the on position. */
    anti_ice_engine_switch_on: boolean;
    /** Whether a propeller anti-ice switch is in the on position. */
    anti_ice_prop_switch_on: boolean;
}
/**
 * Engine-indexed events related to the anti-ice systems.
 */
declare type AntiIceEngineIndexedEvents = {
    [P in keyof AntiIceEngineIndexedTopics as IndexedEventType<P>]: AntiIceEngineIndexedTopics[P];
};
/**
 * Events related to the anti-ice systems.
 */
declare type AntiIceEvents = AntiIceNonIndexedEvents & AntiIceEngineIndexedEvents;
/**
 * A publisher for anti-ice system information.
 */
declare class AntiIcePublisher extends SimVarPublisher<AntiIceEvents> {
    private static readonly nonIndexedSimVars;
    /**
     * Creates an instance of an AntiIcePublisher.
     * @param bus The event bus to use with this instance.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<AntiIceEvents>);
}

/** Data related to autopilot */
interface APSimVarEvents {
    /** Whether the autopilot master is active. */
    ap_master_status: boolean;
    /** Whether the yaw damper is active. */
    ap_yd_status: boolean;
    /** Whether the autopilot is in heading hold mode. */
    ap_heading_hold: boolean;
    /** Whether the autopilot is in NAV mode. */
    ap_nav_hold: boolean;
    /** Whether the autopilot is in approach mode. */
    ap_approach_hold: boolean;
    /** Whether the autopilot is in backcourse mode. */
    ap_backcourse_hold: boolean;
    /** Whether the autopilot is in bank hold mode. */
    ap_bank_hold: boolean;
    /** The autopilot max bank value ID (usually 0 for standard, 1 for half bank). */
    ap_max_bank_id: number;
    /** The current set autopilot max bank value in absolute degrees. */
    ap_max_bank_value: number;
    /** Whether the autopilot is in wings level mode. */
    ap_wing_lvl_hold: boolean;
    /** Whether the autopilot is in vertical speed hold mode. */
    ap_vs_hold: boolean;
    /** Whether the autopilot is in flight level change mode. */
    ap_flc_hold: boolean;
    /** Whether the autopilot is in altitude hold mode. */
    ap_alt_hold: boolean;
    /** Whether the autopilot is in glideslope hold mode. */
    ap_glideslope_hold: boolean;
    /** Whether the autopilot is in pitch hold mode. */
    ap_pitch_hold: boolean;
    /** Whether the autopilot is in TO/GA mode. */
    ap_toga_hold: boolean;
    /** The autopilot's selected pitch target, in degrees. */
    ap_pitch_selected: number;
    /** The autopilot's selected heading in slot 1, in degrees. */
    ap_heading_selected: number;
    /** The autopilot's selected heading in slot 1, in degrees. */
    ap_heading_selected_1: number;
    /** The autopilot's selected heading in slot 2, in degrees. */
    ap_heading_selected_2: number;
    /** The autopilot's selected heading in slot 3, in degrees. */
    ap_heading_selected_3: number;
    /** The autopilot's selected altitude in slot 1, in feet. */
    ap_altitude_selected: number;
    /** The autopilot's selected altitude in slot 1, in feet. */
    ap_altitude_selected_1: number;
    /** The autopilot's selected altitude in slot 2, in feet. */
    ap_altitude_selected_2: number;
    /** The autopilot's selected altitude in slot 3, in feet. */
    ap_altitude_selected_3: number;
    /** The autopilot's selected vertical speed target, in feet per minute. */
    ap_vs_selected: number;
    /** The autopilot's selected flight path angle target, in degrees */
    ap_fpa_selected: number;
    /** The autopilot's selected airspeed target, in knots. */
    ap_ias_selected: number;
    /** The autopilot's selected mach target. */
    ap_mach_selected: number;
    /** Whether the autopilot's selected airspeed target is in mach. */
    ap_selected_speed_is_mach: boolean;
    /** Whether the autopilot's selected airspeed target is manually set. */
    ap_selected_speed_is_manual: boolean;
    /** The bank commanded by the flight director, in degrees. */
    flight_director_bank: number;
    /** The pitch commanded by the flight director, in degrees. */
    flight_director_pitch: number;
    /** Whether the flight director is active. */
    [flight_director_is_active: IndexedEventType<'flight_director_is_active'>]: boolean;
    /** Whether VNAV is active. */
    vnav_active: boolean;
}
declare enum APLockType {
    Heading = 0,
    Nav = 1,
    Alt = 2,
    Bank = 3,
    WingLevel = 4,
    Vs = 5,
    Flc = 6,
    Pitch = 7,
    Approach = 8,
    Backcourse = 9,
    Glideslope = 10,
    VNav = 11
}
/** The events related to an autopilot */
interface APEvents extends APSimVarEvents {
    /** Autopilot has been engaged. */
    ap_master_engage: true;
    /** Autopilot has been disengaged. */
    ap_master_disengage: true;
    /** Yaw damper has been engaged. */
    ap_yd_engage: true;
    /** Yaw damper has been disengaged. */
    ap_yd_disengage: true;
    /** An autopilot lock has been set. */
    ap_lock_set: APLockType;
    /** An autopilot lock has been released. */
    ap_lock_release: APLockType;
}
/** base publisher for simvars */
declare class APSimVarPublisher extends SimVarPublisher<APSimVarEvents> {
    private static simvars;
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<APSimVarEvents> | undefined);
}
/**
 * Publishes autopilot data
 */
declare class AutopilotPublisher extends BasePublisher<APEvents> {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<APEvents>);
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage(): void;
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage(): void;
    /**
     * Publish a YD engage event
     */
    publishYdEngage(): void;
    /**
     * Publish a YD disengage event
     */
    publishYdDisengage(): void;
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock: APLockType): void;
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock: APLockType): void;
}
/**
 * Manages an autopilot system
 */
declare class AutopilotInstrument {
    private bus;
    publisher: AutopilotPublisher;
    simVarPublisher: APSimVarPublisher;
    private simVarSubscriber;
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus: EventBus);
    /**
     * Initialize the instrument
     */
    init(): void;
    /** update our publishers */
    onUpdate(): void;
}

/**
 * An instrument supported by {@link InstrumentBackplane}.
 */
interface Instrument {
    /** Initializes this instrument. */
    init(): void;
    /** Updates this instrument. */
    onUpdate(): void;
}
/**
 * A publisher supported by {@link BackplanePublisher}
 */
interface BackplanePublisher {
    /** Sets this publisher to begin publishing. */
    startPublish(): void;
    /** Updates this publisher. */
    onUpdate(): void;
}
/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
declare class InstrumentBackplane {
    private publishers;
    private instruments;
    /**
     * Create an InstrumentBackplane
     */
    constructor();
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init(): void;
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate(): void;
    /**
     * Add a publisher to this backplane.
     * @param name A symbolic name for the publisher for reference.
     * @param publisher The publisher to add.
     * @param override Whether to override any existing publishers added to this backplane under the same name. If
     * `true`, any existing publisher with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new publisher will not be added if this backplane already has a publisher with the same
     * name or a publisher of the same type. Defaults to `false`.
     */
    addPublisher(name: string, publisher: BackplanePublisher, override?: boolean): void;
    /**
     * Add an instrument to this backplane.
     * @param name A symbolic name for the instrument for reference.
     * @param instrument The instrument to add.
     * @param override Whether to override any existing instruments added to this backplane under the same name. If
     * `true`, any existing instrument with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new instrument will not be added if this backplane already has an instrument with the same
     * name or an instrument of the same type. Defaults to `false`.
     */
    addInstrument(name: string, instrument: Instrument, override?: boolean): void;
    /**
     * Gets a publisher from this backplane.
     * @param name The name of the publisher to get.
     * @returns The publisher in this backplane with the specified name, or `undefined` if there is no such publisher.
     */
    getPublisher<T extends BackplanePublisher = BackplanePublisher>(name: string): T | undefined;
    /**
     * Gets an instrument from this backplane.
     * @param name The name of the instrument to get.
     * @returns The instrument in this backplane with the specified name, or `undefined` if there is no such instrument.
     */
    getInstrument<T extends Instrument = Instrument>(name: string): T | undefined;
    /**
     * Checks for duplicate publishers or instruments of the same name or type.
     * @param name the name of the publisher or instrument
     * @param objToCheck the object to check
     * @param map the map to check
     * @returns true if the object is already in the map
     */
    private static checkAlreadyExists;
    /**
     * Initialize all of the publishers that you hold.
     */
    private initPublishers;
    /**
     * Initialize all of the instruments that you hold.
     */
    private initInstruments;
    /**
     * Update all of the publishers that you hold.
     */
    private updatePublishers;
    /**
     * Update all of the instruments that you hold.
     */
    private updateInstruments;
}

/**
 * Com radio index.
 */
declare type ComRadioIndex = 1 | 2 | 3;
/**
 * Nav radio index.
 */
declare type NavRadioIndex = 1 | 2 | 3 | 4;
/**
 * ADF radio index.
 */
declare type AdfRadioIndex = 1 | 2;
/** The basic radio types. */
declare enum RadioType {
    Com = "COM",
    Nav = "NAV",
    Adf = "ADF"
}
/** Encapsulates a single radio's state. */
declare type Radio = {
    /** Index number of the radio. */
    index: number;
    /** The current active frequency. */
    activeFrequency: number;
    /** The ident of the active station */
    ident: string | null;
    /** Signal strength of the active station. */
    signal: number;
    /** The current standby frequency. */
    standbyFrequency: number;
    /** The appropriate RadioType for this radio. */
    radioType: RadioType;
    /** Whether this radio is selected for changes. */
    selected: boolean;
};
/** The two frequency "banks", active and standby. */
declare enum FrequencyBank {
    Active = 0,
    Standby = 1
}
/** Events relating to changes in a radio's state. */
interface RadioEvents {
    /** Set the state of a radio. */
    set_radio_state: Radio;
    /** Change the stanby frequency in a radio. */
    set_frequency: FrequencyChangeEvent;
    /** Publish the ident of a tuned station. */
    set_ident: IdentChangeEvent;
    /** Publish the signal strength of the active station. */
    set_signal_strength: number;
    /** ADF1 Standby Frequency */
    adf_standby_frequency_1: number;
    /** ADF1 Active Frequency */
    adf_active_frequency_1: number;
}
/** Encapsuation of a frequency change event. */
declare type FrequencyChangeEvent = {
    /** The type of radio to change. */
    radio: Radio;
    /** The frequency bank to update. */
    bank: FrequencyBank;
    /** The new frequency in MHz. */
    frequency: number;
};
/** Encapsulation of a new ident event */
declare type IdentChangeEvent = {
    /** The radio currently tuned. */
    index: number;
    /** The new ident. */
    ident: string;
};
/** COM frequency spacing on COM radios. */
declare enum ComSpacing {
    /** 25Khz spacing */
    Spacing25Khz = 0,
    /** 8.33Khz spacing */
    Spacing833Khz = 1
}
/** Encapsulation of a COM spacing change event. */
declare type ComSpacingChangeEvent = {
    /** The index of the COM radio to update. */
    index: number;
    /** The spacing of the COM radio. */
    spacing: ComSpacing;
};

/**
 * Nav radio data event roots.
 */
declare type NavRadioDataEventsRoot = {
    /** Nav radio selected course, in degrees. */
    nav_obs: number;
    /** Nav radio signal strength, in arbitrary units. A value of `0` indicates no signal. */
    nav_signal: number;
    /** Whether a nav radio's tuned station has a DME component. */
    nav_has_dme: boolean;
    /** Whether a nav radio's tuned station has a VOR component. */
    nav_has_nav: boolean;
    /** Nav radio course needle deflection, scaled to +/-127. */
    nav_cdi: number;
    /** Nav radio DME distance, in nautical miles. */
    nav_dme: number;
    /** Nav radio radial, in degrees (the radial from the tuned station on which the airplane lies). */
    nav_radial: number;
    /** Nav radio ident string. */
    nav_ident: string;
    /** Nav radio to/from flag. */
    nav_to_from: VorToFrom;
    /** Whether a nav radio's tuned station is a localizer. */
    nav_localizer: boolean;
    /** The set course, in degrees, of a nav radio's tuned localizer. */
    nav_localizer_crs: number;
    /** The airport ident of a nav radio's tuned localizer. */
    nav_loc_airport_ident: string;
    /** The runway number of a nav radio's tuned localizer. */
    nav_loc_runway_number: number;
    /** The runway designator of a nav radio's tuned localizer. */
    nav_loc_runway_designator: number;
    /** Whether a nav radio's tuned station has a glideslope. */
    nav_glideslope: boolean;
    /** The angle of a nav radio's tuned glideslope, in degrees. */
    nav_raw_gs: number;
    /** Nav radio glideslope angle error, in degrees. Positive values indicate position above the glideslope. */
    nav_gs_error: number;
    /** The location of a nav radio's tuned VOR station. */
    nav_lla: LatLongAlt;
    /** The location of a nav radio's tuned DME station. */
    nav_dme_lla: LatLongAlt;
    /** The location of a nav radio's tuned glideslope antenna. */
    nav_gs_lla: LatLongAlt;
    /** The nominal magnetic variation defined for a nav radio's tuned station. */
    nav_magvar: number;
};
/**
 * Data events for an indexed nav radio.
 */
declare type NavRadioDataEventsIndexed<Index extends NavRadioIndex> = {
    [Event in keyof NavRadioDataEventsRoot as `${Event}_${Index}`]: NavRadioDataEventsRoot[Event];
};
/**
 * Events related to data received by nav radios.
 */
interface NavRadioDataEvents extends NavRadioDataEventsIndexed<1>, NavRadioDataEventsIndexed<2>, NavRadioDataEventsIndexed<3>, NavRadioDataEventsIndexed<4> {
}
/**
 * ADF radio data event roots.
 */
declare type AdfRadioDataEventsRoot = {
    /** ADF radio signal strength, in arbitrary units. A value of `0` indicates no signal. */
    adf_signal: number;
    /** ADF radio relative bearing, in degrees (the bearing to the tuned station, relative to airplane heading). */
    adf_bearing: number;
    /** The location of an ADF radio's tuned station. */
    adf_lla: LatLongAlt;
};
/**
 * Data events for an indexed ADF radio.
 */
declare type AdfRadioDataEventsIndexed<Index extends AdfRadioIndex> = {
    [Event in keyof AdfRadioDataEventsRoot as `${Event}_${Index}`]: AdfRadioDataEventsRoot[Event];
};
/**
 * Events related to data received by ADF radios.
 */
interface AdfRadioDataEvents extends AdfRadioDataEventsIndexed<1>, AdfRadioDataEventsIndexed<2> {
}
/**
 * Events related to data received by ADF radios.
 */
interface AdfRadioDataEvents {
    /** ADF radio signal strength, in arbitrary units. A value of `0` indicates no signal. */
    [adf_signal: IndexedEventType<'adf_signal'>]: number;
    /** ADF radio relative bearing, in degrees (the bearing to the tuned station, relative to airplane heading). */
    [adf_bearing: IndexedEventType<'adf_bearing'>]: number;
    /** The location of an ADF radio's tuned station. */
    [adf_lla: IndexedEventType<'adf_lla'>]: LatLongAlt;
}
/**
 * Events related to data received by nav radios, ADF radios, marker beacons, and GPS.
 */
interface NavProcSimVars extends NavRadioDataEvents, AdfRadioDataEvents {
    /** DTK to the next GPS waypoint */
    gps_dtk: number;
    /** XTK error for the next GPS waypoint */
    gps_xtk: number;
    /** next GPS waypoint */
    gps_wp: string;
    /** next GPS waypoint bearing */
    gps_wp_bearing: number;
    /** next GPS waypoint distance */
    gps_wp_distance: number;
    /** Marker Beacon State */
    mkr_bcn_state_simvar: MarkerBeaconState;
    /** GPS Obs Active */
    gps_obs_active_simvar: boolean;
    /** GPS Obs Value Setting */
    gps_obs_value_simvar: number;
}
/**
 * A publisher of nav radio, ADF radio, GPS, and marker beacon-related sim var events.
 */
declare class NavProcSimVarPublisher extends SimVarPublisher<NavProcSimVars> {
    private static readonly simvars;
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<NavProcSimVars> | undefined);
    /**
     * Creates an array of nav radio sim var event definitions for an indexed nav radio.
     * @param index The index of the nav radio.
     * @returns An array of nav radio sim var event definitions for the specified nav radio.
     */
    private static createNavRadioDefinitions;
    /**
     * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
     * @param index The index of the ADF radio.
     * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
     */
    private static createAdfRadioDefinitions;
}
declare enum NavSourceType {
    Nav = 0,
    Gps = 1,
    Adf = 2
}
declare enum VorToFrom {
    OFF = 0,
    TO = 1,
    FROM = 2
}
/** Specified for a particular navigation source */
declare type NavSourceId = {
    /** The type of source it is. */
    type: NavSourceType | null;
    /** The index of this in the given source type. */
    index: number;
};
/** The OBS setting for a nav source. */
declare type ObsSetting = {
    /** the nav source */
    source: NavSourceId;
    /** the setting in degrees */
    heading: number | null;
};
/** the deviation setting for a nav source */
declare type CdiDeviation = {
    /** the nav source */
    source: NavSourceId;
    /** the setting in degrees */
    deviation: number | null;
};
/** The to/from value for a vor radio. */
declare type VorToFromSetting = {
    /** the to/from setting for the VOR */
    toFrom: VorToFrom;
    /** the nav source id */
    source: NavSourceId;
};
/** The dme state for a nav radio. */
declare type DmeState = {
    /** whether the radio has DME */
    hasDme: boolean;
    /** this distance to the DME station */
    dmeDistance: number | null;
    /** the nav source id */
    source: NavSourceId;
};
/** whether a nav source has a localizer signal. */
declare type Localizer = {
    /** whether there is a localizer signal */
    isValid: boolean;
    /** the localizer course */
    course: number;
    /** the nav source id */
    source: NavSourceId;
};
/** whether a nav source is tuned to a localizer frequency. */
declare type LocalizerFrequency = {
    /** if the freq is a loc */
    isLocalizer: boolean;
    /** the nav source id */
    source: NavSourceId;
};
/** whether a nav source has a glideslope signal. */
declare type Glideslope = {
    /** whether there is a gs signal */
    isValid: boolean;
    /** the gs deviation value */
    deviation: number;
    /** the angle of the gs */
    gsAngle: number;
    /** the nav source id */
    source: NavSourceId;
};
/** The magnetic variation for a tuned nav station. */
declare type NavMagneticVariation = {
    /** the magnetic variation value */
    variation: number;
    /** the nav source id */
    source: NavSourceId;
};
/** The validity for a bearing source. */
declare type BearingValidity = {
    /** the index number of the reference being changed */
    index: number;
    /** the new validity */
    valid: boolean;
};
/** The ident for a bearing source. */
declare type BearingIdent = {
    /** the index number of the reference being changed */
    index: number;
    /** the new ident */
    ident: string | null;
    /** is this station a loc */
    isLoc: boolean | null;
};
/** An indexed source setting */
declare type BearingSource = {
    /** the index number of the reference being changed */
    index: number;
    /** the new source instrument */
    source: NavSourceId | null;
};
/** An indexed source setting */
declare type BearingDirection = {
    /** the index number of the reference being changed */
    index: number;
    /** the new source instrument */
    direction: number | null;
};
/** An indexed source setting */
declare type BearingDistance = {
    /** the index number of the reference being changed */
    index: number;
    /** the new source instrument */
    distance: number | null;
};
/** If the bearing source is a localizer. */
declare type BearingIsLoc = {
    /** the index number of the reference being changed */
    index: number;
    /** if the source is a loc */
    isLoc: boolean | null;
};
/** Marker beacon signal state. */
declare enum MarkerBeaconState {
    Inactive = 0,
    Outer = 1,
    Middle = 2,
    Inner = 3
}
/** navprocessor events */
interface NavEvents {
    /** an OBS heading in degrees*/
    obs_set: ObsSetting;
    /** a CDI selection event */
    cdi_select: NavSourceId;
    /** actual deviation in points */
    cdi_deviation: CdiDeviation;
    /** dme distance in nm */
    dme_distance: number;
    /** dme speed in kt */
    dme_speed: number;
    /** vor distance in m */
    vor_distance: number;
    /** nav to/from value */
    vor_to_from: VorToFromSetting;
    /** nav radio selected */
    nav_select: number;
    /** the validity of a bearing source */
    brg_validity: BearingValidity;
    /** the ident for a bearing needle */
    brg_ident: BearingIdent;
    /** changed source of a bearing needle */
    brg_source: BearingSource;
    /** changed distance of a bearing needle */
    brg_distance: BearingDistance;
    /** changed heading to a bearing source */
    brg_direction: BearingDirection;
    /** changed magnetic variation for a tune nav station */
    mag_variation: NavMagneticVariation;
    /** whether a localizer exists and its course */
    localizer: Localizer;
    /** whether a glideslope exists and its deviation */
    glideslope: Glideslope;
    /** whether a nav source frequency is a localizer frequency */
    is_localizer_frequency: LocalizerFrequency;
    /** Marker Beacon State */
    mkr_bcn_state: MarkerBeaconState;
    /** DME State */
    dme_state: DmeState;
    /** GPS Obs Active */
    gps_obs_active: boolean;
    /** GPS Obs Value Setting */
    gps_obs_value: number;
}
/** The interface to a nav source. */
interface NavSource {
    /** The ID of the source. */
    srcId: NavSourceId;
    /** The nav signal strength. */
    signal: number | null;
    /** Whether the source info is valed. */
    valid: boolean;
    /** Whether this is an active bearing source. */
    activeBrg: boolean;
    /** Whether this is an active CDI source. */
    activeCdi: boolean;
    /** Whether this source provides course deviation information. */
    hasCdi: boolean;
    /** Whether the source provides DME info. */
    hasDme: boolean;
    /** Whether the source has glideslope info. */
    hasGlideslope: boolean;
    /** Whether the source has localizer info. */
    hasLocalizer: boolean;
    /** Whether the source is a localizer frequency. */
    isLocalizerFrequency: boolean | null;
    /** A handler to call when source validity changes. */
    validHandler?: ((valid: boolean, source: NavSourceId) => void);
    /** A handler to call when the source ident changes. */
    identHandler?: ((ident: string | null, source: NavSourceId) => void);
    /** A handler to call when the bearing to the source changes. */
    brgHandler?: ((bearing: number | null, source: NavSourceId) => void);
    /** A handler to call when the distance to the source changes. */
    distHandler?: ((distance: number | null, source: NavSourceId) => void);
    /** A handler to call when the OBS setting for the source changes. */
    obsHandler?: ((heading: number | null, source: NavSourceId) => void);
    /** A handler to call when the lateral deviation from the source changes. */
    deviationHandler?: ((deviation: number | null, source: NavSourceId) => void);
    /** A handler to call when the to/from state of the source changes. */
    toFromHandler?: ((toFrom: VorToFrom, source: NavSourceId) => void);
    /** A handler to call when the vertical deviation from the source changes. */
    glideslopeDeviationHandler?: ((deviation: number | null, source: NavSourceId) => void);
    /** A handler to call when the angle on the glide slope changes. */
    glideslopeAngleHandler?: ((angle: number | null, source: NavSourceId) => void);
    /** A handler to call when the magvar of the source changes. */
    magvarHandler?: ((magvar: number | null, source: NavSourceId) => void);
    /** A handler to call when wtf.  */
    isLocalizerFrequencyHandler?: ((isLocalizer: boolean | null, source: NavSourceId) => void);
    /** The ident for this source. */
    ident: string | null;
    /** The bearing to this source. */
    bearing: number | null;
    /** Distance to the source. */
    distance: number | null;
    /** OBS bearing in degrees. */
    obs?: number;
    /** Deviation in points. */
    deviation?: number | null;
    /** The to/from state of the source. */
    toFrom?: VorToFrom;
    /** The localizer course. */
    localizerCourse?: number | null;
    /** The glideslope deviation. */
    glideslopeDeviation?: number | null;
    /** The glideslope angle. */
    glideslopeAngle?: number | null;
    /** The magnetic variation at the source. */
    magneticVariation?: number | null;
}
/**
 * A convenience class for creating a navproc configuration set.
 *
 * Implementers should instantiate this and then populate the sets with the
 * HEvents that their radio sends for various actions.
 */
declare class NavProcessorConfig {
    numNav: number;
    numGps: number;
    numAdf: number;
    courseIncEvents: Set<string>;
    courseDecEvents: Set<string>;
    courseSyncEvents: Set<string>;
    simVarPublisher?: NavProcSimVarPublisher;
    additionalSources: NavSource[];
}
/**
 * The core of tne nav processor
 */
declare class NavProcessor {
    private bus;
    private config;
    private cdiSourceIdx;
    private bearingSourceIdxs;
    private hEvents;
    private navComSubscriber;
    private publisher;
    private simVarPublisher;
    private controlSubscriber;
    private simVarSubscriber;
    private navSources;
    private readonly brgSrcAsoboMap;
    /**
     * Create a NavProcessor.
     * @param bus The event bus to publish to.
     * @param config A config object defining our radio options.
     */
    constructor(bus: EventBus, config: NavProcessorConfig);
    /**
     * Initialize a nav processor
     */
    init(): void;
    /**
     * Add a custom nav source to the processor.
     * @param source The implementation of NavSourceBase to add.
     */
    addNavSource(source: NavSource): void;
    /**
     * Process a CDI source change event.
     * @param index is specified if a specific cdiSourceIdx is requested
     */
    private switchCdiSrc;
    /** Initialize the CDI. */
    private initCdi;
    /**
     * Process a bearing source change event.
     * @param index The index of the source to change (1-based).
     */
    private cycleBrgSrc;
    /**
     * Set the bearing source to the specified nav source index.
     * @param bearingSrcIndex The index of the bearing source to change (0-based).
     * @param navSrcIndex The index of the nav source to change to (0-based).
     */
    private setBrgSrc;
    /**
     * Handle HEvents
     * @param event The hEvent name
     */
    private eventHandler;
    /**
     * Handle a course inc event if we have a nav radio as our active CDI source.
     */
    private handleCrsInc;
    /**
     * Handle a course dec event if we have a nav radio as our active CDI source.
     */
    private handleCrsDec;
    /**
     * Handle a course sync event if we have a nav radio as our active CDI source.
     */
    private handleCrsSync;
    /**
     * Handle a bearing validity change.
     * @param valid The new bearing validity
     * @param source The source of
     */
    private onBrgValidity;
    /**
     * Handle a bearing distance change.
     * @param distance The distance to the source.
     * @param source The nav source ID.
     */
    private onBrgDistance;
    /**
     * Handle a bearing direction change.
     * @param direction The distance to the source.
     * @param source The nav source ID.
     */
    private onBrgDirection;
    /**
     * Handle a bearing ident change.
     * @param ident The ident of the source.
     * @param source The nav source ID.
     */
    private onBrgIdent;
    /**
     * Handle a localizer course change.
     * @param course The localizer course of the source.
     * @param source The nav source ID.
     */
    private onLocalizerCourse;
    /**
     * Handle a glideslope deviation change.
     * @param deviation The glideslope deviation of the source.
     * @param source The nav source ID.
     */
    private onGlideslopeDeviation;
    /**
     * Handle a glideslope angle change.
     * @param angle The glideslope angle of the source.
     * @param source The nav source ID.
     */
    private onGlideslopeAngle;
    /**
     * Determine whether a set frequency is a localizer frequency.
     * @param frequency The frequency to evaluate.
     * @returns a bool true if the frequency is a loc freq.
     */
    private frequencyIsLocalizer;
    /**
     * Publishers whether a set frequency is a localizer frequency.
     * @param isLoc whether the freq is a loc.
     * @param source the selected nav source.
     */
    private onIsLocalizerFrequency;
    /**
     * Publishers dme distance info.  This should be replaced by a generalization of
     * BearingDistance that provides the distance to any nav source if it has DME.
     * @param hasDme whether the radio has dme.
     * @param distance is the dme distance.
     * @param source the selected nav source.
     */
    private onDme;
    /**
     * Toggles CDI between GPS and NAV1.
     */
    private onCdiGpsToggle;
    /**
     * Gets the index of the first nav source of the given type.
     * @param type The type of nav source to find.
     * @returns The nav source index.
     */
    private getFirstNavSourceIndexByType;
    /**
     * Perform events for the update loop.
     */
    onUpdate(): void;
}

/**
 * Events related to the active navigation radio.
 */
interface NavRadioEvents {
    /** The location of the tuned glideslope on the active nav radio. */
    nav_radio_active_gs_location: LatLongAlt;
    /** The location of the tuned station on the active nav radio. */
    nav_radio_active_nav_location: LatLongAlt;
    /** Localizer data for the active nav radio. */
    nav_radio_active_localizer: Localizer;
    /** Glideslope data for the active nav radio. */
    nav_radio_active_glideslope: Glideslope;
    /** The obs setting of the current nav radio. */
    nav_radio_active_obs_setting: ObsSetting;
    /** The CDI deviation of the current nav radio. */
    nav_radio_active_cdi_deviation: CdiDeviation;
    /** The magnetic variation, in degrees, of the tuned station on the active nav radio. */
    nav_radio_active_magvar: number;
    /** The Nav1 Localizer. */
    nav_radio_localizer_1: Localizer;
    /** The Nav2 Localizer. */
    nav_radio_localizer_2: Localizer;
    /** The Nav3 Localizer. */
    nav_radio_localizer_3: Localizer;
    /** The Nav4 Localizer. */
    nav_radio_localizer_4: Localizer;
    /** The Nav1 CdiDeviation. */
    nav_radio_cdi_1: CdiDeviation;
    /** The Nav2 CdiDeviation. */
    nav_radio_cdi_2: CdiDeviation;
    /** The Nav3 CdiDeviation. */
    nav_radio_cdi_3: CdiDeviation;
    /** The Nav4 CdiDeviation. */
    nav_radio_cdi_4: CdiDeviation;
    /** The Nav1 obs setting. */
    nav_radio_obs_1: ObsSetting;
    /** The Nav2 obs setting. */
    nav_radio_obs_2: ObsSetting;
    /** The Nav3 obs setting. */
    nav_radio_obs_3: ObsSetting;
    /** The Nav4 obs setting. */
    nav_radio_obs_4: ObsSetting;
    /** The Nav1 tuned station location. */
    nav_radio_nav_location_1: LatLongAlt;
    /** The Nav2 tuned station location. */
    nav_radio_nav_location_2: LatLongAlt;
    /** The Nav3 tuned station location. */
    nav_radio_nav_location_3: LatLongAlt;
    /** The Nav4 tuned station location. */
    nav_radio_nav_location_4: LatLongAlt;
    /** The Nav1 station declination (difference between true north and 0 radial). */
    nav_radio_magvar_1: number;
    /** The Nav2 station declination (difference between true north and 0 radial). */
    nav_radio_magvar_2: number;
    /** The Nav3 station declination (difference between true north and 0 radial). */
    nav_radio_magvar_3: number;
    /** The Nav4 station declination (difference between true north and 0 radial). */
    nav_radio_magvar_4: number;
    /** The Nav1 Glideslope. */
    nav_radio_glideslope_1: Glideslope;
    /** The Nav2 Glideslope. */
    nav_radio_glideslope_2: Glideslope;
    /** The Nav3 Glideslope. */
    nav_radio_glideslope_3: Glideslope;
    /** The Nav4 Glideslope. */
    nav_radio_glideslope_4: Glideslope;
    /** The Nav1 tuned GS location. */
    nav_radio_gs_location_1: LatLongAlt;
    /** The Nav2 tuned GS location. */
    nav_radio_gs_location_2: LatLongAlt;
    /** The Nav3 tuned GS location. */
    nav_radio_gs_location_3: LatLongAlt;
    /** The Nav4 tuned GS location. */
    nav_radio_gs_location_4: LatLongAlt;
}
/**
 * An instrument that gathers localizer and glideslope information for use by
 * the AP systems.
 */
declare class APRadioNavInstrument implements Instrument {
    private readonly bus;
    private readonly navRadioData;
    private readonly navProc;
    private readonly publisher;
    private currentCdiIndex;
    /**
     * Creates an instance of the APRadioNavInstrument.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus: EventBus);
    /** @inheritdoc */
    init(): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Sets a value in a nav radio glideslope.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    private setGlideslopeValue;
    /**
     * Sends the current glideslope's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    private setGlideslopePosition;
    /**
     * Sends the current nav's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    private setNavPosition;
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    private setLocalizerValue;
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    private setCDIValue;
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    private setOBSValue;
    /**
     * Sets the magnetic variation of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param magVar The magvar to set.
     */
    private setMagVar;
    /**
     * Creates an empty localizer data.
     * @param id The nav source ID.
     * @returns New empty localizer data.
     */
    private createEmptyLocalizer;
    /**
     * Creates an empty glideslope data.
     * @param id The nav source ID.
     * @returns New empty glideslope data.
     */
    private createEmptyGlideslope;
    /**
     * Creates an empty CDI data.
     * @param id The nav source ID.
     * @returns New empty CDI data.
     */
    private createEmptyCdi;
    /**
     * Creates an empty OBS data.
     * @param id The nav source ID.
     * @returns New empty OBS data.
     */
    private createEmptyObs;
}

/**
 * An interface that describes the possible Brake events.
 */
interface BrakeEvents {
    /** Brake position on the left side, in percentage */
    brake_position_left: number;
    /** Brake position on the right side, in percentage */
    brake_position_right: number;
    /** Raw Brake position on the left side, in percentage - excluding parking brake effects */
    brake_position_left_raw: number;
    /** Raw Brake position on the right side, in percentage - excluding parking brake effects */
    brake_position_right_raw: number;
    /** Left wheel rpm */
    left_wheel_rpm: number;
    /** Right wheel rpm */
    right_wheel_rpm: number;
    /** Whether parking brake is set */
    parking_brake_set: boolean;
}
/**
 * A publisher for Brake information.
 */
declare class BrakeSimvarPublisher extends SimVarPublisher<BrakeEvents> {
    /**
     * Create a BrakePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<BrakeEvents> | undefined);
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * Events related to the clock.
 */
interface ClockEvents {
    /** A UNIX timestamp corresponding to the real-world (operating system) time. */
    realTime: number;
    /** A UNIX timestamp corresponding to the simulation time. */
    simTime: number;
    /**
     * A UNIX timestamp corresponding to the simulation time, fired every sim frame
     * instead of on each Coherent animation frame. USE THIS EVENT SPARINGLY, as it
     * will impact performance and ignores the user set glass cockpit refresh setting.
     */
    simTimeHiFreq: number;
}
/**
 * A publisher of clock events.
 */
declare class ClockPublisher extends BasePublisher<ClockEvents> {
    /** @inheritdoc */
    startPublish(): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    private static absoluteTimeToUNIXTime;
}
/**
 * A clock which keeps track of real-world and sim time.
 */
declare class Clock {
    private publisher;
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus: EventBus);
    /**
     * Initializes this clock.
     */
    init(): void;
    /**
     * Updates this clock.
     */
    onUpdate(): void;
}

/**
 * Base events related to control surfaces.
 */
interface BaseControlSurfacesEvents {
    /** The handle index for flaps. */
    flaps_handle_index: number;
    /** The extension angle of the left trailing edge flaps, in degrees. */
    flaps_left_angle: number;
    /** The extension angle of the right trailing edge flaps, in degrees. */
    flaps_right_angle: number;
    /** The left trailing edge flaps, in percent. */
    flaps_left_percent: number;
    /** The right trailing edge flaps, in percent. */
    flaps_right_percent: number;
    /** The extension angle of the left slats, in degrees. */
    slats_left_angle: number;
    /** The extension angle of the right slats, in degrees. */
    slats_right_angle: number;
    /** The left slats, in percent. */
    slats_left_percent: number;
    /** The right slats, in percent. */
    slats_right_percent: number;
    /** The left spoilers angle, in percent. */
    spoilers_left_percent: number;
    /** The right spoilers angle, in percent. */
    spoilers_right_percent: number;
    /** The left spoilers but without the spoilerons angle, in percent */
    spoilers_without_spoilerons_left_percent: number;
    /** The elevator trim angle, in degrees. Positive values indicate nose-up trim. */
    elevator_trim_angle: number;
    /** The percent of applied elevator trim. */
    elevator_trim_pct: number;
    /** The neutral position in percent of the elevator trim. */
    elevator_trim_neutral_pct: number;
    /** The aileron trim angle, in degrees. Positive values indicate rightward trim. */
    aileron_trim_angle: number;
    /** The percent of applied aileron trim. */
    aileron_trim_pct: number;
    /** The rudder trim angle, in degrees. Positive values indicate rightward trim. */
    rudder_trim_angle: number;
    /** The percent of applied rudder trim. */
    rudder_trim_pct: number;
    /** The percent of left aileron deflection */
    aileron_left_percent: number;
    /** The percent of right aileron deflection */
    aileron_right_percent: number;
    /** The percent of elevator deflection */
    elevator_percent: number;
    /** The percent of rudder deflection */
    rudder_percent: number;
    /** Landing gear position. A value of `0` indicates fully retracted, and a value of `1` indicates fully extended. */
    gear_position: number;
    /** Whether landing gear is on the ground. */
    gear_is_on_ground: boolean;
}
/**
 * Topics indexed by landing gear.
 */
declare type LandingGearIndexedTopics = 'gear_position' | 'gear_is_on_ground';
/**
 * Topics related to control surfaces that are indexed.
 */
declare type ControlSurfacesIndexedTopics = LandingGearIndexedTopics;
/**
 * Indexed events related to control surfaces.
 */
declare type ControlSurfacesIndexedEvents = {
    [P in keyof Pick<BaseControlSurfacesEvents, ControlSurfacesIndexedTopics> as IndexedEventType<P>]: BaseControlSurfacesEvents[P];
};
/**
 * Events related to control surfaces.
 */
interface ControlSurfacesEvents extends BaseControlSurfacesEvents, ControlSurfacesIndexedEvents {
}
/**
 * A publisher for control surfaces information.
 */
declare class ControlSurfacesPublisher extends SimVarPublisher<ControlSurfacesEvents> {
    /**
     * Create an ControlSurfacesPublisher.
     * @param bus The EventBus to publish to.
     * @param gearCount The number of landing gear to support.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, gearCount: number, pacer?: PublishPacer<ControlSurfacesEvents>);
}

/**
 * Topics indexed by hydraulic pump.
 */
interface HydraulicsIndexedTopics {
    /** The switch state of the hydraulic pump.  */
    hyd_pump_switch_state: boolean;
    /** The reservoir quantity in percent. */
    hyd_reservoir_perc: number;
    /** The hydraulic pressure of this pump */
    hyd_pressure: number;
}
/**
 * Indexed events related to the hydraulics.
 */
declare type HydraulicsIndexedEvents = {
    [P in keyof HydraulicsIndexedTopics as IndexedEventType<P>]: HydraulicsIndexedTopics[P];
};
/**
 * Events related to the planes hydraulics.
 */
declare type HydraulicsEvents = HydraulicsIndexedEvents;
/**
 * A publisher for control surfaces information.
 */
declare class HydraulicsPublisher extends SimVarPublisher<HydraulicsEvents> {
    /**
     * Create an HydraulicsPublisher.
     * @param bus The EventBus to publish to.
     * @param pumpsCount The number of hydraulic pumps.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, pumpsCount: number, pacer?: PublishPacer<HydraulicsEvents>);
}

/**
 * Events relating to the electrical systems.
 */
interface ElectricalEvents {
    /** Master battery power is switched on or not. */
    'elec_master_battery': boolean;
    /** The avionics circuit is on or off. */
    [elec_circuit_avionics_on: IndexedEventType<'elec_circuit_avionics_on'>]: boolean;
    /** The navcom 1 circuit is on or off. */
    'elec_circuit_navcom1_on': boolean;
    /** The navcom 2 circuit is on of off. */
    'elec_circuit_navcom2_on': boolean;
    /** The navcom 3 circuit is on of off. */
    'elec_circuit_navcom3_on': boolean;
    /** The first avionics power bus. */
    'elec_av1_bus': boolean;
    /** The second avionics power bus. */
    'elec_av2_bus': boolean;
    /** A voltage value for the main elec bus */
    'elec_bus_main_v': number;
    /** A current value for the main elec bus */
    'elec_bus_main_a': number;
    /** A voltage value for the avionics bus */
    'elec_bus_avionics_v': number;
    /** A current value for the avinoics bus */
    'elec_bus_avionics_a': number;
    /** A voltage value for the generator/alternator 1 bus */
    'elec_bus_genalt_1_v': number;
    /** A voltage value for the generator/alternator 2 bus */
    'elec_bus_genalt_2_v': number;
    /** A current value for the generator/alternator 1 bus */
    'elec_bus_genalt_1_a': number;
    /** A current value for the generator/alternator 2 bus */
    'elec_bus_genalt_2_a': number;
    /** A voltage value for the battery */
    [elec_bat_v: IndexedEventType<'elec_bat_v'>]: number;
    /** A current value for the battery */
    [elec_bat_a: IndexedEventType<'elec_bat_a'>]: number;
}
/**
 * A publisher for electrical information.
 */
declare class ElectricalPublisher extends SimVarPublisher<ElectricalEvents> {
    private static simvars;
    private flightStarted;
    private av1BusLogic;
    private av2BusLogic;
    private avBusList;
    /**
     * Create an ElectricalPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<ElectricalEvents> | undefined);
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Sets the logic element to use for the avionics 1 bus.
     * @param logicElement The logic element to use.
     */
    setAv1Bus(logicElement: CompositeLogicXMLElement): void;
    /**
     * Sets the logic element to use for the avionics 2 bus.
     * @param logicElement The logic element to use.
     */
    setAv2Bus(logicElement: CompositeLogicXMLElement): void;
}

/**
 * An interface that describes the possible Engine Parameter events (non-indexed).
 */
interface BaseEngineEvents {
    /** A pressure value for vacuum system */
    vac: number;
    /** Total fuel flow rate, in gallons per hour. */
    fuel_flow_total: number;
    /** The amount of fuel remaining (usable + unusable) in all tanks, in gallons. */
    fuel_total: number;
    /** The amount of fuel remaining (usable + unusable)in all tanks, in pounds. */
    fuel_total_weight: number;
    /** The usable amount of fuel remaining in all tanks, in gallons. */
    fuel_usable_total: number;
    /** The usable amount of fuel remaining in all tanks, in pounds. */
    fuel_usable_total_weight: number;
    /** The amount of fuel remaining in all tanks on the left side, in gallons. */
    fuel_left: number;
    /** The amount of fuel remaining in all tanks on the right side, in gallons. */
    fuel_right: number;
    /** The amount of fuel remaining in the left main tank, in gallons. */
    fuel_left_main: number;
    /** The amount of fuel remaining in the left main tank, as a percent of maximum capacity. */
    fuel_left_main_pct: number;
    /** The amount of fuel remaining in the right main tank, in gallons. */
    fuel_right_main: number;
    /** The amount of fuel remaining in the right main tank, as a percent of maximum capacity. */
    fuel_right_main_pct: number;
    /** The amount of fuel remaining in the center tank, in gallons. */
    fuel_center: number;
    /** The fuel weight per gallon, in pounds per gallon. */
    fuel_weight_per_gallon: number;
    /** The state of fuel tank selector 1. */
    fuel_tank_selector_state_1: number;
    /** The state of fuel tank selector 2. */
    fuel_tank_selector_state_2: number;
    /** The state of fuel tank selector 3. */
    fuel_tank_selector_state_3: number;
    /** The state of fuel tank selector 4. */
    fuel_tank_selector_state_4: number;
    /** A hours value for engine 1 total elapsed time. */
    eng_hours_1: number;
    /** The APU rpm in %. */
    apu_pct: number;
}
/**
 * Topics indexed by engine.
 */
interface EngineIndexedTopics {
    /** The engine rpm. */
    rpm: number;
    /** The propeller rpm. */
    prop_rpm: number;
    /** The engine n1 in %. */
    n1: number;
    /** The engine n2 in %. */
    n2: number;
    /** The engine torque in %. */
    torque: number;
    /** The engine fuel flow, in gallons per hour. */
    fuel_flow: number;
    /** The engine fuel flow, in pounds per hour. */
    fuel_flow_pph: number;
    /** The recip engine fuel flow . */
    recip_ff: number;
    /** The engine oil pressure, in pounds per square inch. */
    oil_press: number;
    /** The engine oil temperature, in degrees Fahrenheit. */
    oil_temp: number;
    /** The engine itt. */
    itt: number;
    /** The engine exhaust gas temperature. */
    egt: number;
    /** The engine hydraulic pressure, in pounds per square inch. */
    eng_hyd_press: number;
    /** Whether the engine starter is on. */
    eng_starter_on: boolean;
    /** Whether the engine is combusting. */
    eng_combustion: boolean;
    /** The engine ignition switch state. 0: Off, 1: Auto, 2: On. */
    eng_ignition_switch_state: 0 | 1 | 2;
    /** Whether the engine is igniting. */
    eng_igniting: boolean;
    /** Whether the engine fuel pump is on. */
    eng_fuel_pump_on: boolean;
    /** The engine fuel pump switch state. 0: Off, 1: On, 2: Auto. */
    eng_fuel_pump_switch_state: 0 | 1 | 2;
    /** The Engine Vibration */
    eng_vibration: number;
    /** The Engine fuel flow switch */
    eng_fuel_flow_switch: boolean;
}
/**
 * Indexed events related to the engines.
 */
declare type EngineIndexedEvents = {
    [P in keyof EngineIndexedTopics as IndexedEventType<P>]: EngineIndexedTopics[P];
};
/**
 * Events related to the planes engines.
 */
declare type EngineEvents = BaseEngineEvents & EngineIndexedEvents;
/**
 * A publisher for Engine information.
 */
declare class EISPublisher extends SimVarPublisher<EngineEvents> {
    private readonly engineCount;
    /**
     * Create an EISPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<EngineEvents> | undefined);
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * An interface that describes the possible Weight and Balance events.
 */
interface WeightBalanceEvents {
    /** A total weight value for the aircraft, in pounds. */
    total_weight: number;
}
/**
 * A publisher for Engine information.
 */
declare class WeightBalanceSimvarPublisher extends SimVarPublisher<WeightBalanceEvents> {
    /**
     * Create a WeightAndBalancePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<WeightBalanceEvents> | undefined);
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * Flight timer modes.
 */
declare enum FlightTimerMode {
    CountingDown = 0,
    CountingUp = 1
}
/**
 * Events related to flight timers.
 */
declare type FlightTimerEvents = {
    /** Active timer mode. */
    [timer_mode: IndexedEventType<'timer_mode'>]: FlightTimerMode;
    /** Whether a timer is running. */
    [timer_is_running: IndexedEventType<'timer_is_running'>]: boolean;
    /** Initial timer value, in milliseconds. */
    [timer_initial_value_ms: IndexedEventType<'timer_initial_value_ms'>]: number;
    /** Current timer value, in milliseconds. */
    [timer_value_ms: IndexedEventType<'timer_value_ms'>]: number;
};
/**
 * Events used to control flight timers.
 */
declare type FlightTimerControlEvents = {
    /** Sets the active timer mode. */
    [timer_set_mode: IndexedEventType<'timer_set_mode'>]: FlightTimerMode;
    /** Sets the initial timer value, in milliseconds. */
    [timer_set_initial_value: IndexedEventType<'timer_set_initial_value'>]: number;
    /** Sets the current timer value, in milliseconds. */
    [timer_set_value: IndexedEventType<'timer_set_value'>]: number;
    /** Starts the timer. */
    [timer_start: IndexedEventType<'timer_start'>]: void;
    /** Stops the timer. */
    [timer_stop: IndexedEventType<'timer_stop'>]: void;
    /** Resets the current timer value to the initial value. */
    [timer_reset: IndexedEventType<'timer_reset'>]: void;
};
/**
 * A publisher for flight timer information.
 */
declare class FlightTimerPublisher extends SimVarPublisher<FlightTimerEvents> {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, timerCount: number, pacer?: PublishPacer<FlightTimerEvents>);
}
/**
 * An instrument which manages zero or more flight timers. Requires the topics defined in {@link ClockEvents} to be
 * actively published to the event bus in order to function properly. All timers operate using simulation time and are
 * updated every instrument update cycle with up to millisecond precision.
 */
declare class FlightTimerInstrument implements Instrument {
    private readonly bus;
    private readonly timerCount;
    private readonly timers;
    private readonly simTime;
    private lastUpdateSimTime;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     */
    constructor(bus: EventBus, timerCount: number);
    /** @inheritdoc */
    init(): void;
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * An interface that describes GNSS event bus events.
 */
interface GNSSEvents {
    /** A GNSS location change event. */
    ['gps-position']: LatLongAlt;
    /** The current zulu time change event. */
    zulu_time: number;
    /** The current time of day change event. */
    time_of_day: number;
    /** The plane ground track, in degrees true north. */
    track_deg_true: number;
    /** The plane ground track, in degrees magnetic north. */
    track_deg_magnetic: number;
    /** The plane ground speed, in knots. */
    ground_speed: number;
    /** The current magnetic variation at the plane position. */
    magvar: number;
}
/**
 * A publisher for basic GNSS information.
 */
declare class GNSSPublisher extends BasePublisher<GNSSEvents> {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<GNSSEvents> | undefined);
    /**
     * A callback called when the publisher updates.
     */
    onUpdate(): void;
    /**
     * Publishes the gps-position event.
     */
    private publishPosition;
    /**
     * Publishes the zulu_time and time_of_day events.
     */
    private publishTime;
    /**
     * Publishes the track_deg_true and track_deg_magnetic events.
     */
    private publishTrack;
    /**
     * Publishes the ground_speed event.
     */
    private publishGroundSpeed;
    /**
     * Publishes the ground_speed event.
     */
    private publishMagVar;
}

/**
 * An abstract implementation of a subscribable which allows adding, removing, and notifying subscribers.
 */
declare abstract class AbstractSubscribable<T> implements Subscribable<T> {
    readonly isSubscribable = true;
    /**
     * Checks if two values are equal using the strict equality operator.
     * @param a The first value.
     * @param b The second value.
     * @returns whether a and b are equal.
     */
    static readonly DEFAULT_EQUALITY_FUNC: (a: any, b: any) => boolean;
    protected subs: HandlerSubscription<(v: T) => void>[];
    protected notifyDepth: number;
    /** A function which sends initial notifications to subscriptions. */
    protected readonly initialNotifyFunc: (sub: HandlerSubscription<(v: T) => void>) => void;
    /** A function which responds to when a subscription to this subscribable is destroyed. */
    protected readonly onSubDestroyedFunc: (sub: HandlerSubscription<(v: T) => void>) => void;
    /** @inheritdoc */
    abstract get(): T;
    /** @inheritdoc */
    sub(handler: (v: T) => void, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: (v: T) => void): void;
    /**
     * Notifies subscriptions that this subscribable's value has changed.
     */
    protected notify(): void;
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    protected notifySubscription(sub: HandlerSubscription<(v: T) => void>): void;
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    protected onSubDestroyed(sub: HandlerSubscription<(v: T) => void>): void;
    /**
     * Maps this subscribable to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubscribable<M>;
    /**
     * Maps this subscribable to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubscribable<M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this subscribable's state and pipes a mapped version to a mutable subscribable. Whenever an update
     * of this subscribable's state is received through the subscription, it will be transformed by the specified mapping
     * function, and the transformed state will be used as an input to change the other subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (fromVal: T, toVal: M) => M, paused?: boolean): Subscription;
}

/**
 * A Subject which allows a 2D vector to be observed.
 */
declare class Vec2Subject extends AbstractSubscribable<ReadonlyFloat64Array> implements MutableSubscribable<ReadonlyFloat64Array, Readonly<ArrayLike<number>>> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static create(initialVal: Float64Array): Vec2Subject;
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     * @deprecated Use `Vec2Subject.create()` instead.
     */
    static createFromVector(initialVal: Float64Array): Vec2Subject;
    /** @inheritdoc */
    get(): ReadonlyFloat64Array;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: Readonly<ArrayLike<number>>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param x The x component of the new value.
     * @param y The y component of the new value.
     */
    set(x: number, y: number): void;
}
/**
 * A Subject which allows a 3D vector to be observed.
 */
declare class Vec3Subject extends AbstractSubscribable<ReadonlyFloat64Array> implements MutableSubscribable<ReadonlyFloat64Array, Readonly<ArrayLike<number>>> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     */
    static create(initialVal: Float64Array): Vec3Subject;
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     * @deprecated Use `Vec3Subject.create()` instead.
     */
    static createFromVector(initialVal: Float64Array): Vec3Subject;
    /** @inheritdoc */
    get(): ReadonlyFloat64Array;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: Readonly<ArrayLike<number>>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param x The x component of the new value.
     * @param y The y component of the new value.
     */
    set(x: number, y: number, z: number): void;
}
/**
 * A Subject which allows a N-D vector to be observed.
 */
declare class VecNSubject extends AbstractSubscribable<ReadonlyFloat64Array> implements MutableSubscribable<ReadonlyFloat64Array, Readonly<ArrayLike<number>>> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     */
    static create(initialVal: Float64Array): VecNSubject;
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     * @deprecated Use `VecNSubject.create()` instead.
     */
    static createFromVector(initialVal: Float64Array): VecNSubject;
    /** @inheritdoc */
    get(): ReadonlyFloat64Array;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     * @throws Error if the length of `value` is greater than the length of this subject's value.
     */
    set(value: Readonly<ArrayLike<number>>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param args The individual components of the new value.
     * @throws Error if the number of components of the new value is greater than the length of this subject's value.
     */
    set(...args: number[]): void;
}

/** Extracts the type argument from a Subject. */
declare type ExtractSubjectType<P> = P extends Subject<infer T> ? T : never;
/** Generates an indexed type with all the Subjects extracted. */
declare type ExtractSubjectTypes<P extends {
    [key: string]: Subject<any>;
}> = {
    [Key in keyof P]: ExtractSubjectType<P[Key]>;
};
/**
 * A subscribable subject whose value can be freely manipulated.
 */
declare class Subject<T> extends AbstractSubscribable<T> implements MutableSubscribable<T> {
    protected value: T;
    protected readonly equalityFunc: (a: T, b: T) => boolean;
    protected readonly mutateFunc?: ((oldVal: T, newVal: T) => void) | undefined;
    readonly isMutableSubscribable = true;
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    protected constructor(value: T, equalityFunc: (a: T, b: T) => boolean, mutateFunc?: ((oldVal: T, newVal: T) => void) | undefined);
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
     * equality comparison (`===`).
     * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create<IT>(v: IT, equalityFunc?: (a: IT, b: IT) => boolean, mutateFunc?: (oldVal: IT, newVal: IT) => void): Subject<IT>;
    /** @inheritdoc */
    protected notifySub(sub: (v: T) => void): void;
    /**
     * Sets the value of this subject and notifies subscribers if the value changed.
     * @param value The new value.
     */
    set(value: T): void;
    /**
     * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
     * result.
     * @param value The properties to apply.
     */
    apply(value: Partial<T>): void;
    /** @inheritdoc */
    notify(): void;
    /**
     * Gets the value of this subject.
     * @returns The value of this subject.
     */
    get(): T;
}

/**
 * SBAS group names.
 */
declare enum SBASGroupName {
    /** Wide Area Augmentation System (USA). */
    WAAS = "WAAS",
    /** European Geostationary Navigation Overlay Service (EU). */
    EGNOS = "EGNOS",
    /** GPS Aided Geo Augmented Navigation System (India). */
    GAGAN = "GAGAN",
    /** Multi-functional Satellite Augmentation System (Japan). */
    MSAS = "MSAS"
}
/**
 * Events published by the GPSSatComputer system.
 */
interface GPSSatComputerEvents {
    /** An event published when a GPS satellite changes state. */
    [gps_sat_state_changed: IndexedEventType<'gps_sat_state_changed'>]: GPSSatellite;
    /** An event published when the GPS satellite system changes state. */
    [gps_system_state_changed: IndexedEventType<'gps_system_state_changed'>]: GPSSystemState;
    /** An event published when the GPS satellite positions have been updated. */
    [gps_sat_pos_calculated: IndexedEventType<'gps_sat_pos_calculated'>]: void;
    /** An event published when the GPS system SBAS state changes. */
    [gps_system_sbas_state_changed: IndexedEventType<'gps_system_sbas_state_changed'>]: GPSSystemSBASState;
    /**
     * The current position dilution of precision (PDOP) calculated by the GPS system, or `-1` if this system has not
     * acquired a position solution.
     */
    [gps_system_pdop: IndexedEventType<'gps_system_pdop'>]: number;
    /**
     * The current horizontal dilution of precision (HDOP) calculated by the GPS system, or `-1` if this system has not
     * acquired a position solution.
     */
    [gps_system_hdop: IndexedEventType<'gps_system_hdop'>]: number;
    /**
     * The current horizontal dilution of precision (VDOP) calculated by the GPS system, or `-1` if this system has not
     * acquired a position solution.
     */
    [gps_system_vdop: IndexedEventType<'gps_system_vdop'>]: number;
}
/**
 * An instrument that computes GPS satellite information.
 */
declare class GPSSatComputer implements Instrument {
    readonly index: number;
    private readonly bus;
    private readonly ephemerisFile;
    private readonly sbasFile;
    private readonly updateInterval;
    readonly syncRole: 'primary' | 'replica' | 'none';
    private readonly publisher;
    private readonly syncPublisher;
    private readonly stateChangedTopic;
    private readonly satStateChangedTopic;
    private readonly satPosCalcTopic;
    private readonly sbasStateChangedTopic;
    private readonly pdopTopic;
    private readonly hdopTopic;
    private readonly vdopTopic;
    private readonly satCalcSyncTopic;
    private readonly satStateSyncTopic;
    private readonly resetSyncTopic;
    private readonly satStateRequestSyncTopic;
    private readonly satStateResponseSyncTopic;
    private ephemerisData;
    private sbasData;
    private readonly sbasServiceAreas;
    private readonly currentSbasGroupsInView;
    private readonly satellites;
    private readonly ppos;
    private readonly pposVec;
    private readonly vecHeap;
    private altitude;
    private previousSimTime;
    private previousUpdate;
    private simTime;
    private _state;
    private _sbasState;
    private readonly enabledSBASGroups;
    private readonly dops;
    private _pdop;
    private _hdop;
    private _vdop;
    private isInit;
    private needAcquireAndUse;
    private needSatCalc;
    private readonly pendingSatStateUpdates;
    /**
     * Gets the current GPS system state.
     * @returns The current GPS system state.
     */
    get state(): GPSSystemState;
    /**
     * Gets the current GPS system SBAS state.
     * @returns The current GPS system SBAS state.
     */
    get sbasState(): GPSSystemSBASState;
    /**
     * Gets this system's current position dilution of precision value (PDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current position dilution of precision value (PDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get pdop(): number;
    /**
     * Gets this system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get hdop(): number;
    /**
     * Gets this system's current vertical dilution of precision value (VDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current vertical dilution of precision value (VDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get vdop(): number;
    /**
     * Creates an instance of GPSSat.
     * @param index The index of this GPSSat.
     * @param bus An instance of the event bus.
     * @param ephemerisFile The HTTP path to the ephemeris file to use for computations.
     * @param sbasFile The HTTP path to the SBAS definitions file.
     * @param updateInterval The interval in milliseconds to update the satellite positions.
     * @param enabledSBASGroups The names of the SBAS satellite groups for which signal reception is enabled.
     * @param syncRole This system's sync role. A `primary` system will broadcast sync events through the event bus when
     * satellite positions are calculated, satellite states change, or the system is reset. A `replica` system will
     * listen for the aforementioned sync events on the event bus and set its state accordingly. A system with a sync
     * role of `none` does neither; it maintains its own independent state and does not sync it to other systems.
     */
    constructor(index: number, bus: EventBus, ephemerisFile: string, sbasFile: string, updateInterval: number, enabledSBASGroups: Iterable<string> | SubscribableSet<string>, syncRole?: 'primary' | 'replica' | 'none');
    /**
     * Adds the defined SBAS satellites to the tracked satellites.
     */
    private addSbasSatellites;
    /** @inheritdoc */
    init(): void;
    /**
     * Loads the GPS ephemeris data file.
     */
    private loadEphemerisData;
    /**
     * Loads the GPS SBAS data file.
     */
    private loadSbasData;
    /**
     * Instantly acquires and starts using all satellites with sufficient signal strength. If signal strength allows,
     * SBAS satellites are instantly promoted to the {@link GPSSatelliteState.Acquired} state, and GPS satellites are
     * instantly promoted to the {@link GPSSatelliteState.InUse}/{@link GPSSatelliteState.InUseDiffApplied} state.
     *
     * If this system is not initialized, the operation will be delayed until just after initialization, unless `reset()`
     * is called between now and then.
     *
     * Has no effect if this system is a replica.
     */
    acquireAndUseSatellites(): void;
    /**
     * Resets the GPSSatComputer system. This will set the of the system to {@link GPSSystemState.Searching} and the
     * state of every satellite to {@link GPSSatelliteState.None}.
     *
     * If this system is not initialized, this method has no effect other than to cancel any pending operations triggered
     * by previous calls to `acquireAndUseSatellites()`.
     */
    reset(): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Updates the states and optionally the orbital positions of all satellites.
     * @param deltaTime The time elapsed, in milliseconds, since the last satellite update.
     * @param shouldUpdatePositions Whether to update the orbital positions of the satellites.
     * @param forceAcquireAndUse Whether to immediately force satellites to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} for SBAS satellites and {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} for GPS satellites) if signal strength is sufficient.
     */
    private updateSatellites;
    /**
     * Gets the current satellites that are being tracked by this computer.
     * @returns The collection of current satellites.
     */
    get sats(): readonly GPSSatellite[];
    /**
     * Calculates the horizon zenith angle.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    calcHorizonAngle(): number;
    /**
     * Calculates dilution of precision values (PDOP, HDOP, VDOP) for the current satellite constellation.
     * @param out The vector to which to write the results.
     * @returns Dilution of precision values for the current satellite constellation, as `[PDOP, HDOP, VDOP]`.
     */
    private calculateDop;
    /**
     * Sets this system's dilution of precision values, and if they are different from the current values, publishes the
     * new values to the event bus.
     * @param pdop The position DOP value to set.
     * @param hdop The horizontal DOP value to set.
     * @param vdop The vertical DOP valu to set.
     */
    private setDop;
}
/**
 * The GPS ephemeris data epoch.
 */
interface GPSEpoch {
    /** The epoch year. */
    year: number;
    /** The epoch month. */
    month: number;
    /** The epoch day. */
    day: number;
    /** The epoch hour. */
    hour: number;
    /** The epoch minute. */
    minute: number;
    /** The epoch second. */
    second: number;
}
/**
 * Data about the GPS satellite clock.
 */
interface GPSSVClock {
    /** The current clock bias. */
    bias: number;
    /** The current amount of clock drift. */
    drift: number;
    /** The current rate of clock drift. */
    driftRate: number;
}
/**
 * A GPS ephemeris data record.
 */
interface GPSEphemeris {
    /** The GPS epoch for this ephemeris record. */
    epoch: GPSEpoch;
    /** The GPS satellite clock metadata at the time of the record. */
    svClock: GPSSVClock;
    /** IODE Issue of Data, Ephemeris */
    iodeIssueEphemeris: number;
    /** Crs */
    crs: number;
    /** Delta N */
    deltaN: number;
    /** M0 */
    m0: number;
    /** Cuc */
    cuc: number;
    /** e */
    eEccentricity: number;
    /** Cus */
    cus: number;
    /** Square root of A */
    sqrtA: number;
    /** toe */
    toeTimeEphemeris: number;
    /** Cic */
    cic: number;
    /** OMEGA */
    omegaL: number;
    /** Cis */
    cis: number;
    /** i0 */
    i0: number;
    /** Crc */
    crc: number;
    /** omega */
    omegaS: number;
    /** OMEGA dot */
    omegaLDot: number;
    /** IDOT */
    idot: number;
    /** Codes on the GPS L2 channel */
    codesOnL2Channel: number;
    /** The GPS week number */
    gpsWeekNumber: number;
    /** LP2 Data flag */
    l2PDataFlag: number;
    /** Accuracy metadata */
    svAccuracy: number;
    /** Health metadata */
    svHealth: number;
    /** tgd */
    tgd: number;
    /** IODE Issue of Data, Clock */
    iodeIssueClock: number;
    /** Transmission time of the ephemeris message */
    transmissionTimeOfMessage: number;
}
/**
 * A collection of GPS ephemeris records.
 */
interface GPSEphemerisRecords {
    [index: string]: GPSEphemeris;
}
/**
 * A tracked GPS satellite.
 */
declare class GPSSatellite {
    readonly prn: number;
    readonly sbasGroup?: string | undefined;
    private readonly ephemeris?;
    private readonly stateChangeTime;
    private stateChangeTimeRemaining;
    private readonly vec3Cache;
    /** The current satellite state. */
    readonly state: Subject<GPSSatelliteState>;
    /** The current satellite position, in zenith angle radians and hour angle radians. */
    readonly position: Vec2Subject;
    /** The current satellite position, in cartesian coordinates. */
    readonly positionCartesian: Vec3Subject;
    /** The current satellite signal strength. */
    readonly signalStrength: Subject<number>;
    private isApplyingDiffCorrections;
    private hasComputedPosition;
    /**
     * Creates an instance of a GPSSatellite.
     * @param prn The GPS PRN number for this satellite.
     * @param sbasGroup Whether or not this satellite is a SBAS satellite.
     * @param ephemeris The ephemeris data to use for position calculation.
     */
    constructor(prn: number, sbasGroup?: string | undefined, ephemeris?: GPSEphemeris | undefined);
    /**
     * Computes the current satellite positions given the loaded ephemeris data.
     * @param simTime The current simulator time, in milliseconds UNIX epoch
     */
    computeSatellitePositions(simTime: number): void;
    /**
     * Applies a projection to the satellite cartesian coordinates to convert to zenith and hour angles.
     * @param ppos The current plane position.
     * @param altitude The current plane altitude in meters.
     */
    applyProjection(ppos: GeoPoint, altitude: number): void;
    /**
     * Calculates the current signal strength.
     * @param altitude The current plane altitude in meters.
     */
    calculateSignalStrength(altitude: number): void;
    /**
     * Calculates the horizon zenith angle.
     * @param altitude The altitude, in meters.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    static calcHorizonAngle(altitude: number): number;
    /**
     * Updates the state of the satellite.
     * @param deltaTime The amount of sim time that has passed, in milliseconds.
     * @param applyDiffCorrections Whether or not to apply differential corrections to this GPS satellite.
     * @param forceAcquireAndUse Whether to force this satellite to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} if this is an SBAS satellite or {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} if this is a GPS satellite) if signal strength is sufficient.
     * @returns True if the satellite state changed, false otherwise.
     */
    updateState(deltaTime: number, applyDiffCorrections: boolean, forceAcquireAndUse: boolean): boolean;
    /**
     * Forces an update of this satellite's state to a specific value.
     * @param state The state to which to update this satellite.
     * @returns Whether the satellite's state was changed as a result of the forced update.
     */
    forceUpdateState(state: GPSSatelliteState): boolean;
}
/**
 * Possible state on GPS satellites.
 */
declare enum GPSSatelliteState {
    /** There is no current valid state. */
    None = "None",
    /** The satellite is out of view and cannot be reached. */
    Unreachable = "Unreachable",
    /** The satellite has been found and data is being downloaded. */
    Acquired = "Acquired",
    /** The satellite is faulty. */
    Faulty = "Faulty",
    /** The satellite has been found, data is downloaded, but is not presently used in the GPS solution. */
    DataCollected = "DataCollected",
    /** The satellite is being active used in the GPS solution. */
    InUse = "InUse",
    /** The satellite is being active used in the GPS solution and SBAS differential corrections are being applied. */
    InUseDiffApplied = "InUseDiffApplied"
}
/**
 * Possible {@link GPSSatComputer} states.
 */
declare enum GPSSystemState {
    /** The GPS receiver is trying to locate satellites. */
    Searching = "Searching",
    /** The GPS receiver has found satellites and is acquiring a solution. */
    Acquiring = "Acquiring",
    /** A 3D solution has been acquired. */
    SolutionAcquired = "SolutionAcquired",
    /** A 3D solution using differential computations has been acquired. */
    DiffSolutionAcquired = "DiffSolutionAcquired"
}
/**
 * Possible SBAS connection states.
 */
declare enum GPSSystemSBASState {
    /** SBAS is disabled. */
    Disabled = "Disabled",
    /** SBAS is enabled but not receiving differential corrections. */
    Inactive = "Inactive",
    /** SBAS is enabled and is receiving differential corrections. */
    Active = "Active"
}

/**
 * An event fired when the screen state changes.
 */
interface ScreenStateEvent {
    /** The current screen state. */
    current: ScreenState;
    /** The previous screen state. */
    previous: ScreenState | undefined;
}
/**
 * Events from the VCockpit BaseInstrument framework.
 */
interface InstrumentEvents {
    /** An event fired when the instrument is powered on or off. */
    'vc_powered': boolean;
    /** An event fired when the screen state changes. */
    'vc_screen_state': ScreenStateEvent;
    /** An event fired when the game state changes. */
    'vc_game_state': GameState;
    /** An event fired when the flight is started. */
    'vc_flight_start': boolean;
    /** An event fired when the mouse leaves the instrument. */
    'vc_mouse_leave': MouseEvent;
    /** An event fired when the mouse enters the instrument. */
    'vc_mouse_enter': MouseEvent;
}
/**
 * A publisher for VCockpit BaseInstrument events.
 */
declare class BaseInstrumentPublisher extends BasePublisher<InstrumentEvents> {
    private readonly instrument;
    private lastGameState;
    private lastIsPowered;
    private lastScreenState;
    private hasFlightStarted;
    /**
     * Creates an instance of BasePublisher.
     * @param instrument The BaseInstrument instance.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(instrument: BaseInstrument, bus: EventBus, pacer?: PublishPacer<InstrumentEvents> | undefined);
    /** @inheritdoc */
    startPublish(): void;
    /** @inheritdoc */
    stopPublish(): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Updates this publisher from the current game state.
     * @param gameState The current game state.
     */
    private updateFromGameState;
    /**
     * Updates this publisher from the current powered state.
     * @param isPowered The current powered state.
     */
    private updateFromPowered;
    /**
     * Updates this publisher from the current screen state.
     * @param screenState The current screen state.
     */
    private updateFromScreenState;
}

/** Minimums Modes */
declare enum MinimumsMode {
    OFF = 0,
    BARO = 1,
    RA = 2,
    TEMP_COMP_BARO = 3
}
/** Events sourced from minimums-related simvars. */
interface MinimumsSimVarEvents {
    /** The current decision height in feet. */
    decision_height_feet: number;
    /** The current decision altitude in feet. */
    decision_altitude_feet: number;
    /** The current selected minimums mode. */
    minimums_mode: MinimumsMode;
}
/** Events for setting Minimums values */
interface MinimumsControlEvents {
    /** Set a new decision height in feet. */
    set_decision_height_feet: number;
    /** Set a new decision altitude in feet. */
    set_decision_altitude_feet: number;
    /** Set the decision height unit to manage increments. */
    set_dh_distance_unit: 'feet' | 'meters';
    /** Set the decision altitude unit to manage increments. */
    set_da_distance_unit: 'feet' | 'meters';
    /** Set the current selected minimums mode. */
    set_minimums_mode: MinimumsMode;
}
/** A common type for all minimums events. */
declare type MinimumsEvents = MinimumsSimVarEvents & MinimumsControlEvents;
/** A publisher for minimums simvar events. */
declare class MinimumsSimVarPublisher extends SimVarPublisher<MinimumsSimVarEvents> {
    private static simvars;
    /**
     * @inheritdoc
     */
    constructor(bus: EventBus);
}
/**
 * A class that manages decision height and altitude data and events.
 */
declare class MinimumsManager {
    private bus;
    private controlSubscriber;
    private currentDH;
    private currentDA;
    private daDistanceUnit;
    private dhDistanceUnit;
    /**
     * Create a MinimumsManager
     * @param bus The event bus
     */
    constructor(bus: EventBus);
}

/**
 * Nav radio tuning event roots.
 */
declare type NavRadioTuneEventsRoot = {
    /** Nav radio active frequency, in megahertz. */
    nav_active_frequency: number;
    /** Nav radio standby frequency, in megahertz. */
    nav_standby_frequency: number;
    /** Nav radio ident string. */
    nav_ident: string;
    /** Nav radio signal strength, in arbitrary units. A value of `0` indicates no signal. */
    nav_signal: number;
    /** Whether nav radio audio monitoring is enabled. */
    nav_sound: boolean;
    /** Nav radio volume, as a percentage (0-100). */
    nav_volume: number;
};
/**
 * Tuning events for an indexed nav radio.
 */
declare type NavRadioTuneEventsIndexed<Index extends NavRadioIndex> = {
    [Event in keyof NavRadioTuneEventsRoot as `${Event}_${Index}`]: NavRadioTuneEventsRoot[Event];
};
/**
 * Events related to nav radio tuning.
 */
interface NavRadioTuneEvents extends NavRadioTuneEventsIndexed<1>, NavRadioTuneEventsIndexed<2>, NavRadioTuneEventsIndexed<3>, NavRadioTuneEventsIndexed<4> {
}
/**
 * Com radio tuning event roots.
 */
declare type ComRadioTuneEventsRoot = {
    /** Com radio active frequency, in megahertz. */
    com_active_frequency: number;
    /** Com radio standby frequency, in megahertz. */
    com_standby_frequency: number;
    /** Com radio active frequency facility name. */
    com_active_facility_name: string;
    /** Com radio active frequency facility type. */
    com_active_facility_type: string;
    /** Com radio active frequency facility ident. */
    com_active_facility_ident: string;
    /** Whether a com radio is set to receive. */
    com_receive: boolean;
    /** Com radio status. */
    com_status: number;
    /** Whether a com radio is set to transmit. */
    com_transmit: boolean;
    /** Com radio spacing mode. */
    com_spacing_mode: ComSpacing;
    /** Com radio volume, as a percentage (0-100). */
    com_volume: number;
};
/**
 * Tuning events for an indexed com radio.
 */
declare type ComRadioTuneEventsIndexed<Index extends ComRadioIndex> = {
    [Event in keyof ComRadioTuneEventsRoot as `${Event}_${Index}`]: ComRadioTuneEventsRoot[Event];
};
/**
 * Events related to com radio tuning.
 */
interface ComRadioTuneEvents extends ComRadioTuneEventsIndexed<1>, ComRadioTuneEventsIndexed<2>, ComRadioTuneEventsIndexed<3> {
}
/**
 * ADF radio tuning event roots.
 */
declare type AdfRadioTuneEventsRoot = {
    /** ADF radio active frequency, in kilohertz. */
    adf_active_frequency: number;
    /** ADF radio standby frequency, in kilohertz. */
    adf_standby_frequency: number;
    /** Whether ADF radio audio monitoring is enabled. */
    adf_sound: boolean;
    /** ADF radio volume, as a percentage (0-100). */
    adf_volume: number;
    /** ADF radio ident, as a string. */
    adf_ident: string;
    /** ADF radio signal, as a number. */
    adf_signal: number;
};
/**
 * Tuning events for an indexed ADF radio.
 */
declare type AdfRadioTuneEventsIndexed<Index extends AdfRadioIndex> = {
    [Event in keyof AdfRadioTuneEventsRoot as `${Event}_${Index}`]: AdfRadioTuneEventsRoot[Event];
};
/**
 * Events related to ADF radio tuning.
 */
interface AdfRadioTuneEvents extends AdfRadioTuneEventsIndexed<1>, AdfRadioTuneEventsIndexed<2> {
}
/**
 * Events related to marker beacon tuning.
 */
interface MarkerBeaconTuneEvents {
    /** Whether the marker beacon receiver is in high sensitivity mode. */
    marker_beacon_hisense_on: boolean;
    /** Whether marker beacon audio monitoring is enabled. */
    marker_beacon_sound: boolean;
}
/**
 * Events related to tuning nav, com, and ADF radios.
 */
interface NavComSimVars extends ComRadioTuneEvents, NavRadioTuneEvents, AdfRadioTuneEvents, MarkerBeaconTuneEvents {
}
/**
 * A publisher of NAV, COM, ADF radio and marker beacon tuning-related sim var events.
 */
declare class NavComSimVarPublisher extends SimVarPublisher<NavComSimVars> {
    private static readonly simvars;
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<NavComSimVars> | undefined);
    /**
     * Creates an array of nav radio sim var event definitions for an indexed nav radio.
     * @param index The index of the nav radio.
     * @returns An array of nav radio sim var event definitions for the specified nav radio.
     */
    private static createNavRadioDefinitions;
    /**
     * Creates an array of com radio sim var event definitions for an indexed com radio.
     * @param index The index of the com radio.
     * @returns An array of com radio sim var event definitions for the specified com radio.
     */
    private static createComRadioDefinitions;
    /**
     * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
     * @param index The index of the ADF radio.
     * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
     */
    private static createAdfRadioDefinitions;
}
/**
 * A convenience class for creating a radio configuration set.
 *
 * Implementers should instantiate this and then populate the various maps
 * with the H events that their radio sends and which displays they affect.
 */
declare class NavComConfig {
    navSwitchEvents: Map<string, string>;
    navSelectorEvents: Map<string, string>;
    navWholeIncEvents: Map<string, string>;
    navWholeDecEvents: Map<string, string>;
    navFractionIncEvents: Map<string, string>;
    navFractionDecEvents: Map<string, string>;
    comSwitchEvents: Map<string, string>;
    comSelectorEvents: Map<string, string>;
    comWholeIncEvents: Map<string, string>;
    comWholeDecEvents: Map<string, string>;
    comFractionIncEvents: Map<string, string>;
    comFractionDecEvents: Map<string, string>;
    comVolumeIncEvents: Map<string, string>;
    comVolumeDecEvents: Map<string, string>;
    navVolumeIncEvents: Map<string, string>;
    navVolumeDecEvents: Map<string, string>;
}
/**
 * The core instrument that will drive all of a system's radios.
 */
declare class NavComInstrument {
    private bus;
    private hevents;
    private publisher;
    private simVarPublisher;
    private simVarSubscriber;
    private controlSubscriber;
    private navRadios;
    private comRadios;
    private config?;
    /**
     * Create a NavComController.
     * @param bus The event bus to publish to.
     * @param config A NavComConfig object defining the radio configuration.
     * @param numNavRadios The number of nav radios in the system.
     * @param numComRadios The number of com radios in the system.
     * @param sync Whether to sync events or not, default true.
     */
    constructor(bus: EventBus, config: NavComConfig | undefined, numNavRadios: number, numComRadios: number, sync?: boolean);
    /**
     * Initialize the instrument.
     */
    init(): void;
    /**
     * Perform events for the update loop.
     */
    onUpdate(): void;
    /**
     * Get the current frequency of a radio.
     * @param radioType The RadioType to query.
     * @param index The index number of the desired radio.
     * @param bank The FrequencyBank to query.
     * @returns The frequency in MHz.
     */
    private getFrequency;
    /**
     * React to a change on a radio frequency simvar.
     * @param type The RadioType to update.
     * @param index Index of the radio in the internal array.
     * @param bank The FrequencyBank in the selected radio to update.
     * @param freq The new frequency in MHz.
     */
    private updateRadioFreqCb;
    /**
     * Handle an hEvent.
     * @param hEvent The event that needs to be handled.
     */
    private eventHandler;
    /**
     * Get the current selected radio in a collection of radios.
     * @param radios An array of Radios.
     * @returns The selected Radio in the array.
     */
    private getSelectedRadio;
    /**
     * Swap frequencies in a radio.
     * @param radio The radio whose frequencies we want to swap.
     */
    private swapFreqs;
    /**
     * Update the frequencies in a radio from simvars.
     *
     * This is useful for snapshot updates as long as we're not worried
     * about one of the frequencies being updated while the snapshot is in
     * flight.
     * @param radio the radio to update
     */
    private updateAndPublish;
    /**
     * Explicitly set a new selected nav radio.
     * @param navSourceId An array of Radios to toggle.
     */
    private setActiveRadio;
    /**
     * Increase the volume of the selected nav or com radio.
     * @param radio The radio whose volume we want to increase.
     */
    private volumeInc;
    /**
     * Increase the volume of the selected nav or com radio.
     * @param radio The radio whose volume we want to increase.
     */
    private volumeDec;
    /**
     * Increase the integer portion of a frequency.
     * @param radio The Radio to update.
     */
    private wholeInc;
    /**
     * Decrease the integer portion of a frequency.
     * @param radio The Radio to update.
     */
    private wholeDec;
    /**
     * Increase the decimal portion of a frequency.
     * @param radio The Radio to update.
     */
    private fractInc;
    /**
     * Decrease the decimal portion of a frequency.
     * @param radio The Radio to update.
     */
    private fractDec;
    /**
     * Set the standby frequency of the currently selected nav or com radio.
     * @param radioType The radio type we want to set standby for.
     * @param frequency The frequency in MHz as a string.
     */
    private setStandbyFreq;
    /**
     * Toggle which of the radios is selected.
     * @param radios An array of Radios to toggle.
     */
    private swapSelection;
    /**
     * Set the full frequency of a radio.
     * @param radio The Radio to update.
     * @param bank The FrequencyBank to update.
     * @param freq The new frequency in MHz as a string.
     */
    private freqSet;
    /**
     * Set the K var for a frequency event
     * @param action A string defining whole/fract and inc/dec.
     * @param radio The radio this frequency is for.
     */
    private setKVar;
    /**
     * Send an update of all our radio states.
     * @param data True if we really want to do this.  (We need to support non-paramaterized commands.())
     */
    private publishRadioStates;
    /**
     * Sets the COM frequency spacing.
     * @param evt The event that is setting the spacing.
     */
    private setComSpacing;
}

/**
 * Non-indexed events related to pitot tubes.
 */
interface PitotNonIndexedEvents {
    /** Whether pitot heat is active. */
    pitot_heat_on: boolean;
    /** The icing state of the pitot tube, in percent. */
    pitot_icing_pct: number;
}
/**
 * Topics related to pitot tubes that are indexed by pitot tube.
 */
interface PitotIndexedTopics {
    /** Whether a pitot heat switch is in the on position. */
    pitot_heat_switch_on: boolean;
}
/**
 * Indexed events related to pitot tubes.
 */
declare type PitotIndexedEvents = {
    [P in keyof PitotIndexedTopics as IndexedEventType<P>]: PitotIndexedTopics[P];
};
/**
 * Events related to pitot tubes.
 */
declare type PitotEvents = PitotNonIndexedEvents & PitotIndexedEvents;
/**
 * A publisher for pitot tube information.
 */
declare class PitotPublisher extends SimVarPublisher<PitotEvents> {
    private static readonly nonIndexedSimVars;
    /**
     * Creates an instance of an PitotPublisher.
     * @param bus The event bus to use with this instance.
     * @param pitotCount The number of pitot tubes to support.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, pitotCount: number, pacer?: PublishPacer<PitotEvents>);
}

/**
 * An interface that describes the possible Pressurization events
 * on the event bus.
 */
interface PressurizationEvents {
    /** A cabin altitude value. */
    cabin_altitude: number;
    /** A cabin altitude rate value. */
    cabin_altitude_rate: number;
    /** A pressure differential value. */
    pressure_diff: number;
}
/**
 * A publisher for Pressurization information.
 */
declare class PressurizationPublisher extends SimVarPublisher<PressurizationEvents> {
    private static simvars;
    /**
     * Updates the ADC publisher.
     */
    onUpdate(): void;
    /**
     * Create an PressurizationPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<PressurizationEvents> | undefined);
}

/** Simvar definitions related to a transponder. */
interface XPDRSimVarEvents {
    /** Transponder code. */
    [xpdr_code: IndexedEventType<'xpdr_code'>]: number;
    /** Transponder mode. */
    [xpdr_mode: IndexedEventType<'xpdr_mode'>]: XPDRMode;
    /** Whether the transponder is sending ident. */
    [xpdr_ident: IndexedEventType<'xpdr_ident'>]: boolean;
}
/** Transponder modes. */
declare enum XPDRMode {
    OFF = 0,
    STBY = 1,
    TEST = 2,
    ON = 3,
    ALT = 4,
    GROUND = 5
}
/** A publiher to poll transponder simvars. */
declare class XPDRSimVarPublisher extends SimVarPublisher<XPDRSimVarEvents> {
    /**
     * Create an XPDRSimVarPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the pace of publishing.
     * @param transponderCount The number of transponders supported by this publisher.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<XPDRSimVarEvents> | undefined, transponderCount?: number);
}
/** A transponder. */
declare class XPDRInstrument {
    private readonly bus;
    private readonly transponderCount;
    private simVarPublisher;
    private controlSubscriber;
    private readonly identDebounceTimers;
    /**
     * Create an XPDRInstrument.
     * @param bus The event bus to publish to.
     * @param transponderCount The number of transponders supported by this instrument. Defaults to `1`.
     */
    constructor(bus: EventBus, transponderCount?: number);
    /** Initialize the instrument. */
    init(): void;
    /**
     * Perform events for the update loop.
     */
    onUpdate(): void;
    /**
     * Set the transponder code in the sim.
     * @param index The index of the transponder.
     * @param code The xpdr code.
     */
    private setXpdrCode;
    /**
     * Set the transponder mode in the sim.
     * @param index The index of the transponder.
     * @param mode The transponder mode.
     */
    private setXpdrMode;
    /**
     * Gets xpdr mode from the sim.
     * @param index The index of the transponder.
     * @returns The xpdr mode.
     */
    private getXpdrMode;
    /**
     * Sends ident to ATC for 18 seconds.
     * @param index The index of the transponder.
     */
    private sendIdent;
}

/**
 * Traffic events.
 */
interface TrafficEvents {
    /** A traffic contact was added. The value is the uid of the new contact. */
    traffic_contact_added: number;
    /** A traffic contact was updated. The value is the uid of the updated contact. */
    traffic_contact_updated: number;
    /** A traffic contact was removed. The value is the uid of the removed contact. */
    traffic_contact_removed: number;
}
/**
 * A traffic contact.
 */
interface TrafficContact {
    /** A unique ID number assigned to this contact. */
    readonly uid: number;
    /** The last time of contact, in sim time, as a UNIX millisecond timestamp. */
    readonly lastContactTime: number;
    /** The position of this contact at time of last contact. */
    readonly lastPosition: GeoPointReadOnly;
    /** The altitude of this contact at time of last contact. */
    readonly lastAltitude: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The heading of this contact at time of last contact. */
    readonly lastHeading: number;
    /** The most recent calculated ground speed of this contact. Equal to NaN if not yet been calculated. */
    readonly groundSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The most recent calculated ground track of this contact. Equal to NaN if not yet been calculated. */
    readonly groundTrack: number;
    /** The most recent calculaed vertical speed of this contact. Equal to NaN if not yet been calculated. */
    readonly verticalSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /**
     * Calculates the predicted position and altitude of this contact at a specified time based on the most recent
     * available data and stores the results in the supplied objects. If insufficient data are available to calculate
     * the prediction, the results will be equal to NaN.
     * @param simTime The sim time for which to calculate the prediction, as a UNIX millisecond timestamp.
     * @param positionOut A GeoPoint object to which to write the predicted position.
     * @param altitudeOut A NumberUnit object to which to write the predicted altitude.
     */
    predict(simTime: number, positionOut: GeoPoint, altitudeOut: NumberUnit<UnitFamily.Distance>): void;
}
/**
 * Initialization options for TrafficInstrument.
 */
declare type TrafficInstrumentOptions = {
    /** The maximum update frequency (Hz) in real time. */
    realTimeUpdateFreq: number;
    /** The maximum update frequency (Hz) in sim time. */
    simTimeUpdateFreq: number;
    /**
     * The maximum amount of sim time elapsed, in milliseconds, since last contact allowed before a contact is
     * deprecated.
     */
    contactDeprecateTime: number;
};
/**
 * Tracks aircraft traffic. Maintains a list of contacts, periodically updates their position, altitude, and reported
 * heading, and uses these data to compute ground speed, ground track, and vertical speed.
 */
declare class TrafficInstrument implements Instrument {
    private readonly bus;
    private readonly options;
    private readonly tracked;
    private lastUpdateRealTime;
    private lastUpdateSimTime;
    private isBusy;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus: EventBus, options: TrafficInstrumentOptions);
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid: number): TrafficContact | undefined;
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor: (contact: TrafficContact) => void): void;
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init(): void;
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    private updateContacts;
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    private createContact;
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    private updateContact;
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    private deprecateContacts;
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    private onSimTimeChanged;
    /**
     * This method does nothing.
     */
    onUpdate(): void;
}

/**
 * An interface that describes the possible Fuel System Parameter events
 */
interface BaseFuelSystemEvents {
    /** The opening state of a fuel system valve, as a percent, with 0 as fully closed and 100 as fully open. */
    fuel_system_valve_open: number;
}
/**
 * Topics related to fuel system information that are indexed.
 */
declare type FuelSystemIndexedTopics = 'fuel_system_valve_open';
/**
 * Indexed events related to fuel system information.
 */
declare type FuelSystemIndexedEvents = {
    [P in keyof Pick<BaseFuelSystemEvents, FuelSystemIndexedTopics> as IndexedEventType<P>]: BaseFuelSystemEvents[P];
};
/**
 * Events related to fuel system computer information.
 */
interface FuelSystemEvents extends BaseFuelSystemEvents, FuelSystemIndexedEvents {
}
/**
 * A publisher for fuel system information.
 */
declare class FuelSystemSimVarPublisher extends SimVarPublisher<FuelSystemEvents> {
    /**
     * Create an FuelSystemSimvarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus: EventBus, pacer?: PublishPacer<FuelSystemEvents> | undefined);
    /** @inheritdoc */
    onUpdate(): void;
}

/**
 * The available facility frequency types.
 */
declare enum FacilityFrequencyType {
    None = 0,
    ATIS = 1,
    Multicom = 2,
    Unicom = 3,
    CTAF = 4,
    Ground = 5,
    Tower = 6,
    Clearance = 7,
    Approach = 8,
    Departure = 9,
    Center = 10,
    FSS = 11,
    AWOS = 12,
    ASOS = 13,
    /** Clearance Pre-Taxi*/
    CPT = 14,
    /** Remote Clearance Delivery */
    GCO = 15
}
/**
 * A radio frequency on facility data.
 */
interface FacilityFrequency {
    /** The name of the frequency. */
    readonly name: string;
    /** The icao of the frequency. */
    readonly icao: string;
    /** The frequency, in MHz. */
    readonly freqMHz: number;
    /** The frequency, in BCD16. */
    readonly freqBCD16: number;
    /** The type of the frequency. */
    readonly type: FacilityFrequencyType;
}
/**
 * An ILS frequency on airport runway data.
 */
interface FacilityILSFrequency {
    /** The ICAO of the ILS frequency. */
    readonly icao: string;
    /** The name of the frequency. */
    readonly name: string;
    /** The frequency, in MHz. */
    readonly freqMHz: number;
    /** The frequency, in BCD16. */
    readonly freqBCD16: number;
    /** The type of the frequency. */
    readonly type: FacilityFrequencyType;
    /** Whether or not this ILS has a glideslope. */
    readonly hasGlideslope: boolean;
    /** The glideslope angle for this localizer. */
    readonly glideslopeAngle: number;
    /** The course, in degrees true, for this localizer. */
    readonly localizerCourse: number;
    /** The magvar at this localizer's position. */
    readonly magvar: number;
}
/**
 * A runway on airport facility data.
 */
interface AirportRunway {
    /** The latitude of the runway center. */
    readonly latitude: number;
    /** The longitude of the runway center. */
    readonly longitude: number;
    /** The runway elevation in meters. */
    readonly elevation: number;
    /** The true heading of the runway, in degrees. */
    readonly direction: number;
    /** The runway designation. */
    readonly designation: string;
    /** The length of the runway in meters. */
    readonly length: number;
    /** The width of the runway in meters. */
    readonly width: number;
    /** The runway surface type. */
    readonly surface: RunwaySurfaceType;
    /** The runway lighting type. */
    readonly lighting: RunwayLightingType;
    /** The primary runway designator character. */
    readonly designatorCharPrimary: RunwayDesignator;
    /** The secondary runway designator character. */
    readonly designatorCharSecondary: RunwayDesignator;
    /** The primary ILS frequency for the runway. */
    readonly primaryILSFrequency: FacilityILSFrequency;
    /** The secondary ILS frequency for the runway. */
    readonly secondaryILSFrequency: FacilityILSFrequency;
    /** The primary elevation for the runway in meters. */
    readonly primaryElevation: number;
    /** The primary displaced threshold distance from the start of the runway in meters. */
    readonly primaryThresholdLength: number;
    /** The primary elevation for the runway in meters. */
    readonly secondaryElevation: number;
    /** The primary displaced threshold distance from the start of the runway in meters. */
    readonly secondaryThresholdLength: number;
}
/**
 * A segment of an airway.
 */
interface AirwaySegment {
    /** The name of the airway */
    readonly name: string;
    /** The type of the airway. */
    readonly type: number;
    /** The previous FS ICAO on the airway. */
    readonly prevIcao: string;
    /** The next FS ICAO on the airway. */
    readonly nextIcao: string;
}
/**
 * A navdata airway.
 */
interface Airway {
    /** The name of the airway.*/
    readonly name: string;
    /** The type of the airway. */
    readonly type: number;
    /** The FS ICAOs that make up the airway. */
    readonly icaos: readonly string[];
}
/**
 * A leg in a flight plan or procedure.
 */
interface FlightPlanLeg {
    /** The ARINC-424 leg type. */
    type: LegType;
    /** The ICAO of the fix, if specified. */
    fixIcao: string;
    /** Whether or not the fix is a flyover fix. */
    flyOver: boolean;
    /** Whether or not the distance is minutes of time. */
    distanceMinutes: boolean;
    /** Whether or not the course is true or magnetic. */
    trueDegrees: boolean;
    /** The direction of the turn for the leg, if any. */
    turnDirection: LegTurnDirection;
    /** A reference ICAO for legs that have relative information. */
    originIcao: string;
    /** A center fix ICAO for legs that require it. */
    arcCenterFixIcao: string;
    /** The theta of the leg. */
    theta: number;
    /** The rho of the leg. */
    rho: number;
    /** The course of the leg. */
    course: number;
    /** The distance for the leg, in meters. */
    distance: number;
    /** Any speed restriction for the leg, in knots IAS. */
    speedRestriction: number;
    /** The type of altitude restriction for the leg. */
    altDesc: AltitudeRestrictionType;
    /** The first altitude field for restrictions, in meters. */
    altitude1: number;
    /** The second altitude field for restrictions, in meters. */
    altitude2: number;
    /** An exact latitude for this leg termination. */
    lat?: number;
    /** An exact longitude for this leg termination. */
    lon?: number;
    /** Flags indicating the approach fix type. See {@link FixTypeFlags}. Use BitFlags to check. */
    fixTypeFlags: number;
}
/** Additional Approach Types (additive to those defined in simplane). */
declare enum AdditionalApproachType {
    APPROACH_TYPE_VISUAL = 99
}
/** Approach Types inclusive of default ApproachType and AdditionalApproachType. */
declare type ExtendedApproachType = ApproachType | AdditionalApproachType;
/**
 * Flags indicating the approach fix type.
 */
declare enum FixTypeFlags {
    None = 0,
    IAF = 1,
    IF = 2,
    MAP = 4,
    FAF = 8,
    MAHP = 16
}
/**
 * Flags indicating the rnav approach type.
 */
declare enum RnavTypeFlags {
    None = 0,
    LNAV = 1,
    LNAVVNAV = 2,
    LP = 4,
    LPV = 8
}
/**
 * An arrival transition for a particular selected runway.
 */
interface RunwayTransition {
    /** The number of the runway. */
    readonly runwayNumber: number;
    /** The letter designation for the runway, if any (L, C, R) */
    readonly runwayDesignation: number;
    /** The legs that make up this procedure. */
    readonly legs: readonly Readonly<FlightPlanLeg>[];
}
/**
 * An enroute transition for an arrival.
 */
interface EnrouteTransition {
    /** The name for this transition. */
    readonly name: string;
    /** The legs that make up this procedure. */
    readonly legs: readonly Readonly<FlightPlanLeg>[];
}
/**
 * An arrival-to-approach transition.
 */
interface ApproachTransition {
    /** The name for this transition. */
    readonly name: string;
    /** The legs that make up this procedure. */
    readonly legs: readonly Readonly<FlightPlanLeg>[];
}
/**
 * An approach procedure.
 */
interface ApproachProcedure {
    /** The name of the approach procedure. */
    readonly name: string;
    /** The approach runway designation. */
    readonly runway: string;
    /** The ICAOs associated with this procedure. */
    readonly icaos: readonly string[];
    /** Transitions from the arrival that are available on this procedure. */
    readonly transitions: readonly ApproachTransition[];
    /** The common legs of the procedure for all transitions. */
    readonly finalLegs: readonly Readonly<FlightPlanLeg>[];
    /** The legs of the procedure for the missed approach segment. */
    readonly missedLegs: readonly Readonly<FlightPlanLeg>[];
    /** The approach type. */
    readonly approachType: ExtendedApproachType;
    /** The approach name suffix. */
    readonly approachSuffix: string;
    /** The approach runway designator. */
    readonly runwayDesignator: RunwayDesignator;
    /** The approach runway number. */
    readonly runwayNumber: number;
    /** The approach RNAV Type Flag. */
    readonly rnavTypeFlags: RnavTypeFlags;
}
/** Common interface for procedures. */
interface Procedure {
    /** The name of the departure. */
    readonly name: string;
    /** The legs of the procedure that are common to all selected transitions and runways. */
    readonly commonLegs: readonly Readonly<FlightPlanLeg>[];
    /** The transition from the departure to the enroute segment. */
    readonly enRouteTransitions: readonly EnrouteTransition[];
    /** The transition from the selected runway to the common procedure legs. */
    readonly runwayTransitions: readonly RunwayTransition[];
}
/**
 * A departure procedure (SID).
 */
declare type DepartureProcedure = Procedure;
/**
 * An arrival procedure (STAR).
 */
declare type ArrivalProcedure = Procedure;
/**
 * A navdata facility from the simulator.
 */
interface Facility {
    /** The FS ICAO for this facility. */
    readonly icao: string;
    /** The name of the facility. */
    readonly name: string;
    /** The latitude of the facility. */
    readonly lat: number;
    /** The longitude of the facility. */
    readonly lon: number;
    /** The region code in which this facility appears. */
    readonly region: string;
    /** The city region boundary within which this facility appears.*/
    readonly city: string;
    /** The magnetic variation at a given facilty location. */
    readonly magvar: number;
}
/**
 * An airport facility from the simulator.
 */
interface AirportFacility extends Facility {
    /** The privacy type of this airport. */
    readonly airportPrivateType: AirportPrivateType;
    /** The primary fuel available at this airport. */
    readonly fuel1: string;
    /** The secondary fuel available at this airport. */
    readonly fuel2: string;
    /** The name of the preferred airport approach. */
    readonly bestApproach: string;
    /** Whether or not the airport has radar coverage. */
    readonly radarCoverage: GpsBoolean;
    /** The type of airspace for the airport. */
    readonly airspaceType: number;
    /** The class of the airport. */
    readonly airportClass: number;
    /** Whether or not the airport is towered. */
    readonly towered: boolean;
    /** The frequencies available on the airport. */
    readonly frequencies: readonly FacilityFrequency[];
    /** The runways available on the airport. */
    readonly runways: AirportRunway[];
    /** The departure procedures on the airport. */
    readonly departures: readonly DepartureProcedure[];
    /** The approach procedures on the airport. */
    readonly approaches: readonly ApproachProcedure[];
    /** The arrival procedures on the airport. */
    readonly arrivals: readonly ArrivalProcedure[];
}
/**
 * The class of airport facility.
 */
declare enum AirportClass {
    /** No other airport class could be identified. */
    None = 0,
    /** The airport has at least one hard surface runway. */
    HardSurface = 1,
    /** The airport has no hard surface runways. */
    SoftSurface = 2,
    /** The airport has only water surface runways. */
    AllWater = 3,
    /** The airport has no runways, but does contain helipads. */
    HeliportOnly = 4,
    /** The airport is a non-public use airport. */
    Private = 5
}
/**
 * The class of an airport facility, expressed as a mask for nearest airport search session filtering.
 */
declare enum AirportClassMask {
    /** No other airport class could be identified. */
    None = 0,
    /** The airport has at least one hard surface runway. */
    HardSurface = 2,
    /** The airport has no hard surface runways. */
    SoftSurface = 4,
    /** The airport has only water surface runways. */
    AllWater = 8,
    /** The airport has no runways, but does contain helipads. */
    HeliportOnly = 16,
    /** The airport is a non-public use airport. */
    Private = 32
}
/**
 * An intersection facility.
 */
interface IntersectionFacility extends Facility {
    /** The airway segments that are adjacent to this */
    readonly routes: readonly AirwaySegment[];
    /** The FS ICAO of the nearest VOR to this intersection. */
    readonly nearestVorICAO: string;
    /** The type of the nearest VOR. */
    readonly nearestVorType: VorType;
    /** The frequency of the nearest VOR, in BCD16. */
    readonly nearestVorFrequencyBCD16: number;
    /** The frequency of the nearest VOR, in MHz. */
    readonly nearestVorFrequencyMHz: number;
    /** The radial in degrees true from the nearest VOR that the intersection lies on. */
    readonly nearestVorTrueRadial: number;
    /** The radial in degrees magnetic from the nearest VOR that the intersection lies on. */
    readonly nearestVorMagneticRadial: number;
    /** This distance to the nearest VOR. */
    readonly nearestVorDistance: number;
}
/**
 * An enumeration of possible intersection types.
 */
declare enum IntersectionType {
    None = 0,
    Named = 1,
    Unnamed = 2,
    Vor = 3,
    NDB = 4,
    Offroute = 5,
    IAF = 6,
    FAF = 7,
    RNAV = 8,
    VFR = 9
}
/**
 * A VOR facility.
 */
interface VorFacility extends Facility {
    /** The frequency of the VOR, in MHz. */
    readonly freqMHz: number;
    /** The frequency of the VOR, in BCD16. */
    readonly freqBCD16: number;
    /** The magnetic variation of the specific VOR. */
    readonly magneticVariation: number;
    /** The type of the VOR. */
    readonly type: VorType;
    /** The class of the VOR. */
    readonly vorClass: VorClass;
}
/**
 * A NDB facility.
 */
interface NdbFacility extends Facility {
    /** The frequency of the facility, in MHz. */
    readonly freqMHz: number;
    /** The type of NDB. */
    readonly type: NdbType;
}
/**
 * A User Waypoint facility.
 */
interface UserFacility extends Facility {
    /** If the user waypoint is temporary. */
    isTemporary: boolean;
    /** The type of user facility this is. */
    userFacilityType: UserFacilityType;
    /** The ICAO of the first reference facility. */
    reference1Icao?: string;
    /** The magnetic radial, in degrees, from the first reference facility. */
    reference1Radial?: number;
    /** The magnetic variation, in degrees, at the first reference facility. */
    reference1MagVar?: number;
    /** The disance from the first reference facility, in nautical miles. */
    reference1Distance?: number;
    /** The ICAO of the second reference facility. */
    reference2Icao?: string;
    /** The magnetic radial, in degrees, from the second reference facility. */
    reference2Radial?: number;
    /** The magnetic variation, in degrees, at the second reference facility. */
    reference2MagVar?: number;
}
declare enum UserFacilityType {
    RADIAL_RADIAL = 0,
    RADIAL_DISTANCE = 1,
    LAT_LONG = 2
}
/**
 * A runway waypoint facility.
 */
interface RunwayFacility extends Facility {
    /** The runway associated with this facility. */
    readonly runway: OneWayRunway;
}
/**
 * A visual approach waypoint facility.
 */
interface VisualFacility extends Facility {
    /** The name of the approach to which this facility belongs. */
    readonly approach: string;
}
/**
 * ARINC 424 Leg Types
 */
declare enum LegType {
    /** An unknown leg type. */
    Unknown = 0,
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    AF = 1,
    /** A course-to-altitude leg. */
    CA = 2,
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    CD = 3,
    /** A course-to-fix leg.*/
    CF = 4,
    /** A course-to-intercept leg. */
    CI = 5,
    /** A course-to-radial intercept leg. */
    CR = 6,
    /** A direct-to-fix leg, from an unspecified starting position. */
    DF = 7,
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    FA = 8,
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    FC = 9,
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    FD = 10,
    /** A course-to-manual-termination leg. */
    FM = 11,
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    HA = 12,
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    HF = 13,
    /** A hold-to-manual-termination leg. */
    HM = 14,
    /** Initial procedure fix. */
    IF = 15,
    /** A procedure turn leg. */
    PI = 16,
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    RF = 17,
    /** A track-to-fix leg, from the previous fix to the terminator. */
    TF = 18,
    /** A heading-to-altitude leg. */
    VA = 19,
    /** A heading-to-DME-distance leg. */
    VD = 20,
    /** A heading-to-intercept leg. */
    VI = 21,
    /** A heading-to-manual-termination leg. */
    VM = 22,
    /** A heading-to-radial intercept leg. */
    VR = 23,
    /** A leg representing a lateral and vertical discontinuity in the flight plan. */
    Discontinuity = 99,
    /** A leg representing a lateral and vertical discontinuity in the flight plan that does not prevent sequencing. */
    ThruDiscontinuity = 100
}
/**
 * Types of altitude restrictions on procedure legs.
 */
declare enum AltitudeRestrictionType {
    Unused = 0,
    At = 1,
    AtOrAbove = 2,
    AtOrBelow = 3,
    Between = 4
}
declare enum LegTurnDirection {
    None = 0,
    Left = 1,
    Right = 2,
    Either = 3
}
declare enum AirwayType {
    None = 0,
    Victor = 1,
    Jet = 2,
    Both = 3
}
declare enum NdbType {
    CompassPoint = 0,
    MH = 1,
    H = 2,
    HH = 3
}
declare enum VorType {
    Unknown = 0,
    VOR = 1,
    VORDME = 2,
    DME = 3,
    TACAN = 4,
    VORTAC = 5,
    ILS = 6,
    VOT = 7
}
declare enum RunwaySurfaceType {
    Concrete = 0,
    Grass = 1,
    WaterFSX = 2,
    GrassBumpy = 3,
    Asphalt = 4,
    ShortGrass = 5,
    LongGrass = 6,
    HardTurf = 7,
    Snow = 8,
    Ice = 9,
    Urban = 10,
    Forest = 11,
    Dirt = 12,
    Coral = 13,
    Gravel = 14,
    OilTreated = 15,
    SteelMats = 16,
    Bituminous = 17,
    Brick = 18,
    Macadam = 19,
    Planks = 20,
    Sand = 21,
    Shale = 22,
    Tarmac = 23,
    WrightFlyerTrack = 24,
    Ocean = 26,
    Water = 27,
    Pond = 28,
    Lake = 29,
    River = 30,
    WasteWater = 31,
    Paint = 32
}
declare enum RunwayLightingType {
    Unknown = 0,
    None = 1,
    PartTime = 2,
    FullTime = 3,
    Frequency = 4
}
/**
 * Describes a selected one way runway.
 */
interface OneWayRunway {
    /** The index of this runway's parent AirportRunway object in the airport facility. */
    readonly parentRunwayIndex: number;
    /** The runway number of this runway (as the numerical value of the one way designation). */
    readonly direction: number;
    /** The runwayDesignator of this runway. */
    readonly runwayDesignator: RunwayDesignator;
    /** The designation of this runway. */
    readonly designation: string;
    /** The latitude of the threshold of this runway. */
    readonly latitude: number;
    /** The longitude of the threshold of this runway. */
    readonly longitude: number;
    /** The elevation of this runway, at the displaced threshold, in meters. */
    readonly elevation: number;
    /** The elevation of this runway, at the opposite displaced threshold, in meters. */
    readonly elevationEnd: number;
    /** The gradient of this runway, in percent. Positive values indicate an upward slope from the start to the end. */
    readonly gradient: number;
    /** The true course of this runway in degrees. */
    readonly course: number;
    /** The ILS frequency for this runway. */
    readonly ilsFrequency?: FacilityILSFrequency;
    /** The total length of this runway, including displaced thresholds, in meters. */
    readonly length: number;
    /** The width of this runway in meters. */
    readonly width: number;
    /** The distance, in meters, between the start of this runway and the displaced threshold on that end. */
    readonly startThresholdLength: number;
    /** The distance, in meters, between the end of this runway and the displaced threshold on that end. */
    readonly endThresholdLength: number;
    /** The surface type of this runway. */
    readonly surface: RunwaySurfaceType;
    /** The lighting available for this runway. */
    readonly lighting: RunwayLightingType;
}
declare enum AirportPrivateType {
    Uknown = 0,
    Public = 1,
    Military = 2,
    Private = 3
}
declare enum GpsBoolean {
    Unknown = 0,
    No = 1,
    Yes = 2
}
declare enum VorClass {
    Unknown = 0,
    Terminal = 1,
    LowAlt = 2,
    HighAlt = 3,
    ILS = 4,
    VOT = 5
}
declare enum FacilityType {
    Airport = "LOAD_AIRPORT",
    Intersection = "LOAD_INTERSECTION",
    VOR = "LOAD_VOR",
    NDB = "LOAD_NDB",
    USR = "USR",
    RWY = "RWY",
    VIS = "VIS"
}
/**
 * A type map of FacilityType enum to facility type.
 */
declare type FacilityTypeMap = {
    /** Airport facility. */
    [FacilityType.Airport]: AirportFacility;
    /** VOR facility. */
    [FacilityType.VOR]: VorFacility;
    /** NDB facility. */
    [FacilityType.NDB]: NdbFacility;
    /** Intersection facility. */
    [FacilityType.Intersection]: IntersectionFacility;
    /** User waypoint facility. */
    [FacilityType.USR]: UserFacility;
    /** Runway waypoint facility. */
    [FacilityType.RWY]: RunwayFacility;
    /** Visual approach waypoint facility. */
    [FacilityType.VIS]: VisualFacility;
};
declare enum FacilitySearchType {
    All = 0,
    Airport = 1,
    Intersection = 2,
    Vor = 3,
    Ndb = 4,
    Boundary = 5,
    User = 6,
    Visual = 7,
    AllExceptVisual = 8
}
/**
 * Results from the completion of a nearest facilities search.
 */
interface NearestSearchResults<TAdded, TRemoved> {
    /** The ID of the search session these results belong to. */
    readonly sessionId: number;
    /** The ID of the search that was performed. */
    readonly searchId: number;
    /** The list of items added since the previous search. */
    readonly added: readonly TAdded[];
    /** The list of items removed since the previous search. */
    readonly removed: readonly TRemoved[];
}
/**
 * A facility that describes an airspace boundary.
 */
interface BoundaryFacility {
    /** The unique ID of the boundary. */
    readonly id: number;
    /** The name of the boundary. */
    readonly name: string;
    /** The airspace type of the boundary. */
    readonly type: BoundaryType;
    /** The minimum altitude for the boundary. */
    readonly minAlt: number;
    /** The maximum altitude for the boundary. */
    readonly maxAlt: number;
    /** The minimum altitude type. */
    readonly minAltType: BoundaryAltitudeType;
    /** The maximum altitude type. */
    readonly maxAltType: BoundaryAltitudeType;
    /** The top left corner of the bounding box for the boundary. */
    readonly topLeft: LatLong;
    /** The bottom right corner of the bounding box for the boundary. */
    readonly bottomRight: LatLong;
    /** The vectors that describe the boundary borders. */
    readonly vectors: BoundaryVector[];
    /** LODs of the vectors that describe the boundary borders. */
    readonly lods?: BoundaryVector[][];
}
/**
 * A type of airspace boundary.
 */
declare enum BoundaryType {
    None = 0,
    Center = 1,
    ClassA = 2,
    ClassB = 3,
    ClassC = 4,
    ClassD = 5,
    ClassE = 6,
    ClassF = 7,
    ClassG = 8,
    Tower = 9,
    Clearance = 10,
    Ground = 11,
    Departure = 12,
    Approach = 13,
    MOA = 14,
    Restricted = 15,
    Prohibited = 16,
    Warning = 17,
    Alert = 18,
    Danger = 19,
    NationalPark = 20,
    ModeC = 21,
    Radar = 22,
    Training = 23
}
/**
 * A type of airspace boundary altitude maxima.
 */
declare enum BoundaryAltitudeType {
    Unknown = 0,
    MSL = 1,
    AGL = 2,
    Unlimited = 3
}
/**
 * A vector in a boundary border geometry.
 */
interface BoundaryVector {
    /** The type of the vector. */
    readonly type: BoundaryVectorType;
    /**
     * The origin ID of the vector. If the type is Origin, then this is the ID of the
     * vector. If the type is not Origin, then this is the ID of the origin vector
     * that relates to the current vector.
     */
    readonly originId: number;
    /** The latitude of the vector. */
    readonly lat: number;
    /** The longitude of the vector. */
    readonly lon: number;
    /** The radius of the vector, if any. */
    readonly radius: number;
}
/**
 * A type of boundary geometry vector.
 */
declare enum BoundaryVectorType {
    None = 0,
    Start = 1,
    Line = 2,
    Origin = 3,
    ArcCW = 4,
    ArcCCW = 5,
    Circle = 6
}
/**
 * A METAR.
 */
interface Metar {
    /** The ident of this METAR's airport. */
    readonly icao: string;
    /** The day of observation, in UTC time. */
    readonly day: number;
    /** The hour of observation, in UTC time. */
    readonly hour: number;
    /** The minute of observation, in UTC time. */
    readonly min: number;
    /** The wind direction, in degrees relative to true north. */
    readonly windDir: number;
    /** The wind speed, expressed in units defined by `windSpeedUnits`. */
    readonly windSpeed: number;
    /** The wind gust, expressed in units defined by `windSpeedUnits`. */
    readonly gust?: number;
    /** The units in which this METAR's wind speeds are reported. */
    readonly windSpeedUnits: MetarWindSpeedUnits;
    /** Whether winds are variable. */
    readonly vrb: boolean;
    /** Whether ceiling and visibility are OK. */
    readonly cavok: boolean;
    /** The visibility, expressed in units defined by `visUnits`. */
    readonly vis: number;
    /** The units in which this METAR's visibility is reported. */
    readonly visUnits: MetarVisibilityUnits;
    /** Whether the observed visibility is less than the reported visibility. */
    readonly visLt: boolean;
    /** Cloud layers. */
    readonly layers: readonly MetarCloudLayer[];
    /** The vertical visibility, in hundreds of feet. */
    readonly vertVis?: number;
    /** The temperature, in degrees Celsius. */
    readonly temp: number;
    /** The dew point, in degrees Celsius. */
    readonly dew: number;
    /** The altimeter setting, in inHg. */
    readonly altimeterA?: number;
    /** The altimeter setting, in hPa. */
    readonly altimeterQ?: number;
    /** The estimated sea-level pressure, in hPa. */
    readonly slp?: number;
    /** Significant weather phenomena. */
    readonly phenomena: readonly MetarPhenomenon[];
    /** Whether this METAR contains remarks. */
    readonly rmk: boolean;
    /** A formatted string representation of this METAR. */
    readonly metarString: string;
}
/**
 * Wind speed units used by METAR.
 */
declare enum MetarWindSpeedUnits {
    Knot = 0,
    MeterPerSecond = 1,
    KilometerPerHour = 2
}
/** Visibility distance units used by METAR. */
declare enum MetarVisibilityUnits {
    Meter = 0,
    StatuteMile = 1
}
/**
 * A METAR cloud layer description.
 */
interface MetarCloudLayer {
    /** The altitude of this layer, in hundreds of feet. */
    readonly alt: number;
    /** The coverage of this layer. */
    readonly cover: MetarCloudLayerCoverage;
    /** The significant cloud type found in this layer. */
    readonly type: MetarCloudLayerType;
}
/**
 * METAR cloud layer coverage/sky condition.
 */
declare enum MetarCloudLayerCoverage {
    SkyClear = 0,
    Clear = 1,
    NoSignificant = 2,
    Few = 3,
    Scattered = 4,
    Broken = 5,
    Overcast = 6
}
/**
 * METAR significant cloud types.
 */
declare enum MetarCloudLayerType {
    Unspecified = -1,
    ToweringCumulus = 0,
    Cumulonimbus = 1,
    AltocumulusCastellanus = 2
}
/**
 * A METAR weather phenomenon.
 */
interface MetarPhenomenon {
    /** The type of this phenomenon. */
    readonly phenom: MetarPhenomenonType;
    /**
     * The intensity of this phenomenon.
     */
    readonly intensity: MetarPhenomenonIntensity;
    /** Whether this phenomenon has the blowing modifier. */
    readonly blowing: boolean;
    /** Whether this phenomenon has the freezing modifier. */
    readonly freezing: boolean;
    /** Whether this phenomenon has the drifting modifier. */
    readonly drifting: boolean;
    /** Whether this phenomenon has the vicinity modifier. */
    readonly vicinity: boolean;
    /** Whether this phenomenon has the partial modifier. */
    readonly partial: boolean;
    /** Whether this phenomenon has the shallow modifier. */
    readonly shallow: boolean;
    /** Whether this phenomenon has the patches modifier. */
    readonly patches: boolean;
    /** Whether this phenomenon has the temporary modifier. */
    readonly tempo: boolean;
}
/** METAR phenomenon types. */
declare enum MetarPhenomenonType {
    None = 0,
    Mist = 1,
    Duststorm = 2,
    Dust = 3,
    Drizzle = 4,
    FunnelCloud = 5,
    Fog = 6,
    Smoke = 7,
    Hail = 8,
    SmallHail = 9,
    Haze = 10,
    IceCrystals = 11,
    IcePellets = 12,
    DustSandWhorls = 13,
    Spray = 14,
    Rain = 15,
    Sand = 16,
    SnowGrains = 17,
    Shower = 18,
    Snow = 19,
    Squalls = 20,
    Sandstorm = 21,
    UnknownPrecip = 22,
    VolcanicAsh = 23
}
/** METAR phenomenon intensities. */
declare enum MetarPhenomenonIntensity {
    Light = -1,
    Normal = 0,
    Heavy = 1
}
/**
 * Methods for working with FS ICAO strings.
 */
declare class ICAO {
    /**
     * An empty ICAO.
     */
    static readonly emptyIcao = "            ";
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao: string): FacilityType;
    /**
     * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
     * @param icao The icao to get the airport ident for.
     * @returns The airport ident.
     */
    static getAssociatedAirportIdent(icao: string): string;
    /**
     * Checks whether an ICAO string defines a facility (optionally of a specific type).
     * @param icao An ICAO string.
     * @param type The specific facility type to check against. If not defined, this method will return `true` as long as
     * the ICAO string defines any valid facility type.
     * @returns Whether the given ICAO string defines a facility of the specified type.
     */
    static isFacility(icao: string, type?: FacilityType): boolean;
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao: string): string;
    /**
     * Gets the region code for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The two letter region code.
     */
    static getRegionCode(icao: string): string;
}
/**
 * Utility functions for working with facilities.
 */
declare class FacilityUtils {
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    /**
     * Checks whether a facility is of a given type.
     * @param facility The facility to check.
     * @param type The facility type to check against.
     * @returns Whether the facility is of the specified type.
     */
    static isFacilityType<T extends FacilityType>(facility: Facility, type: T): facility is FacilityTypeMap[T];
    /**
     * Gets the magnetic variation at a facility, in degrees. If the facility is a VOR, the magnetic variation defined
     * by the VOR is returned. For all other facilities, the modeled magnetic variation at the location of the facility
     * is returned.
     * @param facility A facility.
     * @returns The magnetic variation at the specified facility, in degrees.
     */
    static getMagVar(facility: Facility): number;
    /**
     * Gets latitude/longitude coordinates corresponding to a radial and distance from a reference facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees.
     * @param distance The distance, in nautical miles.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the specified radial and distance from the reference
     * facility.
     */
    static getLatLonFromRadialDistance(reference: Facility, radial: number, distance: number, out: GeoPoint): GeoPoint;
    /**
     * Gets latitude/longitude coordinates corresponding to the intersection of two facility radials.
     * @param reference1 The first reference facility.
     * @param radial1 The first magnetic radial, in degrees.
     * @param reference2 The second reference facility.
     * @param radial2 The second magnetic radial, in degrees.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the intersection of the two specified radials. If
     * the specified radials do not intersect at a unique point, `NaN` is written to both `lat` and `lon`.
     */
    static getLatLonFromRadialRadial(reference1: Facility, radial1: number, reference2: Facility, radial2: number, out: GeoPoint): GeoPoint;
}
/**
 * Utility functions for working with intersection facilities.
 */
declare class IntersectionFacilityUtils {
    private static readonly TERMINAL_REGEX;
    /**
     * Checks whether an intersection ICAO belongs to a terminal intersection.
     * @returns Whether the specified intersection ICAO belongs to a terminal intersection.
     * @throws Error if the specified ICAO is not an intersection ICAO.
     */
    static isTerminal(icao: string): boolean;
    /**
     * Checks whether an intersection facility is a terminal intersection.
     * @returns Whether the specified intersection facility is a terminal intersection.
     * @throws Error if the specified facility is not an intersection.
     */
    static isTerminal(facility: IntersectionFacility): boolean;
    /**
     * Gets the non-terminal version of an intersection ICAO. If the ICAO is already a non-terminal intersection ICAO,
     * then an identical string will be returned.
     * @param icao An intersection ICAO.
     * @returns The non-terminal version of the specified intersection ICAO.
     * @throws Error if the specified ICAO is not an intersection ICAO.
     */
    static getNonTerminalICAO(icao: string): string;
    private static readonly filterDuplicatesSet;
    /**
     * Gets an ICAO string from itself.
     * @param icao An ICAO string.
     * @returns The specified ICAO string.
     */
    private static getIcaoIdentity;
    /**
     * Gets an ICAO string from a facility.
     * @param facility A facility.
     * @returns The specified facility's ICAO string.
     */
    private static getIcaoFacility;
    /**
     * Filters an array of ICAOs such that the filtered array does not contain any duplicate terminal/non-terminal
     * intersection pairs. All non-intersection ICAOs are guaranteed to be retained in the filtered array.
     * @param icaos The array to filter.
     * @param retainTerminal Whether to retain the terminal version of a duplicate pair in the filtered array. If `true`,
     * each non-terminal intersection in the array will be filtered out if and only if the array contains at least one of
     * its terminal intersection counterparts. If `false`, each terminal intersection in the array will be filtered out
     * if and only if the array contains its non-terminal intersection counterpart. Defaults to `false`.
     * @returns A copy of the original array with no duplicate terminal/non-terminal intersection pairs.
     */
    static filterDuplicates(icaos: readonly string[], retainTerminal?: boolean): string[];
    /**
     * Filters an array of facilities such that the filtered array does not contain any duplicate terminal/non-terminal
     * intersection pairs. All non-intersection facilities are guaranteed to be retained in the filtered array.
     * @param icaos The array to filter.
     * @param retainTerminal Whether to retain the terminal version of a duplicate pair in the filtered array. If `true`,
     * each non-terminal intersection in the array will be filtered out if and only if the array contains at least one of
     * its terminal intersection counterparts. If `false`, each terminal intersection in the array will be filtered out
     * if and only if the array contains its non-terminal intersection counterpart. Defaults to `false`.
     * @returns A copy of the original array with no duplicate terminal/non-terminal intersection pairs.
     */
    static filterDuplicates(facilities: readonly Facility[], retainTerminal?: boolean): Facility[];
    /**
     * Filters an array of arbitrary elements such that the filtered array does not contain any elements that are mapped
     * to duplicate terminal/non-terminal intersection pairs. All elements that are not mapped to intersections are
     * guaranteed to be retained in the filtered array.
     * @param icaos The array to filter.
     * @param getIcao A function which maps array elements to ICAOs.
     * @param retainTerminal Whether to retain the terminal version of a duplicate pair in the filtered array. If `true`,
     * each non-terminal intersection in the array will be filtered out if and only if the array contains at least one of
     * its terminal intersection counterparts. If `false`, each terminal intersection in the array will be filtered out
     * if and only if the array contains its non-terminal intersection counterpart. Defaults to `false`.
     * @returns A copy of the original array with no elements that are mapped to duplicate terminal/non-terminal
     * intersection pairs.
     */
    static filterDuplicates<T>(array: readonly T[], getIcao: (element: T) => string, retainTerminal?: boolean): T[];
    /**
     * Checks whether an element should be filtered out from an array such that the filtered array does not contain any
     * elements that are mapped to duplicate terminal/non-terminal intersection pairs.
     * @param element The element to check.
     * @param getIcao A function which maps elements to ICAOs.
     * @param retainTerminal Whether to retain the terminal version of a duplicate pair in the filtered array.
     * @param nonTerminalIcaosToFilter A set of non-terminal ICAOs to filter out of the array.
     * @returns Whether the specified element should be filtered out from an array such that the filtered array does not
     * contain any elements that are mapped to duplicate terminal/non-terminal intersection pairs.
     */
    private static filterDuplicatesHelper;
}
/**
 * Utility functions for working with user facilities.
 */
declare class UserFacilityUtils {
    private static readonly geoPointCache;
    /**
     * Creates a user facility from latitude/longitude coordinates.
     * @param icao The ICAO string of the new facility.
     * @param lat The latitude of the new facility.
     * @param lon The longitude of the new facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromLatLon(icao: string, lat: number, lon: number, isTemporary?: boolean, name?: string): UserFacility;
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees, of the reference facility on which the new facility lies.
     * @param distance The distance, in nautical miles, from the reference facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromRadialDistance(icao: string, reference: Facility, radial: number, distance: number, isTemporary?: boolean, name?: string): UserFacility;
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference1 The first reference facility.
     * @param radial1 The magnetic radial, in degrees, of the first reference facility on which the new facility lies.
     * @param reference2 The second reference facility.
     * @param radial2 The magnetic radial, in degrees, of the second reference facility on which the new facility lies.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility, or `undefined` if the specified radials do not intersect at a unique point.
     */
    static createFromRadialRadial(icao: string, reference1: Facility, radial1: number, reference2: Facility, radial2: number, isTemporary?: boolean, name?: string): UserFacility | undefined;
}
/**
 * Utilities to deal with TACAN facilities.
 */
declare class TacanUtils {
    /**
     * Converts a VOR frequency to a TACAN channel.
     * @param frequency The frequency of the VOR.
     * @returns The TACAN channel.
     */
    static frequencyToChannel(frequency: number): string;
}

/**
 * Utility functions for working with airport data.
 */
declare class AirportUtils {
    private static readonly REGION_CODES;
    private static readonly NUMERAL_REGEX;
    /**
     * Attempts to get the region code of an airport.
     * @param facility The facility record for the airport.
     * @returns The region code of an airport, or `undefined` if one could not be found.
     */
    static tryGetRegionCode(facility: AirportFacility): string | undefined;
    /**
     * Gets the elevation of an airport, in meters. The elevation is estimated as the average elevation of the airport's
     * runways. If the airport has no runways, an elevation cannot be estimated and `undefined` is returned instead.
     * @param facility The facility record for the airport.
     * @returns The elevation of the specified airport, in meters, or `undefined` if the elevation could not be
     * determined.
     */
    static getElevation(facility: AirportFacility): number | undefined;
    /**
     * Gets the longest runway of an airport.
     * @param facility The facility record for the airport.
     * @returns The longest runway as an AirportRunway, or null.
     */
    static getLongestRunway(facility: AirportFacility): AirportRunway | null;
    /**
     * Get a list of runways at an airport matching specific criteria.
     * @param facility The facility record for the airport.
     * @param minLength The minimum length of the runway, in feet.
     * @param surfaceTypes An optional bitfield of RunwaySurfaceCategory values to allow.
     * @returns A list of matching runways.
     */
    static getFilteredRunways(facility: AirportFacility, minLength: number, surfaceTypes?: number): AirportRunway[];
    /**
     * Checks to see whether an airport has a runway matching specific criteria.   This is a
     * lighter version of getFilteredRunways that doesn't do any extra assignments.
     * @param facility The facility record for the airport.
     * @param minLength The minimum length of the runway, in feet.
     * @param surfaceTypes An optional bitfield of RunwaySurfaceCategory values to allow.
     * @returns A boolean if a matching runway exists.
     */
    static hasMatchingRunway(facility: AirportFacility, minLength: number, surfaceTypes?: number): boolean;
}

/**
 * Types of airspaces.
 */
declare enum AirspaceType {
    None = 0,
    Center = 1,
    ClassA = 2,
    ClassB = 3,
    ClassC = 4,
    ClassD = 5,
    ClassE = 6,
    ClassF = 7,
    ClassG = 8,
    Tower = 9,
    Clearance = 10,
    Ground = 11,
    Departure = 12,
    Approach = 13,
    MOA = 14,
    Restricted = 15,
    Prohibited = 16,
    Warning = 17,
    Alert = 18,
    Danger = 19,
    Nationalpark = 20,
    ModeC = 21,
    Radar = 22,
    Training = 23,
    Max = 24
}
/**
 * An airspace.
 */
interface Airspace {
    /** The type of the airspace. */
    readonly type: AirspaceType;
    /** The name of the airspace. */
    readonly name: string;
    /** The type of the airspace. */
    readonly segments: readonly GeoPoint[];
    /**
     * Checks whether this airspace is the same as another airspace.
     * @param other The other airspace.
     * @returns whether this airspace is the same as another airspace.
     */
    equals(other: Airspace): boolean;
}

/**
 * A searcher for airspaces.
 */
declare class AirspaceSearcher {
    readonly cacheSize: number;
    /** The amount of time to wait for a search to finish before it times out, in milliseconds. */
    static readonly SEARCH_TIMEOUT = 5000;
    static readonly DEFAULT_CACHE_SIZE = 1000;
    private cache;
    private _isBusy;
    private queue;
    /**
     * Constructor.
     * @param cacheSize The maximum size of the Airspace cache.
     */
    constructor(cacheSize?: number);
    /**
     * Checks whether this searcher is currently busy with a search.
     * @returns whether this searcher is currently busy with a search.
     */
    isBusy(): boolean;
    /**
     * Searches for airspaces around a geographic point. If the searcher is not busy, the search will execute
     * immediately. If the search is busy, the search will be queued. Queued searches will be executed one at a time in
     * FIFO order as searches are finished.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of airspaces when the search finishes.
     */
    search(center: GeoPointInterface): Promise<Airspace[]>;
    /**
     * Enqueues a search operation.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    private enqueueSearch;
    /**
     * Executes the next search operation in the queue, if one exists.
     */
    private processQueue;
    /**
     * Executes an airspace search.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    private doSearch;
    /**
     * Executes a Coherent airspace search.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of Coherent airspace definitions when the search finishes.
     */
    private executeCoherentSearch;
    /**
     * Processes an array of Coherent airspace definitions into an array of Airspaces.
     * @param defs An array fo Coherent airspace definitions.
     * @returns an array of Airspaces corresponding to the supplied definitions.
     */
    private processCoherentDefs;
    /**
     * Adds an airspace to the cache. If the cache size exceeds the maximum after the operation, airspaces will be
     * removed from the cache in FIFO order to maintain the maximum cache size.
     * @param airspace The airspace to cache.
     */
    private cacheAirspace;
    /**
     * Generates a unique string ID for a Coherent airspace definition.
     * @param def The airspace definition.
     * @returns a unique string ID.
     */
    private static generateUID;
}

/**
 * Gets the element type of an array.
 */
declare type ArrayType<A extends ReadonlyArray<any>> = A extends ReadonlyArray<infer T> ? T : never;
/**
 * Flattens an array type to a depth of 1.
 */
declare type FlattenArray<A extends ReadonlyArray<any>> = A extends ReadonlyArray<infer T> ? Array<T extends ReadonlyArray<infer T1> ? T1 : T> : never;
/**
 * Flattens an array type to a depth between 0 and 10, inclusive.
 */
declare type FlattenArrayToDepth<A extends ReadonlyArray<any>, Depth extends 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10> = Depth extends 0 ? A : Depth extends 1 ? FlattenArray<A> : Depth extends 2 ? FlattenArrayToDepth<FlattenArray<A>, 1> : Depth extends 3 ? FlattenArrayToDepth<FlattenArray<A>, 2> : Depth extends 4 ? FlattenArrayToDepth<FlattenArray<A>, 3> : Depth extends 5 ? FlattenArrayToDepth<FlattenArray<A>, 4> : Depth extends 6 ? FlattenArrayToDepth<FlattenArray<A>, 5> : Depth extends 7 ? FlattenArrayToDepth<FlattenArray<A>, 6> : Depth extends 8 ? FlattenArrayToDepth<FlattenArray<A>, 7> : Depth extends 9 ? FlattenArrayToDepth<FlattenArray<A>, 8> : Depth extends 10 ? FlattenArrayToDepth<FlattenArray<A>, 9> : never;
/**
 * Utility functions for working with arrays.
 */
declare class ArrayUtils {
    private static readonly STRICT_EQUALS;
    /**
     * Creates a new array with initialized values.
     * @param length The length of the new array.
     * @param init A function which generates initial values for the new array at each index.
     * @returns A new array of the specified length with initialized values.
     */
    static create<T>(length: number, init: (index: number) => T): T[];
    /**
     * Gets the element at a specific index in an array.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array.
     * @throws RangeError if the index is out of bounds.
     */
    static at<T>(array: readonly T[], index: number): T;
    /**
     * Gets the element at a specific index in an array, or `undefined` if the index is out of bounds.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array, or `undefined` if the index is out of bounds.
     */
    static peekAt<T>(array: readonly T[], index: number): T | undefined;
    /**
     * Gets the first element of an array.
     * @param array An array.
     * @returns The first element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static first<T>(array: readonly T[]): T;
    /**
     * Gets the first element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The first element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekFirst<T>(array: readonly T[]): T | undefined;
    /**
     * Gets the last element of an array.
     * @param array An array.
     * @returns The last element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static last<T>(array: readonly T[]): T;
    /**
     * Gets the last element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The last element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekLast<T>(array: readonly T[]): T | undefined;
    /**
     * Checks if a certain element is included in an array.
     * @param array An array.
     * @param searchElement The element to search for.
     * @param fromIndex The position in this array at which to begin searching for `searchElement`.
     * @returns Whether the search element is included in the specified array.
     */
    static includes<T>(array: readonly T[], searchElement: any, fromIndex?: number): searchElement is T;
    /**
     * Checks if two arrays are equal to each other. This method considers two arrays `a` and `b` if their lengths are
     * equal and `a[i]` equals `b[i]` for every valid index `i`. All empty arrays are considered equal to one another.
     * @param a The first array.
     * @param b The second array.
     * @param equalsFunc The function to use to determine whether two array elements are equal to each other. Defaults
     * to a function which uses the strict equality operator (`===`).
     * @returns Whether the two specified arrays are equal.
     */
    static equals<T1, T2>(a: readonly T1[], b: readonly T2[], equalsFunc?: (a: T1, b: T2) => boolean): boolean;
    /**
     * Creates a new array by mapping each element of an existing array using a mapping function, then flattening the
     * mapped elements to a maximum depth of one, leaving the original array intact.
     * @param array An array.
     * @param map A function which is called once on each element of the original array to map it to an arbitrary value.
     * @returns A new array which was created by mapping each element of the specified array, then flattening the mapped
     * elements to a maximum depth of one.
     */
    static flatMap<O, A extends ReadonlyArray<any>>(array: A, map: (value: ArrayType<A>, index: number, array: A) => O): FlattenArray<O[]>;
    /**
     * Creates a new array by flattening an existing array to a maixmum depth of one, leaving the original array intact.
     * The process of flattening replaces each element in the array that is itself an array with the sequence of elements
     * found in the sub-array, recursively up to the maximum depth.
     * @param array An array.
     * @returns A new array which was created by flattening the specified array to a maximum depth of one.
     */
    static flat<A extends ReadonlyArray<any>>(array: A): FlattenArray<A>;
    /**
     * Creates a new array by flattening an existing array to a maximum depth, leaving the original array intact. The
     * process of flattening replaces each element in the array that is itself an array with the sequence of elements
     * found in the sub-array, recursively up to the maximum depth.
     * @param array An array.
     * @param depth The maximum depth to which to flatten. Values less than or equal to zero will result in no flattening
     * (in other words, a shallow copy of the original array will be returned). Defaults to `1`.
     * @returns A new array which was created by flattening the specified array to the specified maximum depth.
     */
    static flat<A extends ReadonlyArray<any>, Depth extends 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | undefined>(array: A, depth: Depth): FlattenArrayToDepth<A, Depth extends undefined ? 1 : Depth>;
    /**
     * Creates a new array by flattening an existing array to a maximum depth, leaving the original array intact. The
     * process of flattening replaces each element in the array that is itself an array with the sequence of elements
     * found in the sub-array, recursively up to the maximum depth.
     * @param array An array.
     * @param depth The maximum depth to which to flatten. Values less than or equal to zero will result in no flattening
     * (in other words, a shallow copy of the original array will be returned). Defaults to `1`.
     * @returns A new array which was created by flattening the specified array to the specified maximum depth.
     */
    static flat<T = unknown>(array: readonly unknown[], depth?: number): T[];
    /**
     * Recursively flattens an array and writes the flattened sequence of elements into another array.
     * @param array The array to flatten.
     * @param maxDepth The maximum depth to which to flatten.
     * @param depth The current flattening depth.
     * @param out The array to which to write the flattened sequence of elements.
     */
    private static flatHelper;
    /**
     * Performs a shallow copy of an array. After the operation is complete, the target array will have the same
     * length and the same elements in the same order as the source array.
     * @param source The array to copy.
     * @param target The array to copy into. If not defined, a new array will be created.
     * @returns The target array, after the source array has been copied into it.
     */
    static shallowCopy<T>(source: readonly T[], target?: T[]): T[];
    /**
     * Performs a binary search on a sorted array to find the index of the first or last element in the array whose
     * sorting order is equal to a query element. If no such element in the array exists, `-(index + 1)` is returned,
     * where `index` is the index at which the query element would be found if it were contained in the sorted array.
     * @param array An array.
     * @param element The element to search for.
     * @param comparator A function which determines the sorting order of elements in the array. The function should
     * return a negative number if the first element is to be sorted before the second, a positive number if the first
     * element is to be sorted after the second, or zero if both elements are to be sorted equivalently.
     * @param first If `true`, this method will find the first (lowest) matching index if there are multiple matching
     * indexes, otherwise this method will find the last (highest) matching index. Defaults to `true`.
     * @returns The index of the first (if `first` is `true`) or last (if `first` is `false`) element in the specified
     * array whose sorting order is equal to the query element, or `-(index + 1)`, where `index` is the index at which
     * the query element would be found if it were contained in the sorted array, if no element in the array has a
     * sorting order equal to the query.
     */
    static binarySearch<T>(array: readonly T[], element: T, comparator: (a: T, b: T) => number, first?: boolean): number;
    /**
     * Gets the length of the longest string in the array.
     * @param array The array to search in.
     * @returns length of the longest string
     */
    static getMaxStringLength(array: string[]): number;
}

/**
 * A binary min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time. Additionally, this type of heap
 * supports combined insertion and removal operations (in either order) which are slightly more efficient than chaining
 * the two operations separately.
 */
declare class BinaryHeap<T> {
    private readonly comparator;
    private readonly tree;
    /** The number of elements contained in this heap. */
    get size(): number;
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator: (a: T, b: T) => number);
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin(): T | undefined;
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin(): T | undefined;
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element: T): this;
    /**
     * Inserts an element into this heap, then removes the element with the smallest key.
     * @param element The element to insert.
     * @returns The removed element.
     */
    insertAndRemoveMin(element: T): T;
    /**
     * Removes the element in this heap with the smallest key, then inserts a new element.
     * @param element The element to insert.
     * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
     */
    removeMinAndInsert(element: T): T | undefined;
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear(): this;
    /**
     * Restores the heap property for this heap upwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    private heapifyUp;
    /**
     * Restores the heap property for this heap downwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    private heapifyDown;
    /**
     * Swaps two nodes in this heap.
     * @param index1 The index of the first node.
     * @param index2 The index of the second node.
     */
    private swap;
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    private static parent;
    /**
     * Finds the index of a node's left child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's left child.
     */
    private static left;
    /**
     * Finds the index of a node's right child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's right child.
     */
    private static right;
}

/**
 * A binominal min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time (amortized to constant time in the
 * case of insertions). Merges are also supported, with destructive merges performed in logarithmic time.
 */
declare class BinomialHeap<T> {
    private readonly comparator;
    /**
     * The root of the lowest-ordered tree in this heap. For each root, the `rightSibling` property points to the root
     * of the next-lowest-ordered tree in the heap, forming a singly-linked list of roots in ascending tree order.
     */
    private rootsHead?;
    private minimum?;
    private _size;
    /** The number of elements contained in this heap. */
    get size(): number;
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator: (a: T, b: T) => number);
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin(): T | undefined;
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin(): T | undefined;
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element: T): this;
    /**
     * Merges this heap with another one. The merge can either be non-destructive or destructive. A non-destructive merge
     * preserves the other heap. A destructive merge clears the other heap. A destructive merge takes O(log N) time
     * while a non-destructive merge takes O(M + log N) time, where N is either the size of this heap or the size of the
     * other heap, whichever is larger, and M is the size of the other heap. The difference stems from the need to copy
     * the other heap in a non-destructive merge. Note that the result of this operation is only valid if the two heaps
     * have equivalent comparator functions.
     * @param other The heap to merge into this one.
     * @param destructive Whether to perform a destructive merge. False by default.
     * @returns This heap, after the merge has been completed.
     */
    merge<U extends T>(other: BinomialHeap<U>, destructive?: boolean): this;
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear(): this;
    /**
     * Updates the pointer to this heap's minimum element.
     */
    private updateMin;
    /**
     * Merges two heaps.
     * @param a The lowest-ordered root of the first heap to merge, or undefined for an empty heap.
     * @param b The lowest-ordered root of the second heap to merge, or undefined for an empty heap.
     * @returns The lowest-ordered root of the union of the two input heaps, or undefined if the merged heap is empty.
     */
    private mergeHeaps;
    /**
     * Merges two binomial trees of equal order.
     * @param a The root of the first tree to merge.
     * @param b The root of the second tree to merge.
     * @returns The root of the merged tree.
     * @throws Error if the two input trees have different orders.
     */
    private mergeTrees;
    /**
     * Reverses the order of sibling nodes.
     * @param leftMostSibling The left-most sibling in a set of sibling nodes to reverse.
     * @returns The left-most sibling of the reversed set of siblings (originally the right-most sibling before the
     * reversal).
     */
    private static reverseSiblings;
    /**
     * Copies a binomial tree.
     * @param root The root of the tree to copy.
     * @returns The root of the copy.
     */
    private static copyTree;
}

/**
 * A sorted array.
 */
declare class SortedArray<T> {
    private readonly comparatorFunc;
    private readonly equalityFunc;
    private static readonly DEFAULT_EQUALITY_FUNC;
    private readonly _array;
    /** A read-only version of the array object backing this sorted array. */
    get array(): readonly T[];
    /**
     * The number of elements in this array.
     * @returns The number of elements in the array.
     */
    get length(): number;
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc: (a: T, b: T) => number, equalityFunc?: (a: T, b: T) => boolean);
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    private findIndex;
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    private searchEquals;
    /**
     * Gets the element at a specified index.
     * @param index An index.
     * @returns The element at the specified index.
     * @throws RangeError if index is out of bounds.
     */
    get(index: number): T;
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    peek(index: number): T | undefined;
    /**
     * Gets the first element in this array.
     * @returns The first element in this array.
     * @throws RangeError if this array is empty.
     */
    first(): T;
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    peekFirst(): T | undefined;
    /**
     * Gets the last element in this array.
     * @returns The last element in this array.
     * @throws RangeError if this array is empty.
     */
    last(): T;
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    peekLast(): T | undefined;
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element: T): boolean;
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element: T): number;
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements: Iterable<T>): number;
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element: T): number;
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements: Iterable<T>): number;
    /**
     * Removes an element at a specific index from this array and returns it.
     * @param index The index of the element to remove.
     * @returns The removed element, or `undefined` if no element was removed.
     */
    removeAt(index: number): T | undefined;
    /**
     * Removes the last element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    pop(): T | undefined;
    /**
     * Removes the first element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    shift(): T | undefined;
    /**
     * Re-sorts this array using its sorting function.
     */
    resort(): void;
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element: T): number;
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query: T): T | undefined;
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query: T): number;
    /**
     * Removes all elements from this array.
     */
    clear(): void;
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values(): IterableIterator<T>;
    /** @inheritdoc */
    [Symbol.iterator](): IterableIterator<T>;
}

/**
 * A linearly interpolated N-dimensional lookup table.
 */
declare class LerpLookupTable {
    private static readonly BREAKPOINT_COMPARATOR;
    private static readonly tempBreakpoint;
    private readonly _dimensionCount;
    /** The number of dimensions in this table. */
    get dimensionCount(): number;
    private readonly table;
    /**
     * Creates a lookup table of a specified dimension.
     * @param dimensionCount The number of dimensions in the new table. Values less than 0 will be clamped to 0.
     */
    constructor(dimensionCount: number);
    /**
     * Creates a lookup table initialized with an array of breakpoints.
     * @param breakpoints An array of breakpoints with which to initialize the new table. Each breakpoint should be
     * expressed as a number array, where the first element represents the breakpoint value, and the next N elements
     * represent the breakpoint key in each dimension. If not all breakpoint arrays have the same length, the dimension
     * of the table will be set equal to `L - 1`, where `L` is the length of the shortest array. For arrays with length
     * greater than `L`, all keys after index `L - 1` will be ignored. If the table ends up with zero dimensions, it will
     * be initialized to an empty table.
     */
    constructor(breakpoints: readonly (readonly number[])[]);
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, or the breakpoint has fewer dimensions than this table.
     */
    insertBreakpoint(breakpoint: readonly number[]): this;
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    private insertBreakpointHelper;
    /**
     * Looks up a value in this table using a specified key. The returned value will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The value corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a value could
     * not be retrieved.
     */
    get(...key: number[]): number;
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @returns The interpolated value of the key at the specified dimension.
     */
    private lookupHelper;
}

/**
 * A utility class for working with common aeronautical constants and calculations.
 */
declare class AeroMath {
    /** The ideal gas constant, in units of joules per mole per kelvin. */
    static readonly R = 8.314462618153;
    /** The specific gas constant of dry air, in units of joules per kilogram per kelvin. */
    static readonly R_AIR = 287.057;
    /** Approximate value of the adiabatic index of air near room temperature. */
    static readonly GAMMA_AIR = 1.4;
    /** The speed of sound in air at sea level under ISA conditions, in meters per second. */
    static readonly SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
    /**
     * Gets the static pressure of air, in hectopascals, given temperature and density.
     * @param temperature The temperature, in degrees Celsius.
     * @param density The density, in kilograms per cubic meter.
     * @returns The static pressure of air, in hectopascals, with the specified temperature and density.
     */
    static pressureAir(temperature: number, density: number): number;
    /**
     * Gets the density of air, in kilograms per cubic meter, given static pressure and temperature.
     * @param pressure The static pressure, in hectopascals.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The density of air, in kilograms per cubic meter, with the specified static pressure and temperature.
     */
    static densityAir(pressure: number, temperature: number): number;
    /**
     * Gets the temperature of air, in degrees Celsius, given static pressure and density.
     * @param pressure The static pressure, in hectopascals.
     * @param density The density, in kilograms per cubic meter.
     * @returns The temperature of air, in degrees Celsius, with the specified static pressure and temperature.
     */
    static temperatureAir(pressure: number, density: number): number;
    /**
     * Gets the speed of sound in air, in meters per second, for a given temperature.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The speed of sound in air, in meters per second, for the given temperature.
     */
    static soundSpeedAir(temperature: number): number;
    /**
     * Gets the ratio of total pressure to static pressure for a given mach number in a subsonic compressible airflow.
     * @param mach The mach number.
     * @returns The ratio of total pressure to static pressure for the specific mach number.
     */
    static totalPressureRatioAir(mach: number): number;
    /**
     * Gets the ISA temperature, in degrees Celsius, at a given pressure altitude. The supported pressure altitude range
     * is from -610 to 80000 meters above MSL. This method will return the temperature at -610 meters for all altitudes
     * below this range, and the temperature at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA temperature, in degrees Celsius, for the specified pressure altitude.
     */
    static isaTemperature(altitude: number): number;
    /**
     * Gets the ISA pressure, in hectopascals, at a given pressure altitude. The supported pressure altitude range is
     * from -610 to 80000 meters above MSL. This method will return the pressure at -610 meters for all altitudes below
     * this range, and the pressure at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA pressure, in hectopascals, for the specified pressure altitude.
     */
    static isaPressure(altitude: number): number;
    /**
     * Gets the ISA density, in kilograms per cubic meter, at a given pressure altitude. The supported pressure altitude
     * range is from -610 to 80000 meters above MSL. This method will return the density at -610 meters for all altitudes
     * below this range, and the density at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The ISA density, in kilograms per cubic meter, for the specified pressure altitude.
     */
    static isaDensity(altitude: number, deltaIsa?: number): number;
    /**
     * Gets the speed of sound, in meters per second, at a given pressure altitude under ISA conditions.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The speed of sound, in meters per second, at the specified pressure altitude under ISA conditions.
     */
    static soundSpeedIsa(altitude: number, deltaIsa?: number): number;
    /**
     * Converts true airspeed (TAS) to mach number.
     * @param tas The true airspeed to convert, in the same units as `soundSpeed`.
     * @param soundSpeed The speed of sound, in the same units as `tas`.
     * @returns The mach number equivalent of the specified true airspeed.
     */
    static tasToMach(tas: number, soundSpeed: number): number;
    /**
     * Converts true airspeed (TAS) to mach number under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The mach number equivalent of the specified true airspeed at the specified pressure altitude under ISA
     * conditions.
     */
    static tasToMachIsa(tas: number, altitude: number, deltaIsa?: number): number;
    /**
     * Converts mach number to true airspeed (TAS).
     * @param mach The mach number to convert.
     * @param soundSpeed The speed of sound.
     * @returns The true airspeed equivalent of the specified mach number, in the same units as `soundSpeed`.
     */
    static machToTas(mach: number, soundSpeed: number): number;
    /**
     * Converts mach number to true airspeed (TAS), in meters per second, under ISA conditions.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified mach number at the specified
     * pressure altitude under ISA conditions.
     */
    static machToTasIsa(mach: number, altitude: number, deltaIsa?: number): number;
    /**
     * Converts calibrated airspeed (CAS) to mach number. The conversion is only valid for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified static pressure.
     */
    static casToMach(cas: number, pressure: number): number;
    /**
     * Converts calibrated airspeed (CAS) to mach number under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified pressure altitude under
     * ISA conditions.
     */
    static casToMachIsa(cas: number, altitude: number): number;
    /**
     * Converts mach number to calibrated airspeed (CAS). The conversion is only valid for subsonic speeds.
     * @param mach The mach number to convert.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number at the specified
     * static pressure.
     */
    static machToCas(mach: number, pressure: number): number;
    /**
     * Converts mach number to calibrated airspeed (CAS) under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number  at the specified
     * pressure altitude under ISA conditions.
     */
    static machToCasIsa(mach: number, altitude: number): number;
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS).
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * ambient pressure and temperature.
     */
    static casToTas(cas: number, pressure: number, temperature: number): number;
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS) under ISA conditions.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static casToTasIsa(cas: number, altitude: number, deltaIsa?: number): number;
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS).
     * @param tas The true airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * ambient pressure and temperature.
     */
    static tasToCas(tas: number, pressure: number, temperature: number): number;
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS) under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static tasToCasIsa(tas: number, altitude: number, deltaIsa?: number): number;
    /**
     * Calculates a fluid flow force coefficient given a force and flow parameters.
     * @param force The flow force, in newtons.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force coefficient given the specified force and flow parameters.
     */
    private static flowCoefFromForce;
    /**
     * Calculates a fluid flow force given a coefficient and flow parameters.
     * @param coef The flow force coefficient.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force given the specified coefficient and flow parameters.
     */
    private static flowForceFromCoef;
    static liftCoefficient: {
        /**
         * Calculates the lift coefficient given certain parameters.
         * @param lift The lift force, in newtons.
         * @param area The wing area, in meters squared.
         * @param density The flow density, in kilograms per cubic meter.
         * @param flowSpeed The flow speed, in meters per second.
         * @returns The lift coefficient given the specified parameters.
         */
        (lift: number, area: number, density: number, flowSpeed: number): number;
        /**
         * Calculates the lift coefficient given certain parameters.
         * @param lift The lift force, in newtons.
         * @param area The wing area, in meters squared.
         * @param dynamicPressure The flow dynamic pressure, in hectopascals.
         * @returns The lift coefficient given the specified parameters.
         */
        (lift: number, area: number, dynamicPressure: number): number;
    };
    static lift: {
        /**
         * Calculates lift force, in newtons, given certain parameters.
         * @param cl The lift coefficient.
         * @param area The wing area, in meters squared.
         * @param density The flow density, in kilograms per cubic meter.
         * @param flowSpeed The flow speed, in meters per second.
         * @returns The lift force, in newtons, given the specified parameters.
         */
        (cl: number, area: number, density: number, flowSpeed: number): number;
        /**
         * Calculates lift force, in newtons, given certain parameters.
         * @param cl The lift coefficient.
         * @param area The wing area, in meters squared.
         * @param dynamicPressure The flow dynamic pressure, in hectopascals.
         * @returns The lift force, in newtons, given the specified parameters.
         */
        (cl: number, area: number, dynamicPressure: number): number;
    };
    static dragCoefficient: {
        /**
         * Calculates the drag coefficient given certain parameters.
         * @param lift The drag force, in newtons.
         * @param area The wing area, in meters squared.
         * @param density The flow density, in kilograms per cubic meter.
         * @param flowSpeed The flow speed, in meters per second.
         * @returns The drag coefficient given the specified parameters.
         */
        (drag: number, area: number, density: number, flowSpeed: number): number;
        /**
         * Calculates the drag coefficient given certain parameters.
         * @param drag The drag force, in newtons.
         * @param area The wing area, in meters squared.
         * @param dynamicPressure The flow dynamic pressure, in hectopascals.
         * @returns The drag coefficient given the specified parameters.
         */
        (drag: number, area: number, dynamicPressure: number): number;
    };
    static drag: {
        /**
         * Calculates drag force, in newtons, given certain parameters.
         * @param cd The drag coefficient.
         * @param area The wing area, in meters squared.
         * @param density The flow density, in kilograms per cubic meter.
         * @param flowSpeed The flow speed, in meters per second.
         * @returns The drag force, in newtons, given the specified parameters.
         */
        (cd: number, area: number, density: number, flowSpeed: number): number;
        /**
         * Calculates drag force, in newtons, given certain parameters.
         * @param cd The drag coefficient.
         * @param area The wing area, in meters squared.
         * @param dynamicPressure The flow dynamic pressure, in hectopascals.
         * @returns The drag force, in newtons, given the specified parameters.
         */
        (cd: number, area: number, dynamicPressure: number): number;
    };
}

/**
 * Utility class for manipulating bit flags.
 */
declare class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index: number): number;
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags: number, mask?: number): number;
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags: number[]): number;
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags: number[]): number;
    /**
     * Changes a bit flag group by setting values at specific indexes.
     * @param flags The bit flag group to change.
     * @param valuesToSet A bit flag group containing the values to set.
     * @param mask A mask defining the indexes to set. Only indexes at which the mask has a value of `1` (`true`) will
     * be set.
     * @returns The result of changing `flags` using the specified values and indexes.
     */
    static set(flags: number, valuesToSet: number, mask: number): number;
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags: number, conditions: number): boolean;
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags: number, conditions: number): boolean;
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags: number, callback: (value: boolean, index: number, flags: number) => void, valueFilter?: boolean, startIndex?: number, endIndex?: number): void;
}

/**
 * A Subject which provides a {@link NumberUnitInterface} value.
 */
declare class NumberUnitSubject<F extends string, U extends Unit<F> = Unit<F>> extends AbstractSubscribable<NumberUnitInterface<F, U>> implements MutableSubscribable<NumberUnitInterface<F, U>>, MutableSubscribable<NumberUnitInterface<F, U>, number> {
    private readonly value;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     */
    static create<F extends string, U extends Unit<F>>(initialVal: NumberUnit<F, U>): NumberUnitSubject<F, U>;
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     * @deprecated Use `NumberUnitSubject.create()` instead.
     */
    static createFromNumberUnit<F extends string, U extends Unit<F>>(initialVal: NumberUnit<F, U>): NumberUnitSubject<F, U>;
    /** @inheritdoc */
    get(): NumberUnitInterface<F, U>;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: NumberUnitInterface<F>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The numeric part of the new value.
     * @param unit The unit type of the new value. Defaults to the unit type of the NumberUnit used to create this
     * subject.
     */
    set(value: number, unit?: Unit<F>): void;
}

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
declare abstract class AbstractSubscribableArray<T> implements SubscribableArray<T> {
    /** @inheritdoc */
    abstract readonly length: number;
    protected subs: HandlerSubscription<SubscribableArrayHandler<T>>[];
    protected notifyDepth: number;
    /** A function which sends initial notifications to subscriptions. */
    protected readonly initialNotifyFunc: (sub: HandlerSubscription<SubscribableArrayHandler<T>>) => void;
    /** A function which responds to when a subscription to this subscribable is destroyed. */
    protected readonly onSubDestroyedFunc: (sub: HandlerSubscription<SubscribableArrayHandler<T>>) => void;
    /** @inheritdoc */
    sub(handler: SubscribableArrayHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: SubscribableArrayHandler<T>): void;
    /** @inheritdoc */
    abstract getArray(): readonly T[];
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index: number): T;
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index: number): T | undefined;
    /**
     * Notifies subscriptions of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     */
    protected notify(index: number, type: SubscribableArrayEventType, modifiedItem?: T | readonly T[]): void;
    /**
     * Notifies a subscription of this array's current state.
     * @param sub The subscription to notify.
     */
    protected initialNotify(sub: HandlerSubscription<SubscribableArrayHandler<T>>): void;
    /**
     * Responds to when a subscription to this array is destroyed.
     * @param sub The destroyed subscription.
     */
    protected onSubDestroyed(sub: HandlerSubscription<SubscribableArrayHandler<T>>): void;
}

/**
 * A type which contains the `length` property of a tuple.
 */
declare type TupleLength$1<T extends readonly any[]> = {
    length: T['length'];
};
/**
 * A type which maps a tuple of input types to a tuple of subscribables that provide the input types.
 */
declare type MappedSubscribableInputs<Types extends readonly any[]> = {
    [Index in keyof Types]: Subscribable<Types[Index]>;
} & TupleLength$1<Types>;
/**
 * A subscribable subject that is a mapped stream from one or more input subscribables.
 */
declare class MappedSubject<I extends any[], T> extends AbstractSubscribable<T> implements MappedSubscribable<T> {
    private readonly mapFunc;
    private readonly equalityFunc;
    private static readonly IDENTITY_MAP;
    private static readonly NEVER_EQUALS;
    readonly isSubscribable = true;
    private readonly inputs;
    private readonly inputValues;
    private readonly inputSubs;
    private readonly mutateFunc;
    private value;
    private _isAlive;
    /** @inheritdoc */
    get isAlive(): boolean;
    private _isPaused;
    /** @inheritdoc */
    get isPaused(): boolean;
    /**
     * Creates a new MappedSubject.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    private constructor();
    /**
     * Creates a new mapped subject whose state is a combined tuple of an arbitrary number of input values.
     * @param inputs The subscribables which provide the inputs to the new subject.
     * @returns A new subject whose state is a combined tuple of the specified input values.
     */
    static create<I extends any[]>(...inputs: MappedSubscribableInputs<I>): MappedSubject<I, Readonly<I>>;
    /**
     * Creates a new mapped subject. Values are compared for equality using the strict equality comparison (`===`).
     * @param mapFunc The function to use to map inputs to the new subject value.
     * @param inputs The subscribables which provide the inputs to the new subject.
     */
    static create<I extends any[], T>(mapFunc: (inputs: Readonly<I>, previousVal?: T) => T, ...inputs: MappedSubscribableInputs<I>): MappedSubject<I, T>;
    /**
     * Creates a new mapped subject. Values are compared for equality using a custom function.
     * @param mapFunc The function to use to map inputs to the new subject value.
     * @param equalityFunc The function which the new subject uses to check for equality between values.
     * @param inputs The subscribables which provide the inputs to the new subject.
     */
    static create<I extends any[], T>(mapFunc: (inputs: Readonly<I>, previousVal?: T) => T, equalityFunc: (a: T, b: T) => boolean, ...inputs: MappedSubscribableInputs<I>): MappedSubject<I, T>;
    /**
     * Creates a new mapped subject with a persistent, cached value which is mutated when it changes. Values are
     * compared for equality using a custom function.
     * @param mapFunc The function to use to map inputs to the new subject value.
     * @param equalityFunc The function which the new subject uses to check for equality between values.
     * @param mutateFunc The function to use to change the value of the new subject.
     * @param initialVal The initial value of the new subject.
     * @param inputs The subscribables which provide the inputs to the new subject.
     */
    static create<I extends any[], T>(mapFunc: (inputs: Readonly<I>, previousVal?: T) => T, equalityFunc: (a: T, b: T) => boolean, mutateFunc: (oldVal: T, newVal: T) => void, initialVal: T, ...inputs: MappedSubscribableInputs<I>): MappedSubject<I, T>;
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     */
    private updateValue;
    /** @inheritdoc */
    get(): T;
    /** @inheritdoc */
    pause(): this;
    /** @inheritdoc */
    resume(): this;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
declare abstract class AbstractSubscribableSet<T> implements SubscribableSet<T>, Subscribable<ReadonlySet<T>> {
    readonly isSubscribable = true;
    readonly isSubscribableSet = true;
    /** @inheritdoc */
    get size(): number;
    protected subs: HandlerSubscription<SubscribableSetHandler<T>>[];
    protected notifyDepth: number;
    /** A function which sends initial notifications to subscriptions. */
    protected readonly initialNotifyFunc: (sub: HandlerSubscription<SubscribableSetHandler<T>>) => void;
    /** A function which responds to when a subscription to this subscribable is destroyed. */
    protected readonly onSubDestroyedFunc: (sub: HandlerSubscription<SubscribableSetHandler<T>>) => void;
    /** @inheritdoc */
    abstract get(): ReadonlySet<T>;
    /** @inheritdoc */
    has(key: T): boolean;
    /** @inheritdoc */
    sub(handler: SubscribableSetHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: SubscribableSetHandler<T>): void;
    /**
     * Notifies subscriptions of a change in this set.
     * @param type The type of change.
     * @param key The key related to the change.
     */
    protected notify(type: SubscribableSetEventType, key: T): void;
    /**
     * Notifies a subscription of this set's current state.
     * @param sub The subscription to notify.
     */
    protected initialNotify(sub: HandlerSubscription<SubscribableSetHandler<T>>): void;
    /**
     * Responds to when a subscription to this set is destroyed.
     * @param sub The destroyed subscription.
     */
    protected onSubDestroyed(sub: HandlerSubscription<SubscribableSetHandler<T>>): void;
    /**
     * Maps this subscribable to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: ReadonlySet<T>, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubject<[ReadonlySet<T>], M>;
    /**
     * Maps this subscribable to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: ReadonlySet<T>, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubject<[ReadonlySet<T>], M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, ReadonlySet<T>>, paused?: boolean): Subscription;
    /**
     * Subscribes to and pipes mapped inputs from another subscribable. Whenever an update of the other subscribable's
     * state is received through the subscription, it will be transformed by the specified mapping function, and the
     * transformed state will be used as an input to change this subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (fromVal: ReadonlySet<T>, toVal: M) => M, paused?: boolean): Subscription;
    /**
     * Subscribes to and pipes this set's state to a mutable subscribable set. Whenever a key added or removed event is
     * received through the subscription, the same key will be added to or removed from the other set.
     * @param to The mutable subscribable set to which to pipe this set's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribableSet<T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this set's state and pipes a mapped version to a mutable subscribable set. Whenever a key added
     * event is received through the subscription, the key will be transformed by the specified mapping
     * function, and the transformed key will be added to the other set. Whenever a key removed event is received, the
     * transformed key is removed from the other set if and only if no remaining key in this set maps to the same
     * transformed key.
     * @param to The mutable subscribable to which to pipe this set's mapped state.
     * @param map The function to use to transform keys.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribableSet<M>, map: (fromKey: T) => M, paused?: boolean): Subscription;
}

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
declare class ArraySubject<T> extends AbstractSubscribableArray<T> {
    private array;
    /** The length of this array. */
    get length(): number;
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    private constructor();
    /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create<AT>(arr?: AT[]): ArraySubject<AT>;
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item: T, index?: number): void;
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index: number | undefined, arr: readonly T[]): void;
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index: number): void;
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item: T): boolean;
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr: readonly T[]): void;
    /**
     * Clears all data in the array.
     */
    clear(): void;
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray(): readonly T[];
}

/**
 * A type which contains the `length` property of a tuple.
 */
declare type TupleLength<T extends readonly any[]> = {
    length: T['length'];
};
/**
 * A type which maps a tuple of input types to a tuple of subscribables that provide the input types.
 */
declare type CombinedSubscribableInputs<Types extends readonly any[]> = {
    [Index in keyof Types]: Subscribable<Types[Index]>;
} & TupleLength<Types>;
/**
 * A subscribable subject whose state is a combined tuple of an arbitrary number of values.
 * @deprecated This class has been deprecated in favor of using `MappedSubject` without an explicit mapping function.
 */
declare class CombinedSubject<I extends any[]> extends AbstractSubscribable<Readonly<I>> implements MappedSubscribable<Readonly<I>> {
    private readonly inputs;
    private readonly inputValues;
    private readonly inputSubs;
    private _isAlive;
    /** @inheritdoc */
    get isAlive(): boolean;
    private _isPaused;
    /** @inheritdoc */
    get isPaused(): boolean;
    /**
     * Constructor.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    private constructor();
    /**
     * Creates a new subject whose state is a combined tuple of an arbitrary number of input values.
     * @param inputs The subscribables which provide the inputs to the new subject.
     * @returns A new subject whose state is a combined tuple of the specified input values.
     */
    static create<I extends any[]>(...inputs: CombinedSubscribableInputs<I>): CombinedSubject<I>;
    /** @inheritdoc */
    get(): Readonly<I>;
    /** @inheritdoc */
    pause(): this;
    /** @inheritdoc */
    resume(): this;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A class for subjects that return a computed value.
 * @class ComputedSubject
 * @template I The type of the input value.
 * @template T The type of the computed output value.
 */
declare class ComputedSubject<I, T> implements MutableSubscribable<T, I> {
    private readonly computeFn;
    readonly isSubscribable = true;
    readonly isMutableSubscribable = true;
    private value;
    private rawValue;
    private subs;
    private notifyDepth;
    private readonly initialNotifyFunc;
    private readonly onSubDestroyedFunc;
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    private constructor();
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create<IT, CT>(v: IT, fn: (v: IT) => CT): ComputedSubject<IT, CT>;
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value: I): void;
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get(): T;
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw(): I;
    /** @inheritdoc */
    sub(handler: (v: T, rv: I) => void, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: (v: T, rv: I) => void): void;
    /**
     * Notifies subscriptions that this subject's value has changed.
     */
    private notify;
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    private notifySubscription;
    /**
     * Responds to when a subscription to this subject is destroyed.
     * @param sub The destroyed subscription.
     */
    private onSubDestroyed;
    /**
     * Maps this subject to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubject<[T], M>;
    /**
     * Maps this subject to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubject<[T], M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this subscribable's state and pipes a mapped version to a mutable subscribable. Whenever an update
     * of this subscribable's state is received through the subscription, it will be transformed by the specified mapping
     * function, and the transformed state will be used as an input to change the other subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (fromVal: T, toVal: M) => M, paused?: boolean): Subscription;
}

/**
 * A function which handles changes in an {@link ObjectSubject}'s state.
 */
declare type ObjectSubjectHandler<T extends Record<string, any>> = (v: Readonly<T>, key: keyof T, newValue: T[keyof T], oldValue: T[keyof T]) => void;
/**
 * A object-valued subscribable subject which supports setting individual properties on the object and notifying
 * subscribers of any changes to those properties.
 */
declare class ObjectSubject<T extends Record<string, any>> implements MutableSubscribable<Readonly<T>, Partial<Readonly<T>>> {
    private readonly obj;
    readonly isSubscribable = true;
    readonly isMutableSubscribable = true;
    private subs;
    private notifyDepth;
    private readonly initialNotifyFunc;
    private readonly onSubDestroyedFunc;
    /**
     * Constructs an observable object Subject.
     * @param obj The initial object.
     */
    private constructor();
    /**
     * Creates and returns a new ObjectSubject.
     * @param v The initial value of the subject.
     * @returns An ObjectSubject instance.
     */
    static create<T extends Record<string, any>>(v: T): ObjectSubject<T>;
    /**
     * Gets this subject's object.
     * @returns This subject's object.
     */
    get(): Readonly<T>;
    /** @inheritdoc */
    sub(handler: ObjectSubjectHandler<T>, initialNotify?: boolean, paused?: boolean): Subscription;
    /** @inheritdoc */
    unsub(handler: ObjectSubjectHandler<T>): void;
    /**
     * Sets the values of a subset of the properties of this subject's object and notifies subscribers if any of the
     * values changed.
     * @param value An object defining the values of the properties to set.
     */
    set(value: Partial<Readonly<T>>): void;
    /**
     * Sets the value of one of the properties of this subject's object and notifies subscribers if the value changed.
     * @param key The property to set.
     * @param value The new value.
     */
    set<K extends keyof T>(key: K, value: T[K]): void;
    /**
     * Notifies subscriptions that one of the properties of this subject's object has changed.
     * @param key The property of the object that changed.
     * @param oldValue The old value of the property that changed.
     */
    private notify;
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    private initialNotify;
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    private onSubDestroyed;
    /**
     * Maps this subject to a new subscribable.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values. Defaults to the strict
     * equality comparison (`===`).
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: T, previousVal?: M) => M, equalityFunc?: ((a: M, b: M) => boolean)): MappedSubject<[T], M>;
    /**
     * Maps this subject to a new subscribable with a persistent, cached value which is mutated when it changes.
     * @param fn The function to use to map to the new subscribable.
     * @param equalityFunc The function to use to check for equality between mapped values.
     * @param mutateFunc The function to use to change the value of the mapped subscribable.
     * @param initialVal The initial value of the mapped subscribable.
     * @returns The mapped subscribable.
     */
    map<M>(fn: (input: Readonly<T>, previousVal?: M) => M, equalityFunc: ((a: M, b: M) => boolean), mutateFunc: ((oldVal: M, newVal: M) => void), initialVal: M): MappedSubject<[Readonly<T>], M>;
    /**
     * Subscribes to and pipes this subscribable's state to a mutable subscribable. Whenever an update of this
     * subscribable's state is received through the subscription, it will be used as an input to change the other
     * subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's state.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe(to: MutableSubscribable<any, T>, paused?: boolean): Subscription;
    /**
     * Subscribes to this subscribable's state and pipes a mapped version to a mutable subscribable. Whenever an update
     * of this subscribable's state is received through the subscription, it will be transformed by the specified mapping
     * function, and the transformed state will be used as an input to change the other subscribable's state.
     * @param to The mutable subscribable to which to pipe this subscribable's mapped state.
     * @param map The function to use to transform inputs.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    pipe<M>(to: MutableSubscribable<any, M>, map: (fromVal: T, toVal: M) => M, paused?: boolean): Subscription;
}

/**
 * A subscribable set whose keys can be freely added and removed.
 */
declare class SetSubject<T> extends AbstractSubscribableSet<T> implements MutableSubscribable<ReadonlySet<T>>, MutableSubscribableSet<T> {
    readonly isMutableSubscribable = true;
    readonly isMutableSubscribableSet = true;
    private readonly backingSet;
    /**
     * Constructor.
     * @param initialKeys The keys with which to initialize this set. If not defined, this set will be initialized to the
     * empty set.
     */
    private constructor();
    /**
     * Creates and returns a new SetSubject.
     * @param initialKeys The keys initially contained in the new set. If not undefined, the new set will be initialized
     * to the empty set.
     * @returns A new SetSubject instance.
     */
    static create<T>(initialKeys?: Iterable<T>): SetSubject<T>;
    /** @inheritdoc */
    get(): ReadonlySet<T>;
    /**
     * Sets the keys contained in this set.
     * @param keys The keys to set.
     */
    set(keys: Iterable<T>): void;
    /** @inheritdoc */
    add(key: T): this;
    /** @inheritdoc */
    delete(key: T): boolean;
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key: T): boolean;
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @param force The state of the key to force. If `true`, the key will be added to this set. If `false`, the key will
     * be removed from this set.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key: T, force: boolean): boolean;
    /**
     * Removes all keys from this set.
     */
    clear(): void;
}

/**
 * An event to which handlers can be subscribed to be notified whenever the event is emitted.
 */
declare type ReadonlySubEvent<SenderType, DataType> = Omit<SubEventInterface<SenderType, DataType>, 'notify' | 'clear'>;
/**
 * An event which can be emitted with optional data to subscribers.
 */
interface SubEventInterface<SenderType, DataType> {
    /**
     * Subscribes to this event.
     * @param handler A function to be called when an event is emitted.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(handler: (sender: SenderType, data: DataType) => void, paused?: boolean): Subscription;
    /**
     * Unsubscribes a callback function from this event.
     * @param handler The function to unsubscribe.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(handler: (sender: SenderType, data: DataType) => void): void;
    /**
     * Clears all subscriptions to this event.
     */
    clear(): void;
    /**
     * Emits an event to subscribers.
     * @param sender The source of the event.
     * @param data Data associated with the event.
     */
    notify(sender: SenderType, data: DataType): void;
}
/**
 * An implementation of {@link SubEventInterface}.
 */
declare class SubEvent<SenderType, DataType> implements SubEventInterface<SenderType, DataType> {
    private subs;
    private notifyDepth;
    private readonly onSubDestroyedFunc;
    /** @inheritdoc */
    on(handler: (sender: SenderType, data: DataType) => void, paused?: boolean): Subscription;
    /** @inheritdoc */
    off(handler: (sender: SenderType, data: DataType) => void): void;
    /** @inheritdoc */
    clear(): void;
    /** @inheritdoc */
    notify(sender: SenderType, data: DataType): void;
    /**
     * Responds to when a subscription to this event is destroyed.
     * @param sub The destroyed subscription.
     */
    private onSubDestroyed;
}

/**
 * Utility class for generating common functions for mapping subscribables.
 */
declare class SubscribableMapFunctions {
    /**
     * Generates a function which maps an input to itself.
     * @returns A function which maps an input to itself.
     */
    static identity<T>(): (input: T) => T;
    /**
     * Generates a function which maps an input boolean to its negation.
     * @returns A function which maps an input boolean to its negation.
     */
    static not<T extends boolean>(): (input: T, currentVal?: T) => boolean;
    /**
     * Generates a function which maps an input number to its negation.
     * @returns A function which maps an input number to its negation.
     */
    static negate<T extends number>(): (input: T, currentVal?: T) => number;
    /**
     * Generates a function which maps an input number to its absolute value.
     * @returns A function which maps an input number to its absolute value.
     */
    static abs<T extends number>(): (input: T, currentVal?: T) => number;
    /**
     * Generates a function which maps an input number to a rounded version of itself at a certain precision.
     * @param precision The precision to which to round the input.
     * @returns A function which maps an input number to a rounded version of itself at the specified precision.
     */
    static withPrecision<T extends number>(precision: number | Subscribable<number>): (input: T, currentVal?: T) => number;
    /**
     * Generates a function which maps an input number to itself if and only if it differs from the previous mapped value
     * by a certain amount, and to the previous mapped value otherwise.
     * @param threshold The minimum difference between the input and the previous mapped value required to map the input
     * to itself.
     * @returns A function which maps an input number to itself if and only if it differs from the previous mapped value
     * by the specified amount, and to the previous mapped value otherwise.
     */
    static changedBy<T extends number>(threshold: number | Subscribable<number>): (input: T, currentVal?: T) => number;
    /**
     * Generates a function which maps an input number to itself up to a maximum frequency, and to the previous mapped
     * value otherwise.
     * @param freq The maximum frequency at which to map the input to itself, in hertz.
     * @param timeFunc A function which gets the current time in milliseconds. Defaults to `Date.now()`.
     * @returns A function which maps an input number to itself up to the specified maximum frequency, and to the
     * previous mapped value otherwise.
     */
    static atFrequency<T>(freq: number | Subscribable<number>, timeFunc?: () => number): (input: T, currentVal?: T) => T;
}

/**
 * A pipe from an input subscribable to an output mutable subscribable. Each notification received by the pipe is used
 * to change the state of the output subscribable.
 */
declare class SubscribablePipe<I, O, HandlerType extends (...args: any[]) => void> extends HandlerSubscription<HandlerType> {
    /**
     * Constructor.
     * @param from The input subscribable.
     * @param to The output mutable subscribable.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(from: Subscribable<I>, to: MutableSubscribable<any, I>, onDestroy: (sub: SubscribablePipe<I, O, HandlerType>) => void);
    /**
     * Constructor.
     * @param from The input subscribable.
     * @param to The output mutable subscribable.
     * @param map A function which transforms this pipe's inputs.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(from: Subscribable<I>, to: MutableSubscribable<any, O>, map: (fromVal: I, toVal: O) => O, onDestroy: (sub: SubscribablePipe<I, O, HandlerType>) => void);
}

/**
 * A pipe from an input subscribable set to an output mutable subscribable set. Each key added/removed notification
 * received by the pipe is used to add/remove keys to/from the output set.
 */
declare class SubscribableSetPipe<I, O, HandlerType extends (set: ReadonlySet<I>, type: SubscribableSetEventType, key: I, ...args: any[]) => void> extends HandlerSubscription<HandlerType> {
    /**
     * Constructor.
     * @param from The input subscribable set.
     * @param to The output mutable subscribable set.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(from: SubscribableSet<I>, to: MutableSubscribableSet<I>, onDestroy: (sub: SubscribableSetPipe<I, O, HandlerType>) => void);
    /**
     * Constructor.
     * @param from The input subscribable set.
     * @param to The output mutable subscribable set.
     * @param map A function which transforms this pipe's input keys.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(from: SubscribableSet<I>, to: MutableSubscribableSet<O>, map: (from: I) => O, onDestroy: (sub: SubscribableSetPipe<I, O, HandlerType>) => void);
}

/**
 * Utility methods for working with Subscribables.
 */
declare class SubscribableUtils {
    /**
     * A numeric equality function which returns `true` if and only if two numbers are strictly equal or if they are both
     * `NaN`.
     * @param a The first number to compare.
     * @param b The second number to compare.
     * @returns Whether the two numbers are strictly equal or both `NaN`.
     */
    static readonly NUMERIC_NAN_EQUALITY: (a: number, b: number) => boolean;
    /**
     * Checks if a query is a subscribable.
     * @param query A query.
     * @returns Whether the query is a subscribable.
     */
    static isSubscribable<T = any>(query: unknown): query is Subscribable<T>;
    /**
     * Checks if a query is a mutable subscribable.
     * @param query A query.
     * @returns Whether the query is a mutable subscribable.
     */
    static isMutableSubscribable<T = any, I = T>(query: unknown): query is MutableSubscribable<T, I>;
    /**
     * Converts a value to a subscribable.
     *
     * If the `excludeSubscribables` argument is `true` and the value is already a subscribable, then the value is
     * returned unchanged. Otherwise, a new subscribable whose state is always equal to the value will be created and
     * returned.
     * @param value The value to convert to a subscribable.
     * @param excludeSubscribables Whether to return subscribable values as-is instead of wrapping them in another
     * subscribable.
     * @returns A subscribable.
     */
    static toSubscribable<V, Exclude extends boolean>(value: V, excludeSubscribables: Exclude): Exclude extends true ? (V extends Subscribable<any> ? V : Subscribable<V>) : Subscribable<V>;
}

/**
 * Describes a temperature source in the temperature system.
 */
interface TemperatureSource {
    /** The temperature, in degrees Celsius. */
    temperature: number;
    /** The node thermal conductivity, in watts per kelvin.  */
    conductivity: number;
}
/**
 * A closed heat system with temperature sources contributing to a volume.
 */
declare class TemperatureSystem {
    private capacity;
    private readonly sources;
    private readonly _value;
    /**
     * Gets the system's output value.
     * @returns The system's output temperature value, in degrees Celsius.
     */
    get value(): Subscribable<number>;
    /**
     * Creates an instance of a TemperatureSystem.
     * @param capacity The heat capacity of the system, in joules per kelvin.
     */
    constructor(capacity: number);
    /**
     * Directly sets the current temperature value.
     * @param value The temperature value, in degrees Celsius.
     */
    set(value: number): void;
    /**
     * Adds a temperature source.
     * @param source The temperature source.
     * @returns The index of the added temperature source.
     */
    addSource(source: TemperatureSource): number;
    /**
     * Sets the temperature of a temperature source.
     * @param index The index of the source.
     * @param temperature The temperature to set to, in degrees Celsius.
     */
    setSourceTemp(index: number, temperature: number): void;
    /**
     * Sets the conductivity of a temperature source.
     * @param index The index of the source.
     * @param conductivity The conductivity to set to, in watts per meter-kelvin.
     */
    setSourceConductivity(index: number, conductivity: number): void;
    /**
     * Sets the heat capacity of the system.
     * @param capacity The heat capacity of the system, in joules per kelvin.
     */
    setCapacity(capacity: number): void;
    /**
     * Updates the temperature of this system following a period of elapsed time. This method assumes that this system's
     * sources, their temperatures and conductivities, and this system's heat capacity at the time this method is called
     * all remained constant throughout the time elapsed.
     * @param deltaTime The elapsed time, in milliseconds.
     */
    update(deltaTime: number): void;
}

/** A readonly 2D affine transformation. */
declare type ReadonlyTransform2D = Pick<Transform2D, 'getParameters' | 'apply' | 'copy'>;
/**
 * A 2D affine transformation. By default, Transform2D objects are initially created as identity transformations.
 */
declare class Transform2D {
    private readonly array;
    /**
     * Gets the parameters of this transformation as a 6-tuple: `[scaleX, skewX, translateX, skewY, scaleY, translateY]`.
     * @returns The parameters of this transformation.
     */
    getParameters(): ReadonlyFloat64Array;
    /**
     * Sets the parameters of this transformation.
     * @param scaleX The x scaling factor.
     * @param skewX The x skew factor.
     * @param translateX The x translation.
     * @param skewY The y skew factor.
     * @param scaleY The y scaling factor.
     * @param translateY The y translation.
     * @returns This transformation, after it has been changed.
     */
    set(scaleX: number, skewX: number, translateX: number, skewY: number, scaleY: number, translateY: number): this;
    /**
     * Sets the parameters of this transformation from another transformation.
     * @param transform The transformation from which to take parameters.
     */
    set(transform: ReadonlyTransform2D): this;
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value: number): this;
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value: number): this;
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x: number, y: number): this;
    /**
     * Sets the x skew factor of this transformation.
     * @param value The new x skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(value: number): this;
    /**
     * Sets the y skew factor of this transformation.
     * @param value The new y skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(value: number): this;
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value: number): this;
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value: number): this;
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x: number, y: number): this;
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     */
    invert(): this;
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy(): Transform2D;
    /**
     * Applies this transformation to a 2D vector.
     * @param vec A 2D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    private static readonly offsetOriginCache;
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x: number, y: number): this;
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity(): this;
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x: number, y: number): this;
    /**
     * Sets this transformation to a scaling about the origin (0, 0).
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    toScale(x: number, y: number): this;
    /**
     * Sets this transformation to a scaling about an arbitrary origin.
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param originX The x-coordinate of the scaling origin.
     * @param originY The y-coordinate of the scaling origin.
     * @returns This transformation, after it has been changed.
     */
    toScale(x: number, y: number, originX: number, originY: number): this;
    /**
     * Sets this transformation to a rotation about the origin (0, 0).
     * @param theta The rotation angle, in radians.
     * @returns This transformation, after it has been changed.
     */
    toRotation(theta: number): this;
    /**
     * Sets this transformation to a rotation about an arbitrary origin.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotation(theta: number, originX: number, originY: number): this;
    /**
     * Sets this transformation to a reflection across a line passing through the origin (0, 0).
     * @param theta The angle of the reflection line, in radians, with respect to the positive x axis.
     * @returns This transformation, after it has been changed.
     */
    toReflection(theta: number): this;
    /**
     * Sets this transformation to a reflection across a line passing through an arbitrary origin.
     * @param theta The angle of the reflection line, in radians, with respect to the positive x axis.
     * @param originX The x-coordinate of the reflection origin.
     * @param originY The y-coordinate of the reflection origin.
     * @returns This transformation, after it has been changed.
     */
    toReflection(theta: number, originX: number, originY: number): this;
    private static readonly addCache;
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x: number, y: number, order?: 'before' | 'after'): this;
    /**
     * Adds a scaling about the origin (0, 0) to this transformation.
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param order The order in which to add the scaling, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addScale(x: number, y: number, order?: 'before' | 'after'): this;
    /**
     * Adds a scaling about an arbitrary origin to this transformation.
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param originX The x-coordinate of the scaling origin.
     * @param originY The y-coordinate of the scaling origin.
     * @param order The order in which to add the scaling, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addScale(x: number, y: number, originX: number, originY: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about the origin (0, 0) to this transformation.
     * @param theta The rotation angle, in radians.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotation(theta: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about an arbitrary origin to this transformation.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotation(theta: number, originX: number, originY: number, order?: 'before' | 'after'): this;
    /**
     * Adds a reflection across a line passing through the origin (0, 0) to this transformation.
     * @param theta The angle of the reflection line, in radians, with respect to the positive x axis.
     * @param order The order in which to add the reflection, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addReflection(theta: number, order?: 'before' | 'after'): this;
    /**
     * Adds a reflection across a line passing through an arbitrary origin to this transformation.
     * @param theta The angle of the reflection line, in radians, with respect to the positive x axis.
     * @param originX The x-coordinate of the reflection origin.
     * @param originY The y-coordinate of the reflection origin.
     * @param order The order in which to add the reflection, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addReflection(theta: number, originX: number, originY: number, order?: 'before' | 'after'): this;
    private static readonly concatCache;
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat<T extends Transform2D>(out: T, transforms: readonly ReadonlyTransform2D[]): T;
}

/** A readonly 3D affine transformation. */
declare type ReadonlyTransform3D = Pick<Transform3D, 'getParameters' | 'apply' | 'copy'>;
/**
 * A 3D affine transformation. By default, Transform3D objects are initially created as identity transformations.
 */
declare class Transform3D {
    private readonly array;
    /**
     * Gets the parameters of this transformation as a 12-tuple:
     * `[scaleX, skewX(Y), skewX(Z), translateX, skewY(X), scaleY, skewY(Z), translateY, skewZ(X), skewZ(Y), scaleZ, translateZ]`.
     * @returns The parameters of this transformation.
     */
    getParameters(): Readonly<Float64Array>;
    /**
     * Sets the parameters of this transformation.
     * @param scaleX The x scaling factor.
     * @param skewXY The x skew factor along the y axis.
     * @param skewXZ The x skew factor along the z axis.
     * @param translateX The x translation.
     * @param skewYX The y skew factor along the x axis.
     * @param scaleY The y scaling factor.
     * @param skewYZ The y skew factor along the z axis.
     * @param translateY The y translation.
     * @param skewZX The z skew factor along the x axis.
     * @param skewZY The z skew factor along the y axis.
     * @param scaleZ The z scaling factor.
     * @param translateZ The z translation.
     * @returns This transformation, after it has been changed.
     */
    set(scaleX: number, skewXY: number, skewXZ: number, translateX: number, skewYX: number, scaleY: number, skewYZ: number, translateY: number, skewZX: number, skewZY: number, scaleZ: number, translateZ: number): this;
    /**
     * Sets the parameters of this transformation from another transformation.
     * @param transform The transformation from which to take parameters.
     */
    set(transform: ReadonlyTransform3D): this;
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value: number): this;
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value: number): this;
    /**
     * Sets the z scaling factor of this transformation.
     * @param value The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleZ(value: number): this;
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @param z The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x: number, y: number, z: number): this;
    /**
     * Sets the x skew factor of this transformation.
     * @param y The new x skew factor along the y axis.
     * @param z The new x skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(y: number, z: number): this;
    /**
     * Sets the y skew factor of this transformation.
     * @param x The new y skew factor along the x axis.
     * @param z The new y skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(x: number, z: number): this;
    /**
     * Sets the z skew factor of this transformation.
     * @param x The new z skew factor along the x axis.
     * @param y The new z skew factor along the y axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewZ(x: number, y: number): this;
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value: number): this;
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value: number): this;
    /**
     * Sets the z translation of this transformation.
     * @param value The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateZ(value: number): this;
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @param z The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x: number, y: number, z: number): this;
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     * @throws Error if this transformation cannot be inverted.
     */
    invert(): this;
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy(): Transform3D;
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    private static readonly offsetOriginCache;
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @param z The z-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x: number, y: number, z: number): this;
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity(): this;
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x: number, y: number, z: number): this;
    /**
     * Sets this transformation to a scaling about the origin (0, 0, 0).
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param z The z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    toScale(x: number, y: number, z: number): this;
    /**
     * Sets this transformation to a scaling about an arbitrary origin.
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param z The z scaling factor.
     * @param originX The x-coordinate of the scaling origin.
     * @param originY The y-coordinate of the scaling origin.
     * @param originZ The z-coordinate of the scaling origin.
     * @returns This transformation, after it has been changed.
     */
    toScale(x: number, y: number, z: number, originX: number, originY: number, originZ: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the x axis passing through the origin (0, 0, 0).
     * @param theta The rotation angle, in radians.
     * @returns This transformation, after it has been changed.
     */
    toRotationX(theta: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the x axis passing through an arbitrary point.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotationX(theta: number, originX: number, originY: number, originZ: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the y axis passing through the origin (0, 0, 0).
     * @param theta The rotation angle, in radians.
     * @returns This transformation, after it has been changed.
     */
    toRotationY(theta: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the y axis passing through an arbitrary point.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotationY(theta: number, originX: number, originY: number, originZ: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the z axis passing through the origin (0, 0, 0).
     * @param theta The rotation angle, in radians.
     * @returns This transformation, after it has been changed.
     */
    toRotationZ(theta: number): this;
    /**
     * Sets this transformation to a rotation about an axis parallel to the z axis passing through an arbitrary point.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotationZ(theta: number, originX: number, originY: number, originZ: number): this;
    /**
     * Sets this transformation to a rotation about an arbitrary axis passing through the origin (0, 0, 0).
     * @param theta The rotation angle, in radians.
     * @param axisX The x component of the vector defining the direction of the rotation axis.
     * @param axisY The y component of the vector defining the direction of the rotation axis.
     * @param axisZ The z component of the vector defining the direction of the rotation axis.
     * @returns This transformation, after it has been changed.
     */
    toRotation(theta: number, axisX: number, axisY: number, axisZ: number): this;
    /**
     * Sets this transformation to a rotation about an arbitrary axis passing through an arbitrary point.
     * @param theta The rotation angle, in radians.
     * @param axisX The x component of the vector defining the direction of the rotation axis.
     * @param axisY The y component of the vector defining the direction of the rotation axis.
     * @param axisZ The z component of the vector defining the direction of the rotation axis.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @returns This transformation, after it has been changed.
     */
    toRotation(theta: number, axisX: number, axisY: number, axisZ: number, originX: number, originY: number, originZ: number): this;
    private static readonly addCache;
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x: number, y: number, z: number, order?: 'before' | 'after'): this;
    /**
     * Adds a scaling about the origin (0, 0, 0) to this transformation.
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param z The z scaling factor.
     * @param order The order in which to add the scaling, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addScale(x: number, y: number, z: number, order?: 'before' | 'after'): this;
    /**
     * Adds a scaling about an arbitrary origin to this transformation.
     * @param x The x scaling factor.
     * @param y The y scaling factor.
     * @param z The z scaling factor.
     * @param originX The x-coordinate of the scaling origin.
     * @param originY The y-coordinate of the scaling origin.
     * @param originZ The z-coordinate of the scaling origin.
     * @param order The order in which to add the scaling, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addScale(x: number, y: number, z: number, originX: number, originY: number, originZ: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about an axis parallel to the x axis passing through the origin (0, 0, 0) to this transformation.
     * @param theta The rotation angle, in radians.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotationX(theta: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about an axis parallel to the x axis passing through an arbitrary point to this transformation.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotationX(theta: number, originX: number, originY: number, originZ: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about an axis parallel to the y axis passing through the origin (0, 0, 0) to this transformation.
     * @param theta The rotation angle, in radians.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotationY(theta: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about an axis parallel to the y axis passing through an arbitrary point to this transformation.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotationY(theta: number, originX: number, originY: number, originZ: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about an axis parallel to the z axis passing through the origin (0, 0, 0) to this transformation.
     * @param theta The rotation angle, in radians.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotationZ(theta: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about an axis parallel to the z axis passing through an arbitrary point to this transformation.
     * @param theta The rotation angle, in radians.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotationZ(theta: number, originX: number, originY: number, originZ: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about an arbitrary axis passing through the origin (0, 0, 0) to this transformation.
     * @param theta The rotation angle, in radians.
     * @param axisX The x component of the vector defining the direction of the rotation axis.
     * @param axisY The y component of the vector defining the direction of the rotation axis.
     * @param axisZ The z component of the vector defining the direction of the rotation axis.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotation(theta: number, axisX: number, axisY: number, axisZ: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation about an arbitrary axis passing through an arbitrary point to this transformation.
     * @param theta The rotation angle, in radians.
     * @param axisX The x component of the vector defining the direction of the rotation axis.
     * @param axisY The y component of the vector defining the direction of the rotation axis.
     * @param axisZ The z component of the vector defining the direction of the rotation axis.
     * @param originX The x-coordinate of the rotation origin.
     * @param originY The y-coordinate of the rotation origin.
     * @param originZ The z-coordinate of the rotation origin.
     * @param order The order in which to add the rotation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addRotation(theta: number, axisX: number, axisY: number, axisZ: number, originX: number, originY: number, originZ: number, order?: 'before' | 'after'): this;
    private static readonly concatCache;
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat<T extends Transform3D>(out: T, transforms: readonly ReadonlyTransform3D[]): T;
}

/**
 * A readonly perspective transformation.
 */
declare type ReadonlyTransformPerspective = Pick<TransformPerspective, 'getCameraPosition' | 'getCameraRotation' | 'getSurfacePosition' | 'apply' | 'copy'>;
/**
 * A perspective transformation.
 */
declare class TransformPerspective {
    private static readonly vec3Cache;
    private readonly cameraPos;
    private readonly surfacePos;
    private readonly cameraPosTransform;
    private readonly cameraRotationTransform;
    private readonly cameraRotationInverseTransform;
    private readonly allCameraTransforms;
    private readonly fullTransform;
    /**
     * Gets the position of this transformation's camera, as `[x, y, z]` in world coordinates.
     * @returns The position of this transformation's camera, as `[x, y, z]` in world coordinates.
     */
    getCameraPosition(): ReadonlyFloat64Array;
    /**
     * Gets the transformation representing the rotation of this transformation's camera.
     * @returns The transformation representing the rotation of this transformation's camera.
     */
    getCameraRotation(): ReadonlyTransform3D;
    /**
     * Gets the position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns The position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     */
    getSurfacePosition(): ReadonlyFloat64Array;
    /**
     * Sets the parameters of this transformation.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     * @param cameraRotation A transformation representing the rotation of the camera.
     * @param surfacePos The position of the projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns This transformation, after it has been changed.
     */
    set(cameraPos: ReadonlyFloat64Array, cameraRotation: ReadonlyTransform3D, surfacePos: ReadonlyFloat64Array): this;
    /**
     * Sets the parameters of this transformation from another transformation.
     * @param transform The transformation from which to take parameters.
     */
    set(transform: ReadonlyTransformPerspective): this;
    /**
     * Sets the position of this projection's camera. Does not update the full camera transformation.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     */
    private _setCameraPosition;
    /**
     * Sets the rotation of this projection's camera. Does not update the full camera transformation.
     * @param cameraRotation A transformation representing the rotation of the camera.
     */
    _setCameraRotation(cameraRotation: ReadonlyTransform3D): void;
    /**
     * Sets the position of this projection's camera.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     * @returns This transformation, after it has been changed.
     */
    setCameraPosition(cameraPos: ReadonlyFloat64Array): this;
    /**
     * Sets the rotation of this projection's camera.
     * @param cameraRotation A transformation representing the rotation of the camera.
     * @returns This transformation, after it has been changed.
     */
    setCameraRotation(cameraRotation: ReadonlyTransform3D): this;
    /**
     * Sets the position of this transformation's projection surface relative to the camera.
     * @param surfacePos The position of the projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns This transformation, after it has been changed.
     */
    setSurfacePosition(surfacePos: ReadonlyFloat64Array): this;
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy(): TransformPerspective;
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector, in world coordinates.
     * @param out The 2D vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
}

/**
 * A utitlity class for calculating a numerical average of a selected number of samples.
 */
declare class SimpleMovingAverage {
    private samples;
    private _values;
    /**
     * Class to return a numerical average from a specified number of inputs.
     * @param samples is the number of samples.
     */
    constructor(samples: number);
    /**
     * Returns a numerical average of the inputs.
     * @param input is the input number.
     * @returns The numerical average.
     */
    getAverage(input: number): number;
    /**
     * Resets the average.
     */
    reset(): void;
}

/**
 * A utitlity class for basic math.
 */
declare class MathUtils {
    /** Twice the value of pi. */
    static readonly TWO_PI: number;
    /** Half the value of pi. */
    static readonly HALF_PI: number;
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value: number, min: number, max: number): number;
    /**
     * Rounds a number.
     * @param value The number to round.
     * @param precision The precision with which to round. Defaults to `1`.
     * @returns The rounded number.
     */
    static round(value: number, precision?: number): number;
    /**
     * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in radians.
     * @param end The ending angle, in radians.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
     */
    static diffAngle(start: number, end: number, directional?: boolean): number;
    /**
     * Linearly interpolates a keyed value along one dimension.
     * @param x The key of the value to interpolate.
     * @param x0 The key of the first known value.
     * @param x1 The key of the second known value.
     * @param y0 The first known value.
     * @param y1 The second known value.
     * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
     * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
     * @returns The interpolated value corresponding to the specified key.
     */
    static lerp(x: number, x0: number, x1: number, y0: number, y1: number, clampStart?: boolean, clampEnd?: boolean): number;
    /**
     * Linearly interpolates a keyed vector along one dimension. If the known vectors and the result vector have unequal
     * lengths, then only the components shared by all vectors are interpolated in the result.
     * @param out The object to which to write the result.
     * @param x The key of the vector to interpolate.
     * @param x0 The key of the first known vector.
     * @param x1 The key of the second known vector.
     * @param y0 The first known vector.
     * @param y1 The second known vector.
     * @param clampStart Whether to clamp the components of the interpolated vector to those of the first known vector.
     * Defaults to false.
     * @param clampEnd Whether to clamp the components of the interpolated vector to those of the second known vector.
     * Defaults to false.
     * @returns The interpolated vector corresponding to the specified key.
     */
    static lerpVector(out: Float64Array, x: number, x0: number, x1: number, y0: ArrayLike<number>, y1: ArrayLike<number>, clampStart?: boolean, clampEnd?: boolean): Float64Array;
}

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values. When
 * a new raw value is added to the sequence, it and the last smoothed value are weighted according to the time elapsed
 * since the last smoothed value was calculated (i.e. since the last raw value was added) and averaged. The calculation
 * of the weighting is such that the weight of each raw value in the sequence decays exponentially with the "age"
 * (i.e. time elapsed between when that value was added to the sequence and when the latest value was added to the
 * sequence) of the value.
 */
declare class ExpSmoother {
    readonly tau: number;
    readonly dtThreshold: number;
    private lastValue;
    /**
     * Constructor.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect. A value less
     * than or equal to 0 is equivalent to no smoothing.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau: number, initial?: number | null, dtThreshold?: number);
    /**
     * Gets the last smoothed value.
     * @returns The last smoothed value, or null if none exists.
     */
    last(): number | null;
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw: number, dt: number): number;
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    private calculateFactor;
    /**
     * Resets the "history" of this smoother and sets the initial smoothed value to null.
     */
    reset(): null;
    /**
     * Resets the "history" of this smoother and sets the initial smoothed value.
     * @param value The new initial smoothed value.
     * @returns The reset smoothed value.
     */
    reset<T extends number | null>(value: T): T;
    /**
     * Resets the "history" of this smoother and optionally sets the initial smoothed value.
     * @param value The new initial smoothed value. Defaults to null.
     * @returns The reset smoothed value.
     */
    reset(value?: number | null): number | null;
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    private static smooth;
}

/**
 * A calculator for lookahead values based on past trends. The calculator accepts a series of input values separated
 * by discrete time intervals, computes a rate of change at each time step, and uses this rate of change to predict
 * what the input value will be at some arbitrary length of time in the future assuming the rate of change remains
 * constant.
 */
declare class Lookahead {
    lookahead: number;
    private readonly valueSmoother;
    private readonly trendSmoother;
    private lastSmoothedValue;
    private lastTrendValue;
    private lastLookaheadValue;
    private lastSmoothedLookaheadValue;
    /**
     * Constructor.
     * @param lookahead This calculator's lookahead time.
     * @param valueSmoothingTau The smoothing time constant to apply to the calculator's input values before rate of
     * change is computed. A value of `0` is equivalent to no smoothing. Defaults to `0`.
     * @param trendSmoothingTau The smoothing time constant to apply to the calculator's computed trend values. A value
     * of `0` is equivalent to no smoothing. Defaults to `0`.
     */
    constructor(lookahead: number, valueSmoothingTau?: number, trendSmoothingTau?: number);
    /**
     * Gets this calculator's last computed lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param smoothed Whether to retrieve the lookahead value computed using the last smoothed input value instead of
     * the raw input value as the present (`t = 0`) value. Defaults to `false`.
     * @returns This calculator's last computed lookahead value.
     */
    last(smoothed?: boolean): number | null;
    /**
     * Gets this calculator's last computed trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @returns This calculator's last computed trend value.
     */
    lastTrend(): number;
    /**
     * Adds a new input value and gets the next lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @param smoothed Whether to return the lookahead value computed using the smoothed input value instead of the raw
     * input value as the present (`t = 0`) value. Note that this argument does not determine whether smoothing is
     * applied for the purposes of calculating rate of change (smoothing is always applied for this purpose if a positive
     * time constant is defined). Defaults to `false`.
     * @returns The next lookahead value.
     */
    next(value: number, dt: number, smoothed?: boolean): number;
    /**
     * Adds a new input value and gets the next trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @returns The next trend value.
     */
    nextTrend(value: number, dt: number): number;
    /**
     * Resets the "history" of this calculator and sets the initial input value to null.
     */
    reset(): null;
    /**
     * Resets the "history" of this calculator and sets the initial input value.
     * @param value The new initial input value.
     * @returns The reset lookahead value, which will be equal to the initial input value.
     */
    reset<T extends number | null>(value: T): T;
    /**
     * Resets the "history" of this calculator and optionally sets the initial input value.
     * @param value The new initial input value. Defaults to null.
     * @returns The reset lookahead value, which will be equal to the initial input value.
     */
    reset(value?: number | null): number | null;
}

/**
 * A breakpoint for a linearly interpolated N-dimensional lookup table of vectors. The breakpoint value is located at
 * index `0`, followed by the keys for each dimension at indexes `1, 2, ... , N+1`.
 */
declare type LerpVectorLookupTableBreakpoint = [ReadonlyFloat64Array, ...number[]];
/**
 * A linearly interpolated N-dimensional lookup table of vectors.
 */
declare class LerpVectorLookupTable {
    private static readonly BREAKPOINT_COMPARATOR;
    private static readonly tempBreakpoint;
    private readonly _dimensionCount;
    /** The number of dimensions in this table. */
    get dimensionCount(): number;
    private readonly _vectorLength;
    /** The length of the vectors in this table. */
    get vectorLength(): number;
    private readonly table;
    private readonly tempVectors;
    /**
     * Creates a lookup table of a specified dimension.
     * @param dimensionCount The number of dimensions in the new table. Values less than 0 will be clamped to 0.
     * @param vectorLength The length of the interpolated vectors (i.e. the number of components in each vector) in the
     * new table. Values less than 0 will be clamped to 0.
     */
    constructor(dimensionCount: number, vectorLength: number);
    /**
     * Creates a lookup table initialized with an array of breakpoints.
     * @param breakpoints An array of breakpoints with which to initialize the new table. Each breakpoint should be
     * expressed as an array, where the first element represents the breakpoint vector, and the next N elements
     * represent the breakpoint key in each dimension. If not all breakpoint arrays have the same length, the dimension
     * of the table will be set equal to `L - 1`, where `L` is the length of the shortest array. For arrays with length
     * greater than `L`, all keys after index `L - 1` will be ignored. If the table ends up with zero dimensions, it will
     * be initialized to an empty table. Additionally, the table's vector length will be set to the length of the
     * shortest breakpoint vector.
     */
    constructor(breakpoints: readonly Readonly<LerpVectorLookupTableBreakpoint>[]);
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, the breakpoint has fewer dimensions than this table, or the
     * the length of the breakpoint vector is less than this table's vector length property.
     */
    insertBreakpoint(breakpoint: Readonly<LerpVectorLookupTableBreakpoint>): this;
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    private insertBreakpointHelper;
    /**
     * Looks up a vector in this table using a specified key. The returned vector will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param out The vector to which to write the result.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The vector corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a vector could
     * not be retrieved.
     */
    get(out: Float64Array, ...key: number[]): Float64Array;
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @param out The vector to which to write the result.
     * @returns The interpolated value of the key at the specified dimension.
     */
    private lookupHelper;
}

/**
 * A 3D table for intepolating across multiple dimensions.
 */
declare class Table3D {
    private readonly data;
    /**
     * Adds a range of values to the table.
     * @param x The x value for this range of values.
     * @param values The range of values in [y, z]
     */
    addRange(x: number, values: Float64Array[]): void;
    /**
     * Gets the interpolated value from the table given an x and y position.
     * @param x The x position to interpolate for.
     * @param y The y position to interpolate for.
     * @returns The interpolated number.
     */
    getValue(x: number, y: number): number;
    /**
     * Interpolates a range of values given a starting y value.
     * @param y The y value to use.
     * @param range The range of values to interpolate over.
     * @returns A resultant interpolated z value.
     */
    private interpRange;
    /**
     * Interpolates in two dimensions.
     * @param y The input y value.
     * @param y0 The bottom y value for interpolation.
     * @param y1 The top y value for interpolation.
     * @param z0 The bottom z number for interpolation
     * @param z1 The top z number for interpolation.
     * @returns An interpolated z result given the input y.
     */
    private interp2d;
}

/**
 * A visitor function for k-d tree searches.
 * @param element A search result.
 * @param key The key of the search result.
 * @param distance The distance from the search result's key to the query key.
 * @param queryKey The query key.
 * @param queryElement The query element, or undefined if the search was initiated directly from a key.
 * @returns Whether to continue the search.
 */
declare type KdTreeSearchVisitor<T> = (element: T, key: ReadonlyFloat64Array, distance: number, queryKey: ReadonlyFloat64Array, queryElement: T | undefined) => boolean;
/**
 * A filtering function for k-d tree searches.
 * @param element A candidate search result.
 * @param key The key of the candidate search result.
 * @param distance The distance from the candidate search result's key to the query key.
 * @param queryKey The query key.
 * @param queryElement The query element, or undefined if the search was initiated directly from a key.
 * @returns Whether to include the candidate in the final search results.
 */
declare type KdTreeSearchFilter<T> = (element: T, key: ReadonlyFloat64Array, distance: number, queryKey: ReadonlyFloat64Array, queryElement: T | undefined) => boolean;
/**
 * A k-dimensional search tree.
 */
declare class KdTree<T> {
    private readonly keyFunc;
    readonly dimensionCount: number;
    private readonly elements;
    private readonly keys;
    private readonly nodes;
    private minDepth;
    private maxDepth;
    private readonly indexArrays;
    private readonly indexSortFuncs;
    private readonly keyCache;
    /** The number of elements in this tree. */
    get size(): number;
    /**
     * Constructor.
     * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
     * be truncated to one.
     * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
     * the dimension count of this tree.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(dimensionCount: number, keyFunc: (element: T, out: Float64Array) => Float64Array);
    /**
     * Searches this tree for elements whose keys are located near a query key and visits each of them with a function.
     * @param key The query key.
     * @param radius The radius around the query key to search.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    searchKey(key: ReadonlyFloat64Array, radius: number, visitor: KdTreeSearchVisitor<T>): void;
    /**
     * Searches this tree for elements whose keys are located near a query key and returns them in order of increasing
     * distance from the query key.
     * @param key The query key.
     * @param radius The radius around the query key to search.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    searchKey(key: ReadonlyFloat64Array, radius: number, maxResultCount: number, out: T[], filter?: KdTreeSearchFilter<T>): T[];
    /**
     * Searches this tree for elements whose keys are located near the key of a query element and visits each of them
     * with a function.
     * @param element The query element.
     * @param radius The radius around the query element's key to search.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    search(element: T, radius: number, visitor: KdTreeSearchVisitor<T>): void;
    /**
     * Searches this tree for elements whose keys are located near the key of a query element and returns them in order
     * of increasing distance from the query key.
     * @param element The query element.
     * @param radius The radius around the query key to search.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    search(element: T, radius: number, maxResultCount: number, out: T[], filter?: KdTreeSearchFilter<T>): T[];
    /**
     * Performs a tree search with a visitor function.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    private doVisitorSearch;
    /**
     * Performs a tree search and returns an array of search results.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    private doResultsSearch;
    /**
     * Searches a subtree for elements whose keys are located near a query key.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param nodeIndex The index of the root of the subtree to search.
     * @param pivotDimension The dimension in which the root of the subtree is split.
     * @param resultHandler A function which will be called once per element found within the search radius. If the
     * function returns `true`, then the search will continue; if the function returns `false`, the search will
     * immediately halt.
     * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
     * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
     * child.
     * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
     */
    private searchTree;
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element: T): void;
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements: Iterable<T>): void;
    /**
     * Inserts an element into this tree.
     * @param element The element to insert.
     * @returns The depth at which the element was inserted, with 0 being the depth of the root.
     */
    private insertElementInTree;
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element: T): boolean;
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements: Iterable<T>): boolean;
    /**
     * Removes an element and all references to it from this tree's arrays. This method does not change the structure
     * of this tree to reflect the removal of the element.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    private removeElementFromArrays;
    /**
     * Resets this tree's index arrays such that each array contains the indexes 0 to N-1 in order, where N is the
     * number of elements in the tree.
     */
    private resetIndexArrays;
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove: Iterable<T>, toInsert: Iterable<T>): void;
    /**
     * Rebuilds and balances this tree.
     */
    rebuild(): void;
    /**
     * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
     * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
     * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
     * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
     * 0 when reaching `this.dimensionCount`).
     * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
     * pivot key will be placed at this node.
     * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
     * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
     * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
     */
    private buildSubTree;
    /**
     * Removes all elements from this tree.
     */
    clear(): void;
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    private static parent;
    /**
     * Finds the index of a node's lesser child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's lesser child.
     */
    private static lesser;
    /**
     * Finds the index of a node's greater child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's greater child.
     */
    private static greater;
    /**
     * Finds the least index of any node located at a given depth.
     * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
     * @returns The least index of any node located at the specified depth.
     */
    private static leastIndexAtDepth;
    /**
     * Finds the depth at which a node lies.
     * @param index The index of the node for which to find the depth.
     * @returns The depth at which the node lies. The root of the tree lies at depth 0.
     */
    private static depth;
    /**
     * Calculates the Euclidean distance between two keys.
     * @param key1 The first key.
     * @param key2 The second key.
     * @param dimensionCount The number of dimensions in which to calculate the distance.
     * @returns The Euclidean distance between the two keys.
     */
    private static distance;
}

/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
declare class MagVar {
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth. Positive values signify eastward
     * deflection, and negative values signify westward deflection.
     * @param lat The latitude of the query point.
     * @param lon The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static get(lat: number, lon: number): number;
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth. Positive values signify eastward
     * deflection, and negative values signify westward deflection.
     * @param point The query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static get(point: LatLonInterface): number;
    /**
     * Converts magnetic bearing to true bearing at a specific point on Earth.
     * @param bearing A magnetic bearing.
     * @param lat The latitude of the query point.
     * @param lon The longitude of the query point.
     * @returns The true bearing equivalent of the given magnetic bearing at the specified point.
     */
    static magneticToTrue(bearing: number, lat: number, lon: number): number;
    /**
     * Converts magnetic bearing to true bearing at a specific point on Earth.
     * @param bearing A magnetic bearing.
     * @param point The query point.
     * @returns The true bearing equivalent of the given magnetic bearing at the specified point.
     */
    static magneticToTrue(bearing: number, point: LatLonInterface): number;
    /**
     * Converts magnetic bearing to true bearing given a specific magnetic variation (magnetic declination).
     * @param bearing A magnetic bearing.
     * @param magVar The magnetic variation.
     * @returns The true bearing equivalent of the given magnetic bearing.
     */
    static magneticToTrue(bearing: number, magVar: number): number;
    /**
     * Converts true bearing to magnetic bearing at a specific point on Earth.
     * @param bearing A true bearing.
     * @param lat The latitude of the query point.
     * @param lon The longitude of the query point.
     * @returns The magnetic bearing equivalent of the given true bearing at the specified point.
     */
    static trueToMagnetic(bearing: number, lat: number, lon: number): number;
    /**
     * Converts true bearing to magnetic bearing at a specific point on Earth.
     * @param bearing A true bearing.
     * @param point The query point.
     * @returns The magnetic bearing equivalent of the given true bearing at the specified point.
     */
    static trueToMagnetic(bearing: number, point: LatLonInterface): number;
    /**
     * Converts true bearing to magnetic bearing given a specific magnetic variation (magnetic declination).
     * @param bearing A true bearing.
     * @param magVar The magnetic variation.
     * @returns The magnetic bearing equivalent of the given true bearing.
     */
    static trueToMagnetic(bearing: number, magVar: number): number;
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    private static getMagVar;
}

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
declare class GeoCircle {
    static readonly ANGULAR_TOLERANCE = 1e-7;
    private static readonly NORTH_POLE;
    private static readonly tempGeoPoint;
    private static readonly vec3Cache;
    private static readonly intersectionCache;
    private _center;
    private _radius;
    private _sinRadius;
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center: ReadonlyFloat64Array, radius: number);
    /**
     * The center of this circle.
     */
    get center(): ReadonlyFloat64Array;
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius(): number;
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle(): boolean;
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns The length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle: number): number;
    /**
     * Calculates the central angle which subtends an arc along this circle of given length.
     * @param length An arc length, in great-arc radians.
     * @returns The central angle which subtends an arc along this circle of the given length, in radians.
     */
    angularWidth(length: number): number;
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center: ReadonlyFloat64Array | LatLonInterface, radius: number): this;
    /**
     * Sets this circle to be a great circle which contains two given points. There are two possible great circles that
     * contain any two unique points; these circles differ only by their directionality (equivalently, the sign of their
     * normal vectors). The order of points passed to this method and the right-hand rule determines which of the two is
     * returned.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @returns this circle, after it has been changed.
     */
    setAsGreatCircle(point1: ReadonlyFloat64Array | LatLonInterface, point2: ReadonlyFloat64Array | LatLonInterface): this;
    /**
     * Sets this circle to be a great circle defined by a point and bearing offset, equivalent to the path projected from
     * the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @returns this circle, after it has been changed.
     */
    setAsGreatCircle(point: ReadonlyFloat64Array | LatLonInterface, bearing: number): this;
    /**
     * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
     * complement with `Math.PI`.
     * @returns This circle, after it has been reversed.
     */
    reverse(): this;
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    private distanceToCenter;
    /**
     * Finds the closest point on this circle to a specified point. In other words, projects the specified point onto
     * this circle. If the specified point is equidistant from all points on this circle (i.e. it is coincident with or
     * antipodal to this circle's center), NaN will be written to all fields of the result.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param out A Float64Array object to which to write the result.
     * @returns The closest point on this circle to the specified point.
     */
    closest(point: ReadonlyFloat64Array | LatLonInterface, out: Float64Array): Float64Array;
    /**
     * Finds the closest point on this circle to a specified point. In other words, projects the specified point onto
     * this circle. If the specified point is equidistant from all points on this circle (i.e. it is coincident with or
     * antipodal to this circle's center), NaN will be written to all fields of the result.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param out A GeoPoint object to which to write the result.
     * @returns The closest point on this circle to the specified point.
     */
    closest(point: ReadonlyFloat64Array | LatLonInterface, out: GeoPoint): GeoPoint;
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point: ReadonlyFloat64Array | LatLonInterface): number;
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point: ReadonlyFloat64Array | LatLonInterface, tolerance?: number): boolean;
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point: ReadonlyFloat64Array | LatLonInterface, inclusive?: boolean, tolerance?: number): boolean;
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The angular tolerance for considering the start and end points to be equal, in radians.
     * If the absolute (direction-agnostic) angular distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, tolerance?: number, equalityTolerance?: number): number;
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The tolerance for considering the start and end points to be equal, in great-arc radians.
     * If the absolute (direction-agnostic) along-arc distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, tolerance?: number, equalityTolerance?: number): number;
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point: ReadonlyFloat64Array | LatLonInterface, tolerance?: number): number;
    /**
     * Offsets a point on this circle by a specified distance. The direction of the offset for positive distances is
     * counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param distance The distance by which to offset, in great-arc radians.
     * @param out A Float64Array object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    offsetDistanceAlong(point: ReadonlyFloat64Array | LatLonInterface, distance: number, out: Float64Array, tolerance?: number): Float64Array;
    /**
     * Offsets a point on this circle by a specified distance. The direction of the offset for positive distances is
     * counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param distance The distance by which to offset, in great-arc radians.
     * @param out A GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    offsetDistanceAlong(point: ReadonlyFloat64Array | LatLonInterface, distance: number, out: GeoPoint, tolerance?: number): GeoPoint;
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    offsetAngleAlong(point: ReadonlyFloat64Array | LatLonInterface, angle: number, out: Float64Array, tolerance?: number): Float64Array;
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    offsetAngleAlong(point: ReadonlyFloat64Array | LatLonInterface, angle: number, out: GeoPoint, tolerance?: number): GeoPoint;
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    private _offsetAngleAlong;
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other: GeoCircle, out: Float64Array[]): number;
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other: GeoCircle, out: GeoPoint[]): number;
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other: GeoCircle, tolerance?: number): number;
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point: LatLonInterface, radius: number): GeoCircle;
    /**
     * Creates a new great circle that contains two points. There are two possible great circles that contain any two
     * unique points; these circles differ only by their directionality (equivalently, the sign of their normal vectors).
     * The order of points passed to this method and the right-hand rule determines which of the two is returned.
     * @param point1 The first point that lies on the new great circle.
     * @param point2 The second point that lies on the new great circle.
     * @returns a great circle.
     */
    static createGreatCircle(point1: ReadonlyFloat64Array | LatLonInterface, point2: ReadonlyFloat64Array | LatLonInterface): GeoCircle;
    static createGreatCircle(point: ReadonlyFloat64Array | LatLonInterface, bearing: number): GeoCircle;
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point: ReadonlyFloat64Array | LatLonInterface, bearing: number): GeoCircle;
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle. The order of points passed
     * to this method and the right-hand rule determines which of the two possible normal vectors for the great circle is
     * returned.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormal(point1: ReadonlyFloat64Array | LatLonInterface, point2: ReadonlyFloat64Array | LatLonInterface, out: Float64Array): Float64Array;
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormal(point: ReadonlyFloat64Array | LatLonInterface, bearing: number, out: Float64Array): Float64Array;
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    private static _getGreatCircleNormal;
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    private static getGreatCircleNormalFromPoints;
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    private static getGreatCircleNormalFromPointBearing;
}

/**
 * A Subject which provides a {@link GeoPointInterface} value.
 */
declare class GeoPointSubject extends AbstractSubscribable<GeoPointInterface> implements MutableSubscribable<GeoPointInterface, LatLonInterface> {
    private readonly value;
    private readonly tolerance?;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     * @param tolerance The tolerance of this subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     */
    private constructor();
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @param tolerance The tolerance of the subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     * @returns A GeoPointSubject.
     */
    static create(initialVal: GeoPoint, tolerance?: number): GeoPointSubject;
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns A GeoPointSubject.
     * @deprecated Use `GeoPointSubject.create()` instead.
     */
    static createFromGeoPoint(initialVal: GeoPoint): GeoPointSubject;
    /** @inheritdoc */
    get(): GeoPointInterface;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: LatLonInterface): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param lat The latitude of the new value.
     * @param lon The longitude of the new value.
     */
    set(lat: number, lon: number): void;
}

/**
 * A geographic projection.
 */
interface GeoProjection {
    /**
     * Gets the geographic center of this projection.
     * @returns The geographic center of this projection.
     */
    getCenter(): GeoPointReadOnly;
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor(): number;
    /**
     * Gets the pre-projection (spherical) rotation of this projection as a vector `[lambda, phi, gamma]`. The rotation
     * angles are expressed in radians. The full rotation is an intrinsic rotation with angles applied in the order
     * `lambda, phi, gamma`. The rotation uses the standard geographic cartesian coordinate system, a right-handed
     * coordinate system with the origin at the center of the earth, the positive x axis passing through 0 degrees N,
     * 0 degrees E, and the positive z axis passing through the North Pole.
     * * `lambda`: Intrinsic rotation angle about the z axis. Positive rotation is in the counterclockwise direction when
     * looking down from above the axis.
     * * `phi`: Intrinsic rotation angle about the y axis. Positive rotation is in the clockwise direction when looking
     * down from above the axis.
     * * `gamma`: Intrinsic rotation angle about the x axis. Positive rotation is in the counterclockwise direction when
     * looking down from above the axis.
     * @returns The pre-projection rotation of this projection.
     */
    getPreRotation(): ReadonlyFloat64Array;
    /**
     * Gets the post-projection (planar) translation of this projection, in pixels.
     * @returns The post-projection translation of this projection.
     */
    getTranslation(): ReadonlyFloat64Array;
    /**
     * Gets the post-projection (planar) rotation angle of this projection in radians.
     * @returns The post-projection rotation angle of this projection.
     */
    getPostRotation(): number;
    /**
     * Checks whether this projection reflects the projected coordinate system across the x-axis.
     * @returns Whether this projection reflects the projected coordinate system across the x-axis.
     */
    getReflectY(): boolean;
    /**
     * Projects a set of lat/lon coordinates.
     * @param point The point to project, as either a {@link LatLonInterface} or a `[lon, lat]` array.
     * @param out The vector to which to write the result.
     * @returns The projected point, as a vector.
     */
    project(point: LatLonInterface | ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec The 2D position vector describing the location of the projected coordinates.
     * @param out The point to which to write the result.
     * @returns the inverted point.
     */
    invert<T extends GeoPoint | Float64Array>(vec: ReadonlyFloat64Array, out: T): T;
}
/**
 * A mutable geographic projection.
 */
interface MutableGeoProjection extends GeoProjection {
    /**
     * Sets the geographic center of this projection. The center point of the projection is projected to the origin,
     * before any post-projection transformations are applied.
     * @param point The new center point.
     * @returns This projection, after it has been changed.
     */
    setCenter(point: LatLonInterface): this;
    /**
     * Sets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @param factor The new nominal scale factor.
     * @returns This projection, after it has been changed.
     */
    setScaleFactor(factor: number): this;
    /**
     * Sets the pre-projection (spherical) rotation of this projection as a vector `[lambda, phi, gamma]`. The full
     * rotation is an intrinsic rotation with angles applied in the order `lambda, phi, gamma`. The rotation uses the
     * standard geographic cartesian coordinate system, a right-handed coordinate system with the origin at the center of
     * the earth, the positive x axis passing through 0 degrees N, 0 degrees E, and the z axis passing through the North
     * Pole.
     * * `lambda`: Intrinsic rotation angle about the z axis. Positive rotation is in the counterclockwise direction when
     * looking down from above the axis.
     * * `phi`: Intrinsic rotation angle about the y axis. Positive rotation is in the clockwise direction when looking
     * down from above the axis.
     * * `gamma`: Intrinsic rotation angle about the x axis. Positive rotation is in the counterclockwise direction when
     * looking down from above the axis.
     * @param vec The pre-projection rotation, as a vector `[lambda, phi, gamma]`. The rotation angles should be
     * expressed in radians.
     * @returns This projection, after it has been changed.
     */
    setPreRotation(vec: ReadonlyFloat64Array): this;
    /**
     * Sets the post-projection (planar) translation of this projection.
     * @param vec The new post-projection translation, in pixels.
     * @returns This projection, after it has been changed.
     */
    setTranslation(vec: ReadonlyFloat64Array): this;
    /**
     * Sets the post-projection (planar) rotation of this projection.
     * @param rotation The new post-projection rotation angle, in radians.
     * @returns This projection, after it has been changed.
     */
    setPostRotation(rotation: number): this;
    /**
     * Sets whether this reflection should reflect the projected coordinate system across the x-axis. Setting this value
     * to true is useful in the situation where the projected coordinate system should use a positive-y-axis-down
     * convention.
     * @param val True if reflection is desired, false otherwise.
     * @returns This projection, after it has been changed.
     */
    setReflectY(val: boolean): this;
    /**
     * Copies all projection parameters from another projection. The parameters copied are: center, pre-projection
     * rotation angles, scale factor, post-projection translation, post-projection rotation angle, and reflectY.
     * @param other The projection from which to copy parameters.
     * @returns This projection, after it has been changed.
     */
    copyParametersFrom(other: GeoProjection): this;
}
/**
 * A partial implementation of a MutableGeoProjection. Subclasses should use the projectRaw() and invertRaw() methods
 * to define the type of projection to be implemented.
 */
declare abstract class AbstractGeoProjection implements MutableGeoProjection {
    private static readonly vec2Cache;
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    protected readonly center: GeoPoint;
    protected readonly centerTranslation: Float64Array;
    protected scaleFactor: number;
    protected readonly preRotation: Float64Array;
    protected readonly translation: Float64Array;
    protected postRotation: number;
    protected rotationSin: number;
    protected rotationCos: number;
    protected reflectY: number;
    protected readonly preRotationForwardTransform: Transform3D;
    protected readonly preRotationReverseTransform: Transform3D;
    private readonly rotationCache;
    /** @inheritdoc */
    getCenter(): GeoPointReadOnly;
    /** @inheritdoc */
    getScaleFactor(): number;
    /** @inheritdoc */
    getPreRotation(): ReadonlyFloat64Array;
    /** @inheritdoc */
    getTranslation(): ReadonlyFloat64Array;
    /** @inheritdoc */
    getPostRotation(): number;
    /** @inheritdoc */
    getReflectY(): boolean;
    /** @inheritdoc */
    setCenter(point: LatLonInterface): this;
    /** @inheritdoc */
    setScaleFactor(factor: number): this;
    /** @inheritdoc */
    setPreRotation(vec: ReadonlyFloat64Array): this;
    /** @inheritdoc */
    setTranslation(vec: ReadonlyFloat64Array): this;
    /** @inheritdoc */
    setPostRotation(rotation: number): this;
    /** @inheritdoc */
    setReflectY(val: boolean): this;
    /** @inheritdoc */
    copyParametersFrom(other: GeoProjection): this;
    /**
     * Updates the pre-rotation transformation matrices.
     */
    protected updatePreRotationTransforms(): void;
    /**
     * Updates the translation vector to move the center of this projection to the origin.
     */
    protected updateCenterTranslation(): void;
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    protected abstract projectRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    protected abstract invertRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Applies a forward rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    protected preRotateForward(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Applies a reverse rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    protected preRotateReverse(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /** @inheritdoc */
    project(point: LatLonInterface | ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /** @inheritdoc */
    invert<T extends GeoPoint | Float64Array>(vec: ReadonlyFloat64Array, out: T): T;
}
/**
 * A Mercator projection.
 */
declare class MercatorProjection extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    protected projectRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    protected invertRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
}
/**
 * An orthographic projection.
 */
declare class OrthographicProjection extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    protected projectRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    protected invertRaw(vec: ReadonlyFloat64Array, out: Float64Array): Float64Array;
}

/**
 * A function which handles resampled points.
 */
declare type GeodesicResamplerHandler = (point: GeoPointInterface, projected: Float64Array, index: number) => void;
/**
 * Resamples projected geodesic (great-circle) paths between defined endpoints into series of straight line segments.
 */
declare class GeodesicResampler {
    readonly minDistance: number;
    readonly dpTolerance: number;
    readonly maxDepth: number;
    private readonly cosMinDistance;
    private readonly dpTolSq;
    private geoPointCache;
    private vec2Cache;
    private vec3Cache;
    /**
     * Constructor.
     * @param minDistance The minimum geodesic distance this resampler enforces between two adjacent resampled points, in
     * great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance this resampler uses when deciding whether to discard a resampled
     * point during the line simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by 2^[maxDepth] - 1.
     */
    constructor(minDistance: number, dpTolerance: number, maxDepth: number);
    /**
     * Resamples a projected geodesic (great-circle) path.
     * @param projection The projection to use.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     * @throws Error when the start and end of the path are antipodal.
     */
    resample(projection: GeoProjection, start: LatLonInterface, end: LatLonInterface, handler: GeodesicResamplerHandler): void;
    /**
     * Resamples a projected geodesic (great-circle) path. This method will recursively split the path into two halves
     * and resample the midpoint. Recursion continues as long as the maximum depth has not been reached and at least one
     * of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * The Douglas-Peucker metric of the projected midpoint is greater than or equal to the set tolerance.
     * @param projection The projection to use.
     * @param lat1 The latitude of the start of the path.
     * @param lon1 The longitude of the start of the path.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path.
     * @param projY1 The y-component of the projected location of the start of the path.
     * @param lat2 The latitude of the end of the path.
     * @param lon2 The longitude of the end of the path.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path.
     * @param projY2 The y-component of the projected location of the end of the path.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param index The index of the next resampled point.
     * @returns The index of the next resampled point.
     * @throws Error when the start and end of the path are antipodal.
     */
    private resampleHelper;
}

/**
 * A function which handles resampled points.
 * @param vector A vector which describes the projected path terminating at the resampled point.
 */
declare type GeoCircleResamplerHandler = (vector: Readonly<GeoCircleResamplerVector>) => void;
/**
 * A vector describing the projected path terminating at a point resampled by {@link GeoCircleResampler}.
 */
declare type GeoCircleResamplerVector = GeoCircleResamplerStartVector | GeoCircleResamplerLineVector | GeoCircleResamplerArcVector;
/** Base vector class. */
declare type GeoCircleResamplerBaseVector = {
    /** The type of this vector. */
    type: string;
    /** The resampled point that terminates this vector. */
    point: GeoPointInterface;
    /** The projected position, in pixel coordinates, of the resampled point that terminates this vector. */
    projected: ReadonlyFloat64Array;
    /** The index of the resampled point that terminates this vector. `0` is the first point, `1` is the second, and so on. */
    index: number;
};
/**
 * A vector describing the starting point of a path resampled by {@link GeoCircleResampler}.
 */
declare type GeoCircleResamplerStartVector = GeoCircleResamplerBaseVector & {
    /** The type of this vector. */
    type: 'start';
};
/**
 * A vector describing a projected straight line terminating at a point resampled by {@link GeoCircleResampler}.
 */
declare type GeoCircleResamplerLineVector = GeoCircleResamplerBaseVector & {
    /** The type of this vector. */
    type: 'line';
};
/**
 * A vector describing a projected circular arc terminating at a point resampled by {@link GeoCircleResampler}.
 */
declare type GeoCircleResamplerArcVector = GeoCircleResamplerBaseVector & {
    /** The type of this vector. */
    type: 'arc';
    /** The center of the projected arc, in pixel coordinates. */
    projectedArcCenter: ReadonlyFloat64Array;
    /** The radius of the projected arc, in pixels. */
    projectedArcRadius: number;
    /** The radial of the start of the projected arc, in radians. */
    projectedArcStartAngle: number;
    /** The radial of the end of the projected arc, in radians. */
    projectedArcEndAngle: number;
};
/**
 * Resamples projected great- and small-circle paths between defined endpoints into series of straight line segments and circular arcs.
 */
declare class GeoCircleResampler {
    readonly minDistance: number;
    readonly dpTolerance: number;
    readonly maxDepth: number;
    private readonly cosMinDistance;
    private readonly dpTolSq;
    private readonly geoPointCache;
    private readonly vec2Cache;
    private readonly vec3Cache;
    private readonly startVector;
    private readonly lineVector;
    private readonly arcVector;
    private readonly state;
    /**
     * Constructor.
     * @param minDistance The minimum great-circle distance this resampler enforces between two adjacent resampled
     * points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance, in pixels, this resampler uses when deciding whether to discard
     * a resampled point during the simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by `2^[maxDepth] - 1`.
     */
    constructor(minDistance: number, dpTolerance: number, maxDepth: number);
    /**
     * Resamples a projected great- or small-circle path.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     */
    resample(projection: GeoProjection, circle: GeoCircle, start: LatLonInterface | ReadonlyFloat64Array, end: LatLonInterface | ReadonlyFloat64Array, handler: GeoCircleResamplerHandler): void;
    /**
     * Resamples a projected great- or small-circle path. This method will recursively split the path into two halves
     * and resample the midpoint. Based on the projected position of the midpoint relative to those of the start and end
     * points, the projected path is modeled as either a straight line from the start to the end or a circular arc
     * connecting the start, end, and midpoints. Recursion continues as long as the maximum depth has not been reached
     * and at least one of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * If the path is modeled as a line: the distance from the projected midpoint to the model line is greater than
     * this resampler's Douglas-Peucker tolerance.
     * * If the path is modeled as an arc: the distance from the projected one-quarter or the three-quarter point along
     * the path to the model arc is greater than this resampler's Douglas-Peucker tolerance.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param lat1 The latitude of the start of the path, in degrees.
     * @param lon1 The longitude of the start of the path, in degrees.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path, in pixels.
     * @param projY1 The y-component of the projected location of the start of the path, in pixels.
     * @param lat2 The latitude of the end of the path, in degrees.
     * @param lon2 The longitude of the end of the path, in degrees.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path, in pixels.
     * @param projY2 The y-component of the projected location of the end of the path, in pixels.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param state The current state of the resampling algorithm.
     * @returns The index of the next resampled point.
     */
    private resampleHelper;
    /**
     * Calls a handler function for a resampled point.
     * @param handler The handler function to call.
     * @param lat The latitude of the resampled point, in degrees.
     * @param lon The longitude of the resampled point, in degrees.
     * @param projX The x-coordinate of the projected resampled point, in pixels.
     * @param projY The y-coordinate of the projected resampled point, in pixels.
     * @param state The current state of the resampling algorithm.
     */
    private callHandler;
}

/**
 * Navigational mathematics functions.
 */
declare class NavMath {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val: number, min: number, max: number): number;
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading: number): number;
    /**
     * Inverts a heading value by adding 180 and normalizing.
     * @param heading The heading to invert/reciprocate.
     * @returns The inverted/reciprocated heading.
     * */
    static reciprocateHeading(heading: number): number;
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius, in meters.
     */
    static turnRadius(airspeedTrue: number, bankAngle: number): number;
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param radius The airplane turn radius, in meters.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue: number, radius: number): number;
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse: number, endCourse: number): 'left' | 'right';
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians: number): number;
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees: number): number;
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing: number, endBearing: number, radius: number): number;
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1: number, y1: number, x2: number, y2: number, cx: number, cy: number, r: number, sRef: CircleIntersection): 0 | 1 | 2;
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx: number, cy: number, x: number, y: number): number;
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing: number, start: number, end: number): boolean;
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading: number, turnDirection: 'left' | 'right'): number;
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle: number, turnDirection: 'left' | 'right'): number;
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course: number, airspeedTrue: number, windDirection: number, windSpeed: number): number;
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start: LatLonInterface, end: LatLonInterface, pos: LatLonInterface): number;
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start: LatLonInterface, end: LatLonInterface, pos: LatLonInterface): number;
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start: LatLonInterface, end: LatLonInterface, pos: LatLonInterface): number;
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center: LatLonInterface, turnDirection: 'left' | 'right', pos: LatLonInterface): number;
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start: number, end: number, center: LatLonInterface, turnDirection: 'left' | 'right', pos: LatLonInterface): number;
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start: number, center: GeoPoint, radius: number, turnDirection: 'left' | 'right', distance: number, out: GeoPoint): GeoPoint;
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center: LatLonInterface, radius: number, pos: LatLonInterface): number;
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a: number, b: number): number;
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b: number, c: number, beta: number, gamma: number): number;
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course: number, turnDirection: 'left' | 'right', outVector: Float64Array): void;
}
/**
 * A circle intersection solution.
 */
interface CircleIntersection {
    /** The x coordinate of the first solution point. */
    x1: number;
    /** The y coordinate of the first solution point. */
    y1: number;
    /** The x coordinate of the second solution point. */
    x2: number;
    /** The y coordinate of the second solution point. */
    y2: number;
}
/**
 * A representation of a vector.
 */
interface Vector {
    /** The x component of the vector. */
    x: number;
    /** The y component of the vector. */
    y: number;
}

/**
 * The navigation angle unit family type.
 */
declare type NavAngleUnitFamily = 'navangle';
/**
 * A navigation angle unit, which is a measure of angular degrees relative to either true or magnetic north.
 *
 * Unlike most other unit types, each instance of navigation angle unit contains state specific to that instance,
 * namely the magnetic variation used to convert between true and magnetic bearing.
 *
 * Conversions use the magnetic variation of the NavAngleUnit instance whose conversion method is called; this also
 * means that when calling `NumberUnit.asUnit()`, the magnetic variation of the unit of the NumberUnit whose `asUnit()`
 * method was called will be used.
 */
interface NavAngleUnit extends Unit<NavAngleUnitFamily> {
    /** This unit's magnetic variation, in degrees. */
    readonly magVar: number;
    /**
     * Checks whether this nav angle unit is relative to magnetic north.
     * @returns Whether this nav angle unit is relative to magnetic north.
     */
    isMagnetic(): boolean;
}
/**
 * The possible reference norths for navigation angle units.
 */
declare enum NavAngleUnitReferenceNorth {
    True = "true",
    Magnetic = "magnetic"
}
/**
 * A basic implementation of a navigation angle unit.
 */
declare class BasicNavAngleUnit extends AbstractUnit<NavAngleUnitFamily> implements NavAngleUnit {
    /** @inheritdoc */
    readonly family = "navangle";
    private _magVar;
    /** @inheritdoc */
    get magVar(): number;
    /**
     * Constructor.
     * @param referenceNorth The reference north of the new unit.
     * @param magVar The initial magnetic variation of the new unit.
     */
    constructor(referenceNorth: NavAngleUnitReferenceNorth, magVar: number);
    /**
     * Checks whether this nav angle unit is relative to magnetic north.
     * @returns Whether this nav angle unit is relative to magnetic north.
     */
    isMagnetic(): boolean;
    /**
     * Converts a value of this unit to another unit. This unit's magnetic variation is used for the conversion.
     * @param value The value to convert.
     * @param toUnit The unit to which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertTo(value: number, toUnit: Unit<NavAngleUnitFamily>): number;
    /**
     * Converts a value of another unit to this unit. This unit's magnetic variation is used for the conversion.
     * @param value The value to convert.
     * @param fromUnit The unit from which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertFrom(value: number, fromUnit: Unit<NavAngleUnitFamily>): number;
    /**
     * Sets this unit's magnetic variation.
     * @param magVar The magnetic variation to set, in degrees.
     */
    setMagVar(magVar: number): void;
    /**
     * Sets this unit's magnetic variation from a geographic location.
     * @param location The location defining the new magnetic variation.
     */
    setMagVarFromLocation(location: LatLonInterface): void;
    /**
     * Sets this unit's magnetic variation from a geographic location.
     * @param lat The latitude, in degrees, of the location defining the new magnetic variation.
     * @param lon The longitude, in degrees, of the location defining the new magnetic variation.
     */
    setMagVarFromLocation(lat: number, lon: number): void;
    /** @inheritdoc */
    equals(other: Unit<string>): boolean;
    /**
     * Creates an instance of BasicNavAngleUnit.
     * @param isMagnetic Whether the new unit is relative to magnetic north.
     * @param magVar The initial magnetic variation of the new unit, in degrees. Defaults to 0 degrees.
     * @returns An instance of BasicNavAngleUnit.
     */
    static create(isMagnetic: boolean, magVar?: number): BasicNavAngleUnit;
    /**
     * Creates an instance of BasicNavAngleUnit.
     * @param isMagnetic Whether the new unit is relative to magnetic north.
     * @param location The initial location of the new unit.
     * @returns An instance of BasicNavAngleUnit.
     */
    static create(isMagnetic: boolean, location: LatLonInterface): BasicNavAngleUnit;
    /**
     * Creates an instance of BasicNavAngleUnit.
     * @param isMagnetic Whether the new unit is relative to magnetic north.
     * @param lat The initial latitude of the new unit, in degrees.
     * @param lon The initial longitude of the new unit, in degrees.
     * @returns An instance of BasicNavAngleUnit.
     */
    static create(isMagnetic: boolean, lat: number, lon: number): BasicNavAngleUnit;
}
/**
 * A Subject which provides a navigation angle value.
 */
declare class BasicNavAngleSubject extends AbstractSubscribable<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>> implements MutableSubscribable<NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>> {
    private readonly value;
    private static readonly TRUE_BEARING;
    /** @inheritdoc */
    readonly isMutableSubscribable = true;
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    private constructor();
    /**
     * Creates a BasicNavAngleSubject.
     * @param initialVal The initial value.
     * @returns A BasicNavAngleSubject.
     */
    static create(initialVal: NumberUnit<NavAngleUnitFamily, BasicNavAngleUnit>): BasicNavAngleSubject;
    /** @inheritdoc */
    get(): NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The new value.
     */
    set(value: NumberUnitInterface<NavAngleUnitFamily, NavAngleUnit>): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The numeric part of the new value.
     * @param unit The unit type of the new value. Defaults to the unit type of the NumberUnit used to create this
     * subject.
     */
    set(value: number, unit?: NavAngleUnit): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The numeric part of the new value.
     * @param magVar The magnetic variation of the new value.
     */
    set(value: number, magVar: number): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The numeric part of the new value.
     * @param location The location defining the new value's magnetic variation.
     */
    set(value: number, location: LatLonInterface): void;
    /**
     * Sets the new value and notifies the subscribers if the value changed.
     * @param value The numeric part of the new value.
     * @param lat The latitude of the location defining the new value's magnetic variation.
     * @param lon The longitude of the location defining the new value's magnetic variation.
     */
    set(value: number, lat: number, lon: number): void;
}

/**
 * A visitor function for geo k-d tree searches.
 * @param element A search result.
 * @param point The location of the search result, in cartesian form.
 * @param distance The great-circle distance, in great-arc radians, from the search result to the query point.
 * @param queryPoint The query point, in cartesian form.
 * @returns Whether to continue the search.
 */
declare type GeoKdTreeSearchVisitor<T> = (element: T, point: ReadonlyFloat64Array, distance: number, queryPoint: ReadonlyFloat64Array) => boolean;
/**
 * A filtering function for k-d tree searches.
 * @param element A candidate search result.
 * @param point The location of the candidate search result, in cartesian form.
 * @param distance The great-circle distance, in great-arc radians, from the candidate search result to the query point.
 * @param queryPoint The query point, in cartesian form.
 * @returns Whether to include the candidate in the final search results.
 */
declare type GeoKdTreeSearchFilter<T> = (element: T, point: ReadonlyFloat64Array, distance: number, queryPoint: ReadonlyFloat64Array) => boolean;
/**
 * A spatial tree which is keyed on points on Earth's surface and allows searching for elements based on the great-
 * circle distances from their keys to a query point.
 */
declare class GeoKdTree<T> {
    private readonly keyFunc;
    private static readonly vec3Cache;
    private readonly cartesianTree;
    /**
     * Constructor.
     * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
     * Earth's surface.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(keyFunc: (element: T, out: Float64Array) => Float64Array);
    /**
     * Searches this tree for elements located near a query point and visits each of them with a function.
     * @param lat The latitude of the query point, in degrees.
     * @param lon The longitude of the query point, in degrees.
     * @param radius The radius around the query point to search, in great-arc radians.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    search(lat: number, lon: number, radius: number, visitor: GeoKdTreeSearchVisitor<T>): void;
    /**
     * Searches this tree for elements located near a query point and visits each of them with a function.
     * @param center The query point.
     * @param radius The radius around the query point to search, in great-arc radians.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    search(center: LatLonInterface | ReadonlyFloat64Array, radius: number, visitor: GeoKdTreeSearchVisitor<T>): void;
    /**
     * Searches this tree for elements located near a query point and returns them in order of increasing distance from
     * the query key.
     * @param lat The latitude of the query point, in degrees.
     * @param lon The longitude of the query point, in degrees.
     * @param radius The radius around the query point to search, in great-arc radians.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    search(lat: number, lon: number, radius: number, maxResultCount: number, out: T[], filter?: GeoKdTreeSearchFilter<T>): T[];
    /**
     * Searches this tree for elements located near a query point and returns them in order of increasing distance from
     * the query key.
     * @param center The query point.
     * @param radius The radius around the query point to search, in great-arc radians.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    search(center: LatLonInterface | ReadonlyFloat64Array, radius: number, maxResultCount: number, out: T[], filter?: GeoKdTreeSearchFilter<T>): T[];
    /**
     * Performs a tree search with a visitor function.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    private doVisitorSearch;
    /**
     * Performs a tree search and returns an array of search results.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    private doResultsSearch;
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element: T): void;
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements: Iterable<T>): void;
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element: T): boolean;
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements: Iterable<T>): boolean;
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove: Iterable<T>, toInsert: Iterable<T>): void;
    /**
     * Rebuilds and balances this tree.
     */
    rebuild(): void;
    /**
     * Removes all elements from this tree.
     */
    clear(): void;
}

/**
 * A subscribable which provides a sorted version of a source SubscribableArray.
 */
declare class SortedMappedSubscribableArray<T> extends AbstractSubscribableArray<T> {
    private readonly source;
    private readonly comparatorFunc;
    private readonly equalityFunc?;
    private sorted;
    private readonly sourceSub;
    /** @inheritdoc */
    get length(): number;
    /**
     * Constructor.
     * @param source The source array subject for this subscribable.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    private constructor();
    /**
     * Creates a new SortedMappedSubscribableArray.
     * @param source The source array subject for the new mapped sorted array.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create<CT>(source: SubscribableArray<CT>, comparatorFunc: (a: CT, b: CT) => number, equalityFunc?: (a: CT, b: CT) => boolean): SortedMappedSubscribableArray<CT>;
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    private onSourceChanged;
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    private insert;
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    private remove;
    /** @inheritdoc */
    getArray(): readonly T[];
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy(): void;
}

/**
 * A subscribable which provides a filtered version of a source SubscribableArray.
 */
declare class FilteredMappedSubscribableArray<T> extends AbstractSubscribableArray<T> {
    private readonly source;
    private filterFunc;
    private filtered;
    private readonly sourceSub;
    /** @inheritdoc */
    get length(): number;
    /**
     * Private constructor for a FilteredMappedSubscribableArray.
     * @param source The source array subject for this subscribable.
     * @param filterFunc The filter function to use to prune members.  Should return false for filtered-out elements.
     */
    private constructor();
    /**
     * Public creation method for a new FilteredMappedSubscribableArray.
     * @param source The source array subject for the new mapped array.
     * @param filterFunc The filter function to use to prune members.  Should return false for filtered-out elements.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create<CT>(source: SubscribableArray<CT>, filterFunc: (a: CT) => boolean): FilteredMappedSubscribableArray<CT>;
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    private onSourceChanged;
    /**
     * Set a new filter for this array.
     * @param filterFunc The new filter function.
     */
    setFilter(filterFunc: (a: T) => boolean): void;
    /**
     * Takes an element or array of elements and returns an array of only those passing the filter.
     * @param elements An element or array of elements to run through the filter.
     * @returns A new list composed of only those elements which pass the filter.
     */
    private filter;
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    private insert;
    /**
     * Finds the index of the first element in this array which equals a query element.
     * @param element The query element.
     * @returns The index of the first matching element, or -1 if no such element.
     */
    private searchEquals;
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    private remove;
    /**
     * Removes a single element from the array.
     * @param element The element to remove.
     */
    private removeElement;
    /** @inheritdoc */
    getArray(): readonly T[];
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy(): void;
}

/**
 * Topics published by {@link FacilityRepository} on the event bus.
 */
interface FacilityRepositoryEvents {
    /** A facility was added. */
    facility_added: Facility;
    /** A facility was changed. */
    facility_changed: Facility;
    /** A facility was changed. The suffix of the topic specifies the ICAO of the changed facility. */
    [facility_changed: `facility_changed_${string}`]: Facility;
    /** A facility was removed. */
    facility_removed: Facility;
    /** A facility was removed. The suffix of the topic specifies the ICAO of the removed facility. */
    [facility_removed: `facility_removed_${string}`]: Facility;
}
/** Facility types for which {@link FacilityRepository} supports spatial searches. */
declare type SearchableFacilityTypes = FacilityType.USR | FacilityType.VIS;
/**
 * A repository of facilities.
 */
declare class FacilityRepository {
    private readonly bus;
    private static readonly SYNC_TOPIC;
    private static readonly treeKeyFunc;
    private static INSTANCE;
    private readonly publisher;
    private readonly repos;
    private readonly trees;
    private ignoreSync;
    private lastDumpRequestUid?;
    /**
     * Constructor.
     * @param bus The event bus.
     */
    private constructor();
    /**
     * Gets the number of facilities stored in this repository.
     * @param types The types of facilities to count. Defaults to all facility types.
     * @returns The number of facilities stored in this repository.
     */
    size(types?: readonly FacilityType[]): number;
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao: string): Facility | undefined;
    /**
     * Searches for facilities around a point. Only supported for USR and VIS facilities.
     * @param type The type of facility for which to search.
     * @param lat The latitude of the query point, in degrees.
     * @param lon The longitude of the query point, in degrees.
     * @param radius The radius of the search, in great-arc radians.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     * @throws Error if spatial searches are not supported for the specified facility type.
     */
    search(type: SearchableFacilityTypes, lat: number, lon: number, radius: number, visitor: GeoKdTreeSearchVisitor<Facility>): void;
    /**
     * Searches for facilities around a point. Only supported for USR and VIS facilities.
     * @param type The type of facility for which to search.
     * @param lat The latitude of the query point, in degrees.
     * @param lon The longitude of the query point, in degrees.
     * @param radius The radius of the search, in great-arc radians.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @throws Error if spatial searches are not supported for the specified facility type.
     */
    search(type: SearchableFacilityTypes, lat: number, lon: number, radius: number, maxResultCount: number, out: Facility[], filter?: GeoKdTreeSearchFilter<Facility>): Facility[];
    /**
     * Adds a facility to this repository and all other repositories synced with this one. If this repository already
     * contains a facility with the same ICAO as the facility to add, the existing facility will be replaced with the
     * new one.
     * @param fac The facility to add.
     * @throws Error if the facility has an invalid ICAO.
     */
    add(fac: Facility): void;
    /**
     * Adds multiple facilities from this repository and all other repositories synced with this one. For each added
     * facility, if this repository already contains a facility with the same ICAO, the existing facility will be
     * replaced with the new one.
     * @param facs The facilities to add.
     */
    addMultiple(facs: readonly Facility[]): void;
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     * @throws Error if the facility has an invalid ICAO.
     */
    remove(fac: Facility | string): void;
    /**
     * Removes multiple facilities from this repository and all other repositories synced with this one.
     * @param facs The facilities to remove, or the ICAOs of the facilties to remove.
     */
    removeMultiple(facs: readonly (Facility | string)[]): void;
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn: (fac: Facility) => void, types?: readonly FacilityType[]): void;
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    private addToRepo;
    /**
     * Adds multiple facilities to this repository.
     * @param facs The facilities to add.
     */
    private addMultipleToRepo;
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     */
    private removeFromRepo;
    /**
     * Removes multiple facilities from this repository.
     * @param facs The facilities to remove, or the ICAOs of the facilities to remove.
     */
    private removeMultipleFromRepo;
    /**
     * Publishes a facility added or removed sync event over the event bus.
     * @param data The event data.
     */
    private pubSyncEvent;
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    private onSyncEvent;
    /**
     * Gets an instance of FacilityRepository.
     * @param bus The event bus.
     * @returns an instance of FacilityRepository.
     */
    static getRepository(bus: EventBus): FacilityRepository;
}

/**
 * Facility search types for facilities with a defined latitude and longitude.
 */
declare type FacilitySearchTypeLatLon = FacilitySearchType.All | FacilitySearchType.Airport | FacilitySearchType.Intersection | FacilitySearchType.Vor | FacilitySearchType.Ndb | FacilitySearchType.User | FacilitySearchType.Visual | FacilitySearchType.AllExceptVisual;
/**
 * A type map of search type to concrete search session type.
 */
declare type SessionTypeMap = {
    /** All facilities search session. */
    [FacilitySearchType.All]: NearestSearchSession<any, any>;
    /** Airport search session. */
    [FacilitySearchType.Airport]: NearestAirportSearchSession;
    /** Intersection search session. */
    [FacilitySearchType.Intersection]: NearestIntersectionSearchSession;
    /** VOR search session. */
    [FacilitySearchType.Vor]: NearestVorSearchSession;
    /** NDB search session. */
    [FacilitySearchType.Ndb]: NearestSearchSession<string, string>;
    /** Boundary search session. */
    [FacilitySearchType.Boundary]: NearestBoundarySearchSession;
    /** Nearest user facility search session. */
    [FacilitySearchType.User]: NearestRepoFacilitySearchSession<UserFacility>;
    /** Nearest visual facility search session. */
    [FacilitySearchType.Visual]: NearestRepoFacilitySearchSession<VisualFacility>;
    /** All facilities search session. */
    [FacilitySearchType.AllExceptVisual]: NearestSearchSession<any, any>;
};
/**
 * A type map of search type to facility type.
 */
declare type SearchTypeMap = {
    /** All facilities. */
    [FacilitySearchType.All]: Facility;
    /** Airports. */
    [FacilitySearchType.Airport]: AirportFacility;
    /** Intersections. */
    [FacilitySearchType.Intersection]: IntersectionFacility;
    /** VORs. */
    [FacilitySearchType.Vor]: VorFacility;
    /** NDBs. */
    [FacilitySearchType.Ndb]: NdbFacility;
    /** Boundaries. */
    [FacilitySearchType.Boundary]: BoundaryFacility;
    /** User facilities. */
    [FacilitySearchType.User]: UserFacility;
    /** Visual facilities. */
    [FacilitySearchType.Visual]: VisualFacility;
    /** All facilities except visual facilities. */
    [FacilitySearchType.AllExceptVisual]: Facility;
};
/**
 * A type map of facility type to facility search type.
 */
declare const FacilityTypeSearchType: {
    /** Airport facility type. */
    readonly LOAD_AIRPORT: FacilitySearchType.Airport;
    /** Intersection facility type. */
    readonly LOAD_INTERSECTION: FacilitySearchType.Intersection;
    /** NDB facility type. */
    readonly LOAD_NDB: FacilitySearchType.Ndb;
    /** VOR facility type. */
    readonly LOAD_VOR: FacilitySearchType.Vor;
    /** USR facility type. */
    readonly USR: FacilitySearchType.User;
    /** Visual facility type. */
    readonly VIS: FacilitySearchType.Visual;
};
/**
 * Facility types stored in a {@link FacilityRepository}
 */
declare type RepoFacilityType = UserFacility | VisualFacility;
/**
 * A class that handles loading facility data from the simulator.
 */
declare class FacilityLoader {
    private readonly facilityRepo;
    readonly onInitialized: () => void;
    private static readonly MAX_FACILITY_CACHE_ITEMS;
    private static readonly MAX_AIRWAY_CACHE_ITEMS;
    private static facilityListener;
    private static readonly requestQueue;
    private static readonly mismatchRequestQueue;
    private static readonly facCache;
    private static readonly typeMismatchFacCache;
    private static readonly airwayCache;
    private static readonly searchSessions;
    private static readonly facRepositorySearchTypes;
    private static repoSearchSessionId;
    private static isInitialized;
    private static readonly initPromiseResolveQueue;
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo: FacilityRepository, onInitialized?: () => void);
    /**
     * Initializes this facility loader.
     */
    private static init;
    /**
     * Waits until this facility loader is initialized.
     * @returns A Promise which is fulfilled when this facility loader is initialized.
     */
    awaitInitialization(): Promise<void>;
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility<T extends FacilityType>(type: T, icao: string): Promise<FacilityTypeMap[T]>;
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    private getFacilityFromRepo;
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    private getFacilityFromCoherent;
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    getAirway(airwayName: string, airwayType: number, icao: string): Promise<AirwayObject>;
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    startNearestSearchSession<T extends FacilitySearchType>(type: T): Promise<SessionTypeMap[T]>;
    /**
     * Starts a sim-side nearest facilities search session through Coherent.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    private startCoherentNearestSearchSession;
    /**
     * Starts a repository facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     * @throws Error if the search type is not supported.
     */
    private startRepoNearestSearchSession;
    /**
     * Gets a METAR for an airport.
     * @param airport An airport.
     * @returns The METAR for the airport, or undefined if none could be obtained.
     */
    getMetar(airport: AirportFacility): Promise<Metar | undefined>;
    /**
     * Gets a METAR for an airport.
     * @param ident An airport ident.
     * @returns The METAR for the airport, or undefined if none could be obtained.
     */
    getMetar(ident: string): Promise<Metar | undefined>;
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    searchMetar(lat: number, lon: number): Promise<Metar | undefined>;
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    private static cleanMetar;
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matched ICAOs. Exact matches are sorted before partial matches.
     */
    searchByIdent(filter: FacilitySearchType, ident: string, maxItems?: number): Promise<string[]>;
    /**
     * Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
     * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
     * @param lat The latitude to find facilities nearest to.
     * @param lon The longitude to find facilities nearest to.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
     */
    findNearestFacilitiesByIdent<T extends FacilitySearchTypeLatLon>(filter: T, ident: string, lat: number, lon: number, maxItems?: number): Promise<SearchTypeMap[T][]>;
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    private static onFacilityReceived;
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    private static onNearestSearchCompleted;
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    private static addToFacilityCache;
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    private static addToAirwayCache;
}
/**
 * A session for searching for nearest facilities.
 */
interface NearestSearchSession<TAdded, TRemoved> {
    /**
     * Searches for nearest facilities from the specified point.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     * @param radius The radius around the point to search, in meters.
     * @param maxItems The maximum number of items.
     * @returns The nearest search results.
     */
    searchNearest(lat: number, lon: number, radius: number, maxItems: number): Promise<NearestSearchResults<TAdded, TRemoved>>;
}
/**
 * A session for searching for nearest facilities through Coherent.
 */
declare class CoherentNearestSearchSession<TAdded, TRemoved> implements NearestSearchSession<TAdded, TRemoved> {
    protected readonly sessionId: number;
    private readonly searchQueue;
    /**
     * Creates an instance of a CoherentNearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId: number);
    /** @inheritdoc */
    searchNearest(lat: number, lon: number, radius: number, maxItems: number): Promise<NearestSearchResults<TAdded, TRemoved>>;
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results: NearestSearchResults<TAdded, TRemoved>): void;
}
/**
 * A session for searching for nearest airports.
 */
declare class NearestAirportSearchSession extends CoherentNearestSearchSession<string, string> {
    /**
     * Default filters for the nearest airports search session.
     */
    static Defaults: {
        ShowClosed: boolean;
        ClassMask: number;
        SurfaceTypeMask: number;
        ApproachTypeMask: number;
        MinimumRunwayLength: number;
        ToweredMask: number;
    };
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed: boolean, classMask: number): void;
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedAirportFilters(surfaceTypeMask: number, approachTypeMask: number, toweredMask: number, minRunwayLength: number): void;
}
/**
 * A session for searching for nearest intersections.
 */
declare class NearestIntersectionSearchSession extends CoherentNearestSearchSession<string, string> {
    /**
     * Default filters for the nearest intersections search session.
     */
    static Defaults: {
        TypeMask: number;
    };
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     */
    setIntersectionFilter(typeMask: number): void;
}
/**
 * A session for searching for nearest VORs.
 */
declare class NearestVorSearchSession extends CoherentNearestSearchSession<string, string> {
    /**
     * Default filters for the nearest VORs search session.
     */
    static Defaults: {
        ClassMask: number;
        TypeMask: number;
    };
    /**
     * Sets the filter for the VOR nearest search.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask: number, typeMask: number): void;
}
/**
 * A session for searching for nearest airspace boundaries.
 */
declare class NearestBoundarySearchSession extends CoherentNearestSearchSession<BoundaryFacility, number> {
    /**
     * Sets the filter for the boundary nearest search.
     * @param classMask A bitmask to determine which boundary classes to show.
     */
    setBoundaryFilter(classMask: number): void;
}
/**
 * A session for searching for nearest facilities that uses the facility repository.
 */
declare class NearestRepoFacilitySearchSession<F extends RepoFacilityType> implements NearestSearchSession<string, string> {
    private readonly repo;
    private readonly sessionId;
    private filter;
    private readonly cachedResults;
    private searchId;
    /**
     * Creates an instance of a NearestUserSearchSession.
     * @param repo The facility repository in which to search.
     * @param sessionId The ID of the session.
     */
    constructor(repo: FacilityRepository, sessionId: number);
    /** @inheritdoc */
    searchNearest(lat: number, lon: number, radius: number, maxItems: number): Promise<NearestSearchResults<string, string>>;
    /**
     * Sets the filter for this search session.
     * @param filter A function to filter the search results.
     */
    setUserFacilityFilter(filter?: GeoKdTreeSearchFilter<F>): void;
}
/**
 * An airway.
 */
declare class AirwayObject {
    private _name;
    private _type;
    private _waypoints;
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name: string, type: number);
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name(): string;
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type(): number;
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints(): IntersectionFacility[];
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints: IntersectionFacility[]);
}
/**
 * WT Airway Status Enum
 */
declare enum AirwayStatus {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    INCOMPLETE = 0,
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    COMPLETE = 1,
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    PARTIAL = 2
}
/**
 * The Airway Builder.
 */
declare class AirwayBuilder {
    private _initialWaypoint;
    private _initialData;
    private facilityLoader;
    private _waypointsArray;
    private _hasStarted;
    private _isDone;
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint: IntersectionFacility, _initialData: AirwaySegment, facilityLoader: FacilityLoader);
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted(): boolean;
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone(): boolean;
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints(): IntersectionFacility[] | null;
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    _step(stepForward: boolean, arrayInsertFunc: (wpt: IntersectionFacility) => void): Promise<void>;
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    _stepForward(): Promise<void>;
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    _stepBackward(): Promise<void>;
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array: IntersectionFacility[]): void;
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild(): Promise<AirwayStatus>;
}

/**
 * A utility class for working with approach procedures.
 */
declare class ApproachUtils {
    /**
     * Gets the best RNAV minimum type available for a given approach.
     * @param query The approach to check, or its RNAV type flags.
     * @returns The best RNAV minimum type available for the specified approach.
     */
    static getBestRnavType(query: ApproachProcedure | RnavTypeFlags): RnavTypeFlags;
    /**
     * Checks whether an approach procedure is an RNP (AR) approach.
     * @param approach The approach procedure to check.
     * @returns Whether the approach procedure is an RNP (AR) approach.
     */
    static isRnpAr(approach: ApproachProcedure): boolean;
    /**
     * Gets an approach frequency from its parent airport facility record.
     * @param facility The approach's parent airport facility.
     * @param approach The approach for which to get a frequency.
     * @returns The frequency of the specified approach, or `undefined` if one could not be found.
     */
    static getFrequencyFromAirport(facility: AirportFacility, approach: ApproachProcedure): FacilityFrequency | undefined;
    /**
     * Gets an approach frequency from its parent airport facility record.
     * @param facility The approach's parent airport facility.
     * @param approachIndex The index of the approach for which to get a frequency.
     * @returns The frequency of the specified approach, or `undefined` if one could not be found.
     */
    static getFrequencyFromAirport(facility: AirportFacility, approachIndex: number): FacilityFrequency | undefined;
    /**
     * Gets the reference facility for an approach. Only ILS, LOC (BC), LDA, SDF, VOR(DME), and NDB(DME) approaches can
     * have reference facilities.
     * @param approach The approach for which to get a reference facility.
     * @param facLoader The facility loader.
     * @returns A Promise which is fulfilled with the reference facility for the specified approach, or `undefined` if
     * one could not be found.
     */
    static getReferenceFacility(approach: ApproachProcedure, facLoader: FacilityLoader): Promise<VorFacility | NdbFacility | undefined>;
}

/**
 * A viewlistener that gets autopilot mode information.
 */
declare enum MSFSAPStates {
    LogicOn = 1,
    APOn = 2,
    FDOn = 4,
    FLC = 8,
    Alt = 16,
    AltArm = 32,
    GS = 64,
    GSArm = 128,
    Pitch = 256,
    VS = 512,
    Heading = 1024,
    Nav = 2048,
    NavArm = 4096,
    WingLevel = 8192,
    Attitude = 16384,
    ThrottleSpd = 32768,
    ThrottleMach = 65536,
    ATArm = 131072,
    YD = 262144,
    EngineRPM = 524288,
    TOGAPower = 1048576,
    Autoland = 2097152,
    TOGAPitch = 4194304,
    Bank = 8388608,
    FBW = 16777216,
    AvionicsManaged = 33554432,
    None = -2147483648
}

/**
 * Possible types of hold entries
 */
declare enum HoldEntryType {
    Direct = 0,
    Teardrop = 1,
    Parallel = 2,
    None = 3
}
declare enum HoldMaxSpeedRule {
    Faa = 0,
    Icao = 1
}
/**
 * Utilities for hold entries
 */
declare class HoldUtils {
    /**
     * Gets a hold direction UI string for a given inbound course.
     *
     * @param course The inbound course to get the string for.
     * @param short Whether to get the string in short form (single letter)
     *
     * @returns A UI human-readable course string.
     */
    static getDirectionString(course: number, short?: boolean): string;
    /**
     * Obtains hold speed (number and isMach) depending on altitude and speed rule (ICAO or FAA)
     *
     * @param altitude MSL altitude
     * @param rule     hold speed rule
     *
     * @returns hold speed and whether that number is in Mach
     */
    static getHoldSpeed(altitude: number, rule: HoldMaxSpeedRule): [speed: number, isMach: boolean];
}

declare enum RunwaySurfaceCategory {
    Unknown = 1,
    Hard = 2,
    Soft = 4,
    Water = 8
}
/**
 * Methods for working with Runways and Runway Designations.
 */
declare class RunwayUtils {
    private static readonly RUNWAY_DESIGNATOR_LETTERS;
    private static readonly SURFACES_HARD;
    private static readonly SURFACES_SOFT;
    private static readonly SURFACES_WATER;
    protected static tempGeoPoint: GeoPoint;
    /**
     * Gets the letter for a runway designator.
     * @param designator A runway designator.
     * @param lowerCase Whether the letter should be lower case. False by default.
     * @returns The letter for the specified runway designator.
     */
    static getDesignatorLetter(designator: RunwayDesignator, lowerCase?: boolean): string;
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway(): OneWayRunway;
    /**
     * Utility method to return all of the one-way runways from a single airport facility
     * @param airport is the Airport Facility to evaluate
     * @returns all of the one-way runways in the airport facility, sorted.
     */
    static getOneWayRunwaysFromAirport(airport: AirportFacility): OneWayRunway[];
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway: AirportRunway, index: number): OneWayRunway[];
    /**
     * Gets a name for a paired runway. Names are formatted as dash-separated pairs of directional (one-way) runway
     * designations, with optional leading zero padding of the runway numbers. If the specified runway is not paired,
     * then the name will be the designation of the primary runway only.
     * @param runway A paired runway.
     * @param padded Whether the runway numbers should be padded with leading zeroes. Defaults to `true`.
     * @returns The name for the specified paired runway.
     */
    static getRunwayPairNameString(runway: AirportRunway, padded?: boolean): string;
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber: number, designator: RunwayDesignator, padded?: boolean, prefix?: string): string;
    /**
     * Gets the primary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The primary runway number for the specified runway.
     */
    static getRunwayNumberPrimary(runway: AirportRunway): number;
    /**
     * Gets the secondary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The secondary runway number for the specified runway, or `undefined` if the runway has no secondary
     * runway.
     */
    static getRunwayNumberSecondary(runway: AirportRunway): number | undefined;
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport: AirportFacility, runwayNumber: number, runwayDesignator: RunwayDesignator): OneWayRunway | undefined;
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport: AirportFacility, designation: string): OneWayRunway | undefined;
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport: AirportFacility, ident: string): OneWayRunway | undefined;
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures: readonly ApproachProcedure[], runway: AirportRunway): Array<ApproachProcedure>;
    /**
     * Gets the localizer frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runway The query runway.
     * @returns The localizer frequency for the query runway, or undefined if one could not be found.
     */
    static getLocFrequency(airport: AirportFacility, runway: OneWayRunway): FacilityFrequency | undefined;
    /**
     * Gets the localizer frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayDesignation The designation of the query runway.
     * @returns The localizer frequency for the query runway, or undefined if one could not be found.
     */
    static getLocFrequency(airport: AirportFacility, runwayDesignation: string): FacilityFrequency | undefined;
    /**
     * Gets the localizer frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The localizer frequency for the query runway, or undefined if one could not be found.
     */
    static getLocFrequency(airport: AirportFacility, runwayNumber: number, runwayDesignator: RunwayDesignator): FacilityFrequency | undefined;
    /**
     * Gets the back course frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The bc frequency for the query runway, or undefined if one could not be found.
     */
    static getBcFrequency(airport: AirportFacility, runwayNumber: number, runwayDesignator: RunwayDesignator): FacilityFrequency | undefined;
    /**
     * Get the opposite one way runway from a runway number and designator.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The opposite one way runway for the query runway, or undefined if one could not be found.
     */
    static getOppositeOneWayRunway(airport: AirportFacility, runwayNumber: number, runwayDesignator: RunwayDesignator): OneWayRunway | undefined;
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1: OneWayRunway, r2: OneWayRunway): number;
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport, or the ICAO of the airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport: AirportFacility | string, runway: OneWayRunway): string;
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport: AirportFacility, runway: OneWayRunway): RunwayFacility;
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number: number): string;
    /**
     * Gets the runway surface category from a runway or runway surface type.
     * @param runway A runway or runway surface type.
     * @returns The surface category of the specified runway or runway surface type.
     */
    static getSurfaceCategory(runway: AirportRunway | OneWayRunway | RunwaySurfaceType): RunwaySurfaceCategory;
}

/**
 * Gets the facility type returned by a nearest subscription.
 */
declare type NearestSubscriptionFacilityType<S extends NearestSubscription<any>> = S extends NearestSubscription<infer T> ? T : never;
/**
 * A nearest search which provides its search results as an array of facilities. The contents of the array are
 * automatically updated when the search is updated.
 */
interface NearestSubscription<T extends Facility> extends SubscribableArray<T> {
    /** Whether this search has started. */
    readonly started: boolean;
    /** Waits until this search has started. */
    awaitStart(): Promise<void>;
    /** Starts this search. */
    start: () => Promise<void>;
    /**
     * Updates this search with new parameters. If an update is already in progress, this method will wait until the
     * existing update is finished and then fulfill its returned Promise immediately.
     * @param lat The latitude, in degrees, of the center of the search.
     * @param lon The longitude, in degrees, of the center of the search.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return from the search.
     * @returns A Promise which will be fulfilled when the update is complete.
     */
    update: (lat: number, lon: number, radius: number, maxItems: number) => Promise<void>;
}
/**
 * A class for tracking a nearest facility session and making it available as a
 * subscribable array of facilities.
 */
declare abstract class AbstractNearestSubscription<T extends Facility, TAdded, TRemoved> extends AbstractSubscribableArray<T> implements NearestSubscription<T> {
    protected readonly facilityLoader: FacilityLoader;
    protected readonly type: FacilitySearchType;
    protected readonly facilities: T[];
    protected readonly facilityIndex: Map<TRemoved, T>;
    protected session: NearestSearchSession<TAdded, TRemoved> | undefined;
    protected readonly startPromiseResolves: (() => void)[];
    protected readonly updatePromiseResolves: (() => void)[];
    private hasRequestedSession;
    private searchInProgress;
    /**
     * Creates an instance of a NearestSubscription.
     * @param facilityLoader An instance of the facility loader to search with.
     * @param type The type of facility to search for.
     */
    constructor(facilityLoader: FacilityLoader, type: FacilitySearchType);
    /** @inheritdoc */
    get length(): number;
    /**
     * Whether or not this subscription has been started.
     * @returns True if started, false otherwise.
     */
    get started(): boolean;
    /** @inheritdoc */
    getArray(): readonly T[];
    /** @inheritdoc */
    awaitStart(): Promise<void>;
    /** @inheritdoc */
    start(): Promise<void>;
    /** @inheritdoc */
    update(lat: number, lon: number, radius: number, maxItems: number): Promise<void>;
    /**
     * Executes an update of the nearest search subscription.
     * @param lat The latitude of the current search position.
     * @param lon The longitude of the current search position.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return in the search.
     */
    protected doUpdate(lat: number, lon: number, radius: number, maxItems: number): Promise<void>;
    /**
     * A callback called when results are received.
     * @param results The results that were received.
     */
    protected abstract onResults(results: NearestSearchResults<TAdded, TRemoved>): Promise<void>;
    /**
     * Adds a facility to the collection.
     * @param facility The facility to add.
     * @param key The key to track this facility by.
     */
    protected addFacility(facility: T, key: TRemoved): void;
    /**
     * Removes a facility from the collection.
     * @param key The key of the facility to remove.
     */
    protected removeFacility(key: TRemoved): void;
}
/**
 * A nearest search subscription for waypoint facilites, including logic for further filtering
 * of results beyond what the sim search API gives us.
 */
declare abstract class NearestWaypointSubscription<T extends Facility> extends AbstractNearestSubscription<T, string, string> {
    protected filterCb?: (facility: T) => boolean;
    protected readonly facilityCache: Map<string, T>;
    /**
     * Creates a new NearestWaypointSubscription.
     * @param facilityLoader An instance of the facility loader to search with.
     * @param type The type of facility to search for.
     * @param filterCb A function which filters results after they have been returned by this subscription's search
     * session. If not defined, no post-search session filtering will be performed.
     */
    constructor(facilityLoader: FacilityLoader, type: FacilitySearchType, filterCb?: (facility: T) => boolean);
    /**
     * Sets this subscription's post-search session filter and refilters this subscription's latest results using the new
     * filter.
     * @param filter A function which filters results after they have been returned by this subscription's search
     * session, or `undefined` if no post-search session filtering is to be performed.
     */
    setFilterCb(filter: ((facility: T) => boolean) | undefined): void;
    /**
     * Refilters the latest search results returned from this subscription's nearest search session.
     */
    protected refilter(): void;
    /** @inheritdoc */
    protected onResults(results: NearestSearchResults<string, string>): Promise<void>;
}
/**
 * A nearest search subscription for airport facilites.
 */
declare class NearestAirportSubscription extends NearestWaypointSubscription<AirportFacility> {
    /**
     * Creates a new NearestAirportSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     * @param filterCb A function which filters results after they have been returned by this subscription's search
     * session. If not defined, no post-search session filtering will be performed.
     */
    constructor(facilityLoader: FacilityLoader, filterCb?: (facility: AirportFacility) => boolean);
    /**
     * Sets the airport search filter.
     * @param showClosed Whether or not to return closed airports in the search.
     * @param classMask A bitmask representing the classes of airports to show.
     */
    setFilter(showClosed: boolean, classMask: number): void;
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedFilters(surfaceTypeMask: number, approachTypeMask: number, toweredMask: number, minRunwayLength: number): void;
}
/**
 * A nearest search subscription for intersection facilites.
 */
declare class NearestIntersectionSubscription extends NearestWaypointSubscription<IntersectionFacility> {
    protected readonly nonTerminalIcaosToFilter: Set<string>;
    protected filterDupTerminal: boolean;
    /**
     * Creates a new NearestIntersectionSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     * @param filterCb A function which filters results after they have been returned by this subscription's search
     * session. If not defined, no post-search session filtering will be performed.
     * @param filterDupTerminal Whether to filter out terminal intersections if their non-terminal counterparts are
     * also present in the subscription's results. Defaults to `false`.
     */
    constructor(facilityLoader: FacilityLoader, filterCb?: (facility: IntersectionFacility) => boolean, filterDupTerminal?: boolean);
    /**
     * Sets the intersection search filter.
     * @param typeMask A bitmask representing the classes of intersections to show.
     */
    setFilter(typeMask: number): void;
    /**
     * Sets whether to filter out terminal intersections if their non-terminal counterparts are also present in this
     * subscription's results and refilters this subscription's latest results accordingly.
     * @param filter Whether to filter out terminal intersections if their non-terminal counterparts are also present in
     * this subscription's results.
     */
    setFilterDupTerminal(filter: boolean): void;
    /** @inheritdoc */
    protected refilter(): void;
    /** @inheritdoc */
    protected onResults(results: NearestSearchResults<string, string>): Promise<void>;
}
/**
 * A nearest search subscription for VOR facilites.
 */
declare class NearestVorSubscription extends NearestWaypointSubscription<VorFacility> {
    /**
     * Creates a new NearestVorSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader: FacilityLoader);
    /**
     * Sets the VOR search filter.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask: number, typeMask: number): void;
}
/**
 * A nearest search subscription for NDB facilites.
 */
declare class NearestNdbSubscription extends NearestWaypointSubscription<NdbFacility> {
    /**
     * Creates a new NearestNdbSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader: FacilityLoader);
}
/**
 * A nearest search subscription for USR facilites.
 */
declare class NearestUsrSubscription extends NearestWaypointSubscription<UserFacility> {
    /**
     * Creates a new NearestUsrSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader: FacilityLoader);
}
/**
 * A wrapper for a {@link NearestSearchSession} that automatically adjusts the number of
 * search results requested from the sim to minimize search load while still attempting to
 * provide the total number of results needed by the user.
 */
declare class AdaptiveNearestSubscription<InnerType extends NearestSubscription<any>> extends AbstractSubscribableArray<NearestSubscriptionFacilityType<InnerType>> implements NearestSubscription<NearestSubscriptionFacilityType<InnerType>> {
    readonly innerSubscription: InnerType;
    private static readonly RAMP_UP_FACTOR;
    private static readonly RAMP_DOWN_FACTOR;
    private static readonly EMPTY_ARRAY;
    private readonly sortFunc;
    /** The array that holds the results of our latest search. */
    private readonly facilities;
    private readonly absoluteMaxItems;
    /** The number of items we are requesting from the inner search to meet current demands. */
    private derivedMaxItems;
    /** Whether we have a search in progress already. */
    private searchInProgress;
    /** A reusable GeoPoint for sorting by distance. */
    private readonly pos;
    private readonly diffMap;
    private readonly updatePromiseResolves;
    /**
     * Creates an instance of AdaptiveNearestSubscription.
     * @param innerSubscription A {@link NearestSubscription} to use as our inner search.
     * @param absoluteMaxItems The maximum number of results to request in any search.
     */
    constructor(innerSubscription: InnerType, absoluteMaxItems: number | Subscribable<number>);
    /** @inheritdoc */
    get length(): number;
    /** @inheritdoc */
    getArray(): readonly NearestSubscriptionFacilityType<InnerType>[];
    /** @inheritdoc */
    get started(): boolean;
    /** @inheritdoc */
    awaitStart(): Promise<void>;
    /** @inheritdoc */
    start(): Promise<void>;
    /** @inheritdoc */
    update(lat: number, lon: number, radius: number, maxItems: number): Promise<void>;
    /**
     * Executes an update of the nearest search subscription.
     * @param lat The latitude of the current search position.
     * @param lon The longitude of the current search position.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return in the search.
     */
    private doUpdate;
    /**
     * Finds the nearest facility in an array.
     * @param array A non-empty array of facilities.
     * @returns The nearest facility in the specified array.
     */
    private findNearest;
    /**
     * Diffs a new facility array against this subscription's current facility array, makes the necessary changes to
     * the current facility array so that it contains the same facilities as the new one, and notifies subscribers of the
     * changes.
     * @param newArray A new facility array.
     */
    private diffAndNotify;
}

/**
 * A vector describing one edge of a boundary shape.
 */
declare type LodBoundaryVector = {
    /** The path of this vector, or undefined if this is a starting vector. */
    circle?: GeoCircle;
    /** The end point of this vector. */
    end: GeoPointInterface;
};
/**
 * A single contiguous boundary shape.
 */
declare type LodBoundaryShape = LodBoundaryVector[];
/**
 * A boundary (airspace) with pre-processed LODs.
 */
declare class LodBoundary {
    readonly facility: BoundaryFacility;
    private static readonly geoCircleCache;
    private static readonly edgeCache;
    private static readonly queue;
    /** The Douglas-Peucker thresholds, in great-arc radians, used by each of this boundary's LOD levels. */
    readonly lodDistanceThresholds: readonly number[];
    private readonly lodVectorCountTargets;
    /** This boundary's LOD levels. Each LOD level contains one or more boundary shapes. */
    readonly lods: readonly (readonly Readonly<LodBoundaryShape>[])[];
    /**
     * Constructor.
     * @param facility This boundary's facility object.
     * @param lodDistanceThresholds The Douglas-Peucker thresholds, in great-arc radians, used by each LOD level. If
     * undefined or an empty array, only one LOD level (LOD0) will be created with a distance threshold of 0.
     * @param lodVectorCountTargets The vector count targets for each LOD level. The number of vectors per shape after
     * simplification will not exceed the LOD levels' target. Non-positive targets are interpreted as unlimited.
     * If undefined, all LOD levels will be assigned an unlimited vector count target.
     */
    constructor(facility: BoundaryFacility, lodDistanceThresholds?: readonly number[], lodVectorCountTargets?: readonly number[]);
    /**
     * Processes this boundary's LOD levels.
     * @returns This boundary's processed LOD levels.
     */
    private processLods;
    /**
     * Processes this boundary's facility's vectors into boundary shapes.
     * @param vectors The vectors to process.
     * @returns Boundary shapes corresponding to this boundary's facility's vectors.
     */
    private processShapes;
    /**
     * Processes a single, non-circle boundary shape from this boundary's facility's vectors.
     * @param shape The shape to be processed.
     * @param vectors The array containing the facility boundary vectors making up the shape.
     * @param index The index of the first facility boundary vector which makes up the shape.
     * @returns The index of the last facility boundary vector which makes up the shape.
     */
    private processShape;
    /**
     * Processes a single circle boundary shape from this boundary's facility's vectors.
     * @param shape The shape to be processed.
     * @param vectors The array containing the facility boundary vectors making up the shape.
     * @param index The index of the first facility boundary vector which makes up the shape.
     * @returns The index of the last facility boundary vector which makes up the shape.
     */
    private processCircle;
    /**
     * Simplifies boundary shapes using the Douglas-Peucker algorithm.
     * @param shapes The boundary shapes to simplify.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param vectorCountTarget The vector count target for the simplified shapes. An undefined value is interpreted as
     * an unlimited target.
     * @returns The simplified boundary shapes.
     */
    private simplifyShapes;
    /**
     * Simplifies a boundary shape using the Douglas-Peucker algorithm.
     * @param shape The boundary shape to simplify.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param vectorCountTarget The vector count target for the simplified shape. An undefined value is interpreted as
     * an unlimited target.
     * @returns The simplified boundary shape.
     */
    private simplifyShape;
    /**
     * Simplifies a sequence of vectors in a boundary shape using the Douglas-Peucker algorithm.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param shape The boundary shape containing the vectors to simplify.
     * @param startIndex The index of the first vector in the sequence to simplify, inclusive.
     * @param endIndex The index of the last vector in the sequence to simplify, exclusive.
     * @param retain An array of boolean values indicating which vectors in the shape to retain after simplification.
     */
    private simplify;
    /**
     * Simplifies a sequence of vectors in a boundary shape using the Douglas-Peucker algorithm to a target vector count.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param vectorCountTarget The vector count target for the simplified shape.
     * @param shape The boundary shape containing the vectors to simplify.
     * @param startIndex The index of the first vector in the sequence to simplify, inclusive.
     * @param endIndex The index of the last vector in the sequence to simplify, exclusive.
     * @param retain An array of boolean values indicating which vectors in the shape to retain after simplification.
     */
    private simplifyToVectorCount;
    /**
     * Computes an edge and inserts it into a priority queue if the distance from the edge to the farthest vector is
     * greater than a specified distance threshold.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param shape The boundary shape containing the vectors to simplify.
     * @param startIndex The index of the vector at the start of the edge.
     * @param endIndex The index of the vector at the end of the edge.
     * @param queue The priority queue into which to insert the edge.
     * @param edgeIndex The index from which to retrieve an edge from the edge cache, if needed.
     */
    private computeAndInsertEdgeToQueue;
    /**
     * Finds the vector in a boundary shape containing the farthest point from a reference.
     * @param shape The shape containing the vectors to search.
     * @param startIndex The index of the first vector to search, inclusive.
     * @param endIndex The index of the last vector to search, exclusive.
     * @param reference The reference to which to measure distance.
     * @returns The index of the vector containing the farthest point from a reference, and the corresponding distance in great-arc radians.
     */
    private findFarthestVector;
    /**
     * Calculates the maximum distance from a vector in a boundary shape to a reference.
     * @param shape The shape containing the vector to query.
     * @param index The index of the vector to query.
     * @param reference The reference to which to measure the distance.
     * @returns The maximum distance from the vector to the reference, in great-arc radians.
     */
    private getDistanceFromReference;
    /**
     * Rebuilds vectors for a simplified shape.
     * @param shape The original shape.
     * @param retain An array of boolean values indicating which vectors in the shape to retain after simplification.
     * @param simplified The simplified shape to which to add the rebuilt vectors.
     */
    private rebuildSimplifiedVectors;
    /**
     * Copies a boundary shape vector.
     * @param source The vector to copy.
     * @returns A copy of `source`.
     */
    private static copyVector;
    /**
     * Creates an edge.
     * @returns An edge.
     */
    private static createEdge;
}

/**
 * A cache of LodBoundary objects.
 */
declare class LodBoundaryCache {
    readonly size: number;
    readonly lodDistanceThresholds: readonly number[];
    readonly lodVectorCountTargets: readonly number[];
    private readonly cache;
    /**
     * Constructor.
     * @param size The maximum size of this cache.
     * @param lodDistanceThresholds The Douglas-Peucker distance thresholds, in great-arc radians, for each LOD level
     * used by this cache's LodBoundary objects.
     * @param lodVectorCountTargets The vector count targets for each LOD level used by this cache's LodBoundary objects.
     */
    constructor(size: number, lodDistanceThresholds: readonly number[], lodVectorCountTargets: readonly number[]);
    /**
     * Retrieves a LodBoundary from this cache corresponding to a boundary facility. If the requested LodBoundary does
     * not exist, it will be created and added to this cache.
     * @param facility A boundary facility.
     * @returns The LodBoundary corresponding to `facility`.
     */
    get(facility: BoundaryFacility): LodBoundary;
    /**
     * Creates a new LodBoundary and adds it to this cache.
     * @param facility The facility from which to create the new LodBoundary.
     * @returns The newly created LodBoundary.
     */
    private create;
}

/**
 * Results of a nearest LodBoundary search.
 */
declare type NearestLodBoundarySearchResults = {
    /** The boundaries found in these search results that were not returned in the last search. */
    added: readonly LodBoundary[];
    /** The unique IDs of the boundaries returned in the last search that are not found in these search results. */
    removed: readonly number[];
};
/**
 * A nearest search session for boundaries (airspaces) in the form of LodBoundary objects.
 */
declare class NearestLodBoundarySearchSession {
    private readonly cache;
    private readonly session;
    readonly frameBudget: number;
    /**
     * Constructor.
     * @param cache The boundary cache this search session uses.
     * @param session The nearest boundary facility search session this search session uses.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     */
    constructor(cache: LodBoundaryCache, session: NearestBoundarySearchSession, frameBudget: number);
    /**
     * Searches for the nearest boundaries around a specified location.
     * @param lat The latitude of the search center, in degrees.
     * @param lon The longitude of the search center, in degrees.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items for which to search.
     * @returns The nearest search results.
     */
    searchNearest(lat: number, lon: number, radius: number, maxItems: number): Promise<NearestLodBoundarySearchResults>;
    /**
     * Sets this session's boundary class filter. The new filter takes effect with the next search executed in this
     * session.
     * @param classMask A bitmask defining the boundary classes to include in the search (`0`: exclude, `1`: include).
     * The bit index for each boundary class is equal to the value of the corresponding `BoundaryType` enum.
     */
    setFilter(classMask: number): void;
}

/**
 * The state of a calculating flight path.
 */
interface FlightPathState {
    /** The current position of the flight path. */
    currentPosition: GeoPoint | undefined;
    /** The current true course bearing of the flight path. */
    currentCourse: number | undefined;
    /** Whether the flight path is in a fallback state. */
    isFallback: boolean;
    /** The position of the airplane. */
    readonly planePosition: GeoPointReadOnly;
    /** The true heading of the airplane. */
    readonly planeHeading: number;
    /** The altitude of the airplane. */
    readonly planeAltitude: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The ground speed of the airplane. */
    readonly planeSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The climb rate of the airplane. */
    readonly planeClimbRate: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The desired radius for general turns. */
    readonly desiredTurnRadius: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The desired radius for turns in holds. */
    readonly desiredHoldTurnRadius: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The desired radius for turns in course reversals. */
    readonly desiredCourseReversalTurnRadius: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The desired radius for anticipated leg-to-leg turns. */
    readonly desiredTurnAnticipationTurnRadius: NumberUnitReadOnly<UnitFamily.Distance>;
}

/**
 * A flight path vector turn direction.
 */
declare type VectorTurnDirection = 'left' | 'right';
/**
 * The transition type to which a flight path vector belongs.
 */
declare enum FlightPathVectorFlags {
    None = 0,
    /** A turn to a specific course. */
    TurnToCourse = 1,
    /** An arcing turn to a specific point. */
    Arc = 2,
    /** A direct course to a specific point. */
    Direct = 4,
    /** A path to intercept a specific course. */
    InterceptCourse = 8,
    /** Inbound leg of a hold. */
    HoldInboundLeg = 16,
    /** Outbound leg of a hold. */
    HoldOutboundLeg = 32,
    /** A direct hold entry. */
    HoldDirectEntry = 64,
    /** A teardrop hold entry. */
    HoldTeardropEntry = 128,
    /** A parallel hold entry. */
    HoldParallelEntry = 256,
    /** A course reversal. */
    CourseReversal = 512,
    /** A turn from one leg to another. */
    LegToLegTurn = 1024,
    /** An anticipated turn from one leg to another. */
    AnticipatedTurn = 2048,
    /** A fallback path. */
    Fallback = 4096
}
/**
 * A basic flight path vector.
 */
interface BaseFlightPathVector {
    /** The type of vector. */
    vectorType: string;
    /** Bit flags describing the vector. */
    flags: number;
    /** The latitude of the start of the vector. */
    startLat: number;
    /** The longitude of the start of the vector. */
    startLon: number;
    /** The latitude of the end of the vector. */
    endLat: number;
    /** The longitude of the end of the vector. */
    endLon: number;
    /** The total distance of the vector, in meters. */
    distance: number;
}
/**
 * A flight path vector whose path is defined by a geo circle.
 */
interface CircleVector extends BaseFlightPathVector {
    /** The type of vector. */
    vectorType: 'circle';
    /** The radius of the circle, in great-arc radians. */
    radius: number;
    /** The x-coordinate of the center of the circle. */
    centerX: number;
    /** The y-coordinate of the center of the circle. */
    centerY: number;
    /** The z-coordinate of the center of the circle. */
    centerZ: number;
}
/**
 * A flight path vector within a leg flight path calculation.
 */
declare type FlightPathVector = CircleVector;
/**
 * The details of procedures selected in the flight plan.
 */
declare class ProcedureDetails {
    /** The origin runway object, consisting of the index of the origin runway
     * in the origin runway information and the direction. */
    originRunway: OneWayRunway | undefined;
    /** The ICAO for the facility associated with the departure procedure. */
    departureFacilityIcao: string | undefined;
    /** The index of the departure in the origin airport information. */
    departureIndex: number;
    /** The index of the departure transition in the origin airport departure information. */
    departureTransitionIndex: number;
    /** The index of the selected runway in the original airport departure information. */
    departureRunwayIndex: number;
    /** The ICAO for the facility associated with the arrival procedure. */
    arrivalFacilityIcao: string | undefined;
    /** The index of the arrival in the destination airport information. */
    arrivalIndex: number;
    /** The index of the arrival transition in the destination airport arrival information. */
    arrivalTransitionIndex: number;
    /** The index of the selected runway transition at the destination airport arrival information. */
    arrivalRunwayTransitionIndex: number;
    /** The arrival runway object, consisting of the index of the destination runway
     * in the destination runway information and the direction. */
    arrivalRunway: OneWayRunway | undefined;
    /** The ICAO for the facility associated with the approach procedure. */
    approachFacilityIcao: string | undefined;
    /** The index of the apporach in the destination airport information.*/
    approachIndex: number;
    /** The index of the approach transition in the destination airport approach information.*/
    approachTransitionIndex: number;
    /** The destination runway object, consisting of the index of the destination runway
     * in the destination runway information and the direction. */
    destinationRunway: OneWayRunway | undefined;
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
declare enum FlightPlanSegmentType {
    Origin = "Origin",
    Departure = "Departure",
    Enroute = "Enroute",
    Arrival = "Arrival",
    Approach = "Approach",
    Destination = "Destination",
    MissedApproach = "MissedApproach",
    RandomDirectTo = "RandomDirectTo"
}
/**
 * A segment of a flight plan.
 */
declare class FlightPlanSegment {
    segmentIndex: number;
    offset: number;
    legs: LegDefinition[];
    segmentType: FlightPlanSegmentType;
    airway?: string | undefined;
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex: number, offset: number, legs: LegDefinition[], segmentType?: FlightPlanSegmentType, airway?: string | undefined);
    /** An empty flight plan segment. */
    static Empty: FlightPlanSegment;
}
/**
 * Metadata about a particular flight plan leg.
 */
interface LegCalculations {
    /** The magnetic variation, in degrees, used when calculating this leg's course. */
    courseMagVar: number;
    /** The initial DTK of the leg in degrees magnetic. */
    initialDtk: number | undefined;
    /** The leg's total distance in meters, not cut short by ingress/egress turn radii. */
    distance: number;
    /** The cumulative distance in meters up to this point in the flight plan. */
    cumulativeDistance: number;
    /** The leg's total distance in meters, with leg transition turns take into account. */
    distanceWithTransitions: number;
    /** The cumulative distance in meters up to this point, with leg transition turns taken into account. */
    cumulativeDistanceWithTransitions: number;
    /** The latitude of the start of the leg. */
    startLat: number | undefined;
    /** The longitude of the start of the leg. */
    startLon: number | undefined;
    /** The latitude of the end of the leg. */
    endLat: number | undefined;
    /** The longitude of the end of the leg. */
    endLon: number | undefined;
    /** The calculated flight path for the leg. */
    flightPath: FlightPathVector[];
    /** The leg's flight path ingress transition. */
    ingress: FlightPathVector[];
    /** The index of the flight path vector in `flightPath` to which the ingress transition is joined. */
    ingressJoinIndex: number;
    /** The leg's flight path between the ingress and egress transitions. */
    ingressToEgress: FlightPathVector[];
    /** The index of the flight path vector in `flightPath` to which the egress transition is joined. */
    egressJoinIndex: number;
    /** The leg's flight path egress transition. */
    egress: FlightPathVector[];
    /** Whether the leg's flight path ends in a fallback state. */
    endsInFallback: boolean;
}
/**
 * Bitflags describing a leg definition.
 */
declare enum LegDefinitionFlags {
    None = 0,
    DirectTo = 1,
    MissedApproach = 2,
    Obs = 4,
    VectorsToFinal = 8,
    VectorsToFinalFaf = 16
}
/**
 * Vertical flight phase.
 */
declare enum VerticalFlightPhase {
    Climb = "Climb",
    Descent = "Descent"
}
/**
 * Vertical metadata about a flight plan leg.
 */
interface VerticalData {
    /** The vertical flight phase for the leg. */
    phase: VerticalFlightPhase;
    /** The type of altitude restriction for the leg. */
    altDesc: AltitudeRestrictionType;
    /** The first altitude field for restrictions, in meters. */
    altitude1: number;
    /** The second altitude field for restrictions, in meters. */
    altitude2: number;
    /** Whether altitude 1 should be displayed as a flight level. */
    displayAltitude1AsFlightLevel: boolean;
    /** Whether altitude 2 should be displayed as a flight level. */
    displayAltitude2AsFlightLevel: boolean;
    /** The optional speed restriction for this leg, in knots IAS or Mach, depends on speedUnit. */
    speed: number;
    /** The type of speed restriction for the leg. */
    speedDesc: SpeedRestrictionType;
    /** The speed unit. */
    speedUnit: SpeedUnit;
    /** The FPA for this constraint, in degrees, optional. */
    fpa?: number;
}
/** Just the simple altitude constraint fields from the {@link VerticalData} interface. */
declare type AltitudeConstraintSimple = Pick<VerticalData, 'altDesc' | 'altitude1' | 'displayAltitude1AsFlightLevel'>;
/** Just the advanced altitude constraint fields from the {@link VerticalData} interface. */
declare type AltitudeConstraintAdvanced = AltitudeConstraintSimple & Pick<VerticalData, 'altitude2' | 'displayAltitude2AsFlightLevel'>;
/** Just the speed constraint fields from the {@link VerticalData} interface. */
declare type SpeedConstraint = Pick<VerticalData, 'speedDesc' | 'speed' | 'speedUnit'>;
declare enum SpeedUnit {
    IAS = 0,
    MACH = 1
}
/** Types of speed restrictions on legs. */
declare enum SpeedRestrictionType {
    Unused = 0,
    At = 1,
    AtOrAbove = 2,
    AtOrBelow = 3,
    Between = 4
}
/**
 * A definition of a leg in a flight plan.
 */
interface LegDefinition {
    /** The display name of the leg. */
    readonly name?: string;
    /** The calculated leg data. */
    calculated?: LegCalculations;
    /** The leg of the flight plan. */
    leg: Readonly<FlightPlanLeg>;
    /** Leg definition flags. See {@link LegDefinitionFlags}. Use BitFlags to check. */
    readonly flags: number;
    /** Vertical Leg Data. All the fields should be readonly except for calculated fields like `fpa`. */
    readonly verticalData: Readonly<VerticalData> & Pick<VerticalData, 'fpa'>;
}

/**
 * Builds circle vectors.
 */
declare class CircleVectorBuilder {
    private static readonly geoCircleCache;
    /**
     * Builds a circle vector and adds it to a sequence.
     * @param vectors The flight path vector sequence to which to add the vector.
     * @param index The index in the sequence at which to add the vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence, which is always equal to 1.
     */
    build(vectors: FlightPathVector[], index: number, direction: VectorTurnDirection, radius: number, center: ReadonlyFloat64Array | LatLonInterface, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, flags?: number): 1;
    /**
     * Builds a circle vector and adds it to a sequence.
     * @param vectors The flight path vector sequence to which to add the vector.
     * @param index The index in the sequence at which to add the vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence, which is always equal to 1.
     */
    build(vectors: FlightPathVector[], index: number, circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, flags?: number): 1;
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    private setFromPoints;
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    private setFromCircle;
}
/**
 * Builds great-circle paths between defined start and end points.
 */
declare class GreatCircleBuilder {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private readonly circleVectorBuilder;
    /**
     * Builds a sequence of vectors representing a great-circle path between two points. The great circle path chosen is
     * the shortest great-circle path between the two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, initialCourse?: number, flags?: number): number;
    /**
     * Builds a sequence of vectors representing a great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, path: GeoCircle, end: ReadonlyFloat64Array | LatLonInterface, flags?: number): number;
    /**
     * Builds a sequence of vectors representing a great-circle path between two points. The end point is chosen such
     * that it is offset from the start point by a specified distance.
     * @param vectors
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param distance The distance along the path between the start and end points, in meters.
     * @param flags The flags to set on the vector. Defaults to none (0).
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, path: GeoCircle, distance: number, flags?: number): number;
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    private buildFromEndpoints;
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    private buildFromPath;
}
/**
 * Builds constant-radius turns toward specified course bearings.
 */
declare class TurnToCourseBuilder {
    private static readonly geoPointCache;
    private readonly circleVectorBuilder;
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence. If the difference between the initial and final course is small enough such that the start and end of
     * the turn are identical, no turn will be added to the vector sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, radius: number, direction: VectorTurnDirection, fromCourse: number, toCourse: number, flags?: FlightPathVectorFlags): number;
}
/**
 * Builds great-circle paths to intercept other geo circles.
 */
declare class CircleInterceptBuilder {
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly greatCircleBuilder;
    private readonly circleVectorBuilder;
    /**
     * Builds a sequence of vectors representing a great-circle path from a defined start point to an intersection with
     * another geo circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param course The initial true course bearing.
     * @param circle The circle to intercept.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, course: number, circle: GeoCircle, flags?: number): number;
    /**
     * Builds a sequence of vectors representing a path from a defined start point to an intersection with another geo
     * circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The initial path.
     * @param circle The circle to intercept.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` does not lie on `startPath`.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, circle: GeoCircle, flags?: number): number;
}
/**
 * Builds constant-radius turns to join great-circle paths.
 */
declare class TurnToJoinGreatCircleBuilder {
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private readonly circleVectorBuilder;
    /**
     * Builds an arc representing a turn from a defined start point and initial course toward a defined target great-
     * circle path, ending at the point in the turn circle which is closest to the target path.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startCourse The initial true course bearing.
     * @param endPath The great-circle path defining the target course.
     * @param radius The radius of the turn, in meters.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence, which is always equal to 1.
     * @throws Error if `endPath` is not a great circle.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startCourse: number, endPath: GeoCircle, radius: number, flags?: number): 1;
    /**
     * Builds an arc representing a turn from a defined start point and initial course toward a defined target great-
     * circle path, ending at the point in the turn circle which is closest to the target path.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param endPath The great-circle path defining the target course.
     * @param radius The radius of the turn, in meters.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence, which is always equal to 1.
     * @throws Error if `startPath` or `endPath` is not a great circle, or if `start` does not lie on `startPath`.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, endPath: GeoCircle, radius: number, flags?: number): 1;
}
/**
 * Builds paths to connect two geo circles.
 */
declare class ConnectCirclesBuilder {
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly circleVectorBuilder;
    /**
     * Builds a sequence of vectors representing a path which consists of a single geo circle which connects two other
     * circles and optionally paths to link the connecting circle with a start point on the from circle and an end point
     * on the to circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param fromCircle The circle from which to add the connecting circle.
     * @param toCircle The circle to which to add the connecting circle.
     * @param radius The radius, in meters, of the circle to join the two circles. If not defined, defaults to pi / 2
     * times the radius of the Earth (and therefore the connecting circle will be a great circle).
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @param fromCircleVectorFlags The flags to set on the vector along `fromCircle`. Defaults to none (0).
     * @param toCircleVectorFlags The flags to set on the vector along the `toCircle`. Defaults to none (0).
     * @param connectVectorFlags The flags to set on the vector connecting `fromCircle` to `toCircle`. Defaults to none
     * (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, fromCircle: GeoCircle, toCircle: GeoCircle, radius?: number, from?: ReadonlyFloat64Array | LatLonInterface, to?: ReadonlyFloat64Array | LatLonInterface, fromCircleVectorFlags?: number, toCircleVectorFlags?: number, connectVectorFlags?: number): number;
    /**
     * Finds a GeoCircle which connects (is tangent to) two other circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param radius The desired radius of the connecting circle, in great-arc radians.
     * @param out A GeoCircle object to which to write the result.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns a GeoCircle which connects the two circles, or null if one could not be found.
     */
    private findCircleToJoinCircles;
    /**
     * Calculates the total distance along the joining path between two circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param joinCircle The connecting circle.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns the total distance along the joining path, in great-arc radians.
     */
    private calculateJoinCirclesPathDistance;
}
/**
 * Builds paths connecting initial great circle paths to final great circle paths via a turn starting at the start
 * point and a turn ending at the end point, connected by a great-circle path.
 */
declare class TurnToJoinGreatCircleAtPointBuilder {
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private readonly connectCirclesBuilder;
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * connects with another turn via a great-circle path to terminate at a defined end point and final course.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters.
     * @param endTurnDirection The direction of the final turn.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0).
     * @param connectVectorFlags The flags to set on the vector along the great-circle path connecting the turns.
     * Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, startTurnRadius: number, startTurnDirection: VectorTurnDirection, end: ReadonlyFloat64Array | LatLonInterface, endPath: GeoCircle, endTurnRadius: number, endTurnDirection: VectorTurnDirection, startTurnVectorFlags?: number, endTurnVectorFlags?: number, connectVectorFlags?: number): number;
}
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths via a turn starting at the start
 * point followed by an angled intercept path which intercepts the final path before the end point.
 */
declare class InterceptGreatCircleToPointBuilder {
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly circleVectorBuilder;
    private readonly turnToJoinGreatCircleBuilder;
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * intercepts a final course at a specified angle using a great-circle path. Optionally includes a final turn from
     * the intercept path to the final course.
     *
     * If an intercept angle greater than the minimum angle is required to intercept the final course before the end
     * point, no vectors will be calculated.
     *
     * If the initial and final courses are parallel, no vectors will be calculated.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn. If not defined, the direction of the initial turn
     * will be automatically selected.
     * @param interceptAngle The angle at which to intercept the final path, in degrees. Will be clamped to the range
     * `[0, 90]`.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters, or `undefined` if a turn to join the final path
     * should not be calculated.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param interceptVectorFlags The flags to set on the vector along the intercept path. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0). Ignored if a turn to
     * join the final path is not calculated.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, startTurnRadius: number, startTurnDirection: VectorTurnDirection | undefined, interceptAngle: number, end: ReadonlyFloat64Array | LatLonInterface, endPath: GeoCircle, endTurnRadius?: number, startTurnVectorFlags?: number, interceptVectorFlags?: number, endTurnVectorFlags?: number): number;
}
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
declare class JoinGreatCircleToPointBuilder {
    private static readonly INTERCEPT_ANGLE;
    private static readonly vec3Cache;
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly circleVectorBuilder;
    private readonly greatCircleBuilder;
    private readonly turnToJoinGreatCircleBuilder;
    private readonly interceptGreatCircleToPointBuilder;
    private readonly directToPointBuilder;
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     *
     * This method will first attempt to connect the starting point and final path with a single constant-radius turn
     * of at least the minimum turn radius and in the desired direction that joins the final path before the end point.
     * If this is not possible, then what happens next depends on the `preferSingleTurn` argument:
     * * If it is `true`, then another path connecting the starting point and final path with a single constant-radius
     * turn will be computed - this path will respect the minimum turn radius but not necessarily the desired turn
     * direction.
     * * If it is `false`, then a path to intercept the final path at a 45-degree angle will be computed. If such a path
     * is not possible or if the intercept point lies after the end point, and `allowDirectFallback` is `true`, a direct
     * course to the end point will be computed. If `allowDirectFallback` is `false` and all attempts to compute a path
     * have failed, then no vectors will be built.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param preferSingleTurn Whether to prefer flight path solutions that consist of a single constant-radius turn
     * from the initial to final course. Defaults to `false`.
     * @param allowDirectFallback Whether the computed path should fall back to a direct course to the end point if the
     * final path cannot be joined before the end point. Defaults to `true`.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @param includeDirectFlag Whether to include the `Direct` flag on vectors when falling back to a direct course.
     * Defaults to `true`.
     * @param includeInterceptFlag Whether to include the `InterceptCourse` flag on vectors when building an intercept
     * path. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, end: ReadonlyFloat64Array | LatLonInterface, endPath: GeoCircle, desiredTurnDirection?: VectorTurnDirection, minTurnRadius?: number, preferSingleTurn?: boolean, allowDirectFallback?: boolean, intersection?: ReadonlyFloat64Array, flags?: number, includeTurnToCourseFlag?: boolean, includeDirectFlag?: boolean, includeInterceptFlag?: boolean): number;
}
/**
 * Builds procedure turns.
 */
declare class ProcedureTurnBuilder {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private static readonly intersectionCache;
    private readonly greatCircleBuilder;
    private readonly circleVectorBuilder;
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @param flags The flags to set on the vectors. Defaults to the `CourseReversal` flag.
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, end: ReadonlyFloat64Array | LatLonInterface, endPath: GeoCircle, outboundCourse: number, desiredTurnRadius: number, desiredTurnDirection?: VectorTurnDirection, initialCourse?: number, finalCourse?: number, flags?: FlightPathVectorFlags, includeTurnToCourseFlag?: boolean): number;
}
/**
 * Builds paths directly connecting a defined initial point and course and a defined end point.
 */
declare class DirectToPointBuilder {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private readonly circleVectorBuilder;
    private readonly greatCircleBuilder;
    /**
     * Builds a sequence of vectors representing a path which consists of an optional turn from an initial point and
     * course toward an end point followed by an optional great-circle path terminating at the end point.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startCourse The initial course.
     * @param end The end point.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction. If undefined, a turn direction will be chosen such that
     * the initial turn is always toward the end point.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. Defaults to `true`.
     * @param includeDirectFlag Whether to include the `Direct` flag on the vectors. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startCourse: number, end: ReadonlyFloat64Array | LatLonInterface, desiredTurnRadius: number, desiredTurnDirection?: VectorTurnDirection, flags?: number, includeTurnToCourseFlag?: boolean, includeDirectFlag?: boolean): number;
    /**
     * Builds a sequence of vectors representing a path which consists of an optional turn from an initial point and
     * course toward an end point followed by an optional great-circle path terminating at the end point.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction. If undefined, a turn direction will be chosen such that
     * the initial turn is always toward the end point.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. Defaults to `true`.
     * @param includeDirectFlag Whether to include the `Direct` flag on the vectors. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors: FlightPathVector[], index: number, start: ReadonlyFloat64Array | LatLonInterface, startPath: GeoCircle, end: ReadonlyFloat64Array | LatLonInterface, desiredTurnRadius: number, desiredTurnDirection?: VectorTurnDirection, flags?: number, includeTurnToCourseFlag?: boolean, includeDirectFlag?: boolean): number;
}

/**
 * A flight path calculator for individual flight plan legs.
 */
interface FlightPathLegCalculator {
    /**
     * Calculates flight path vectors for a flight plan leg and adds the calculations to the leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns The flight plan leg calculations.
     */
    calculate(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState, resolveIngressToEgress?: boolean): LegCalculations;
}
/**
 * Abstract implementation of FlightPathLegCalculator.
 */
declare abstract class AbstractFlightPathLegCalculator implements FlightPathLegCalculator {
    protected readonly facilityCache: Map<string, Facility>;
    protected readonly skipWhenActive: boolean;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache: Map<string, Facility>, skipWhenActive?: boolean);
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    protected getPositionFromIcao(icao: string, out: GeoPoint): GeoPoint | undefined;
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    protected getTerminatorPosition(leg: FlightPlanLeg, icao: string, out: GeoPoint): GeoPoint | undefined;
    /**
     * Gets the magnetic variation, in degrees, to use when calculating a flight plan leg's course. If the leg defines
     * an origin or fix VOR facility, then the magnetic variation defined at the VOR is used. Otherwise the computed
     * magnetic variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The magnetic variation, in degrees, to use when calculating the specified flight plan leg's course.
     */
    protected getLegMagVar(leg: FlightPlanLeg, point: LatLonInterface): number;
    /**
     * Gets the true course, in degrees, for a flight plan leg. If the leg defines an origin or fix VOR facility, then
     * the magnetic variation defined at the VOR is used to adjust magnetic course. Otherwise the computed magnetic
     * variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The true course, in degrees, for the flight plan leg.
     */
    protected getLegTrueCourse(leg: FlightPlanLeg, point: LatLonInterface): number;
    /** @inheritdoc */
    calculate(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState, resolveIngressToEgress?: boolean): LegCalculations;
    /**
     * Checks whether vector calculations should be skipped when the leg to calculate is the active leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns Whether to skip vector calculations.
     */
    protected shouldSkipWhenActive(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): boolean;
    /**
     * Calculates the magnetic variation for a flight plan leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns The number of vectors added to the sequence.
     */
    protected abstract calculateMagVar(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    /**
     * Calculates flight path vectors for a flight plan leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns The number of vectors added to the sequence.
     */
    protected abstract calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    /**
     * Calculates the ingress to egress vectors for a flight plan leg and adds them to a leg calculation.
     * @param legCalc The calculations for a flight plan leg.
     */
    protected resolveIngressToEgress(legCalc: LegCalculations): void;
}
/**
 * Calculates flight path vectors for legs with no path.
 */
declare class NoPathLegCalculator extends AbstractFlightPathLegCalculator {
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
declare class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    private readonly geoPointCache;
    private readonly greatCircleBuilder;
    private readonly directToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
declare class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly vec3Cache: Float64Array[];
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly directToPointBuilder: DirectToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
declare abstract class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly vec3Cache: Float64Array[];
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly circleVectorBuilder: CircleVectorBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    /**
     * Gets the center of the turn defined by a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The center of the turn defined by the flight plan leg, or undefined if it could not be determined.
     */
    protected abstract getTurnCenter(leg: FlightPlanLeg): LatLonInterface | undefined;
    /**
     * Gets the radius of the turn defined by a flight plan leg.
     * @param leg A flight plan leg.
     * @param center The center of the turn.
     * @returns The radius of the turn defined by the flight plan leg, or undefined if it could not be determined.
     */
    protected abstract getTurnRadius(leg: FlightPlanLeg, center: LatLonInterface): number | undefined;
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
declare class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    protected readonly geoPointCache: GeoPoint[];
    /** @inheritdoc */
    protected getTurnCenter(leg: FlightPlanLeg): LatLonInterface | undefined;
    /** @inheritdoc */
    protected getTurnRadius(leg: FlightPlanLeg, center: LatLonInterface): number | undefined;
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
declare class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    /** @inheritdoc */
    protected getTurnCenter(leg: FlightPlanLeg): LatLonInterface | undefined;
    /** @inheritdoc */
    protected getTurnRadius(leg: FlightPlanLeg, center: LatLonInterface): number | undefined;
}
/**
 * Information about a geo circle path to intercept.
 */
declare type CircleInterceptPathInfo = {
    /** The geo circle defining the path to intercept. */
    circle: GeoCircle | undefined;
    /** The start of the path to intercept. */
    start: LatLonInterface | undefined;
    /** The end of the path to intercept. */
    end: LatLonInterface | undefined;
};
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
declare abstract class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly includeInitialTurn: boolean;
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly intersectionCache;
    private readonly turnBuilder;
    private readonly directToPointBuilder;
    private readonly interceptBuilder;
    private readonly interceptInfo;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache: Map<string, Facility>, includeInitialTurn: boolean);
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    private readonly handleInvalidInterceptCache;
    /**
     * Checks if a path to intercept cannot be intercepted from a defined starting point and intercept course, and
     * calculates a fallback intercept point if so.
     * @param start The start point.
     * @param interceptPath The great-circle path defining the intercept course.
     * @param pathToInterceptCircle The geo circle defining the path to intercept.
     * @param pathToInterceptStart The start of the path to intercept.
     * @param pathToInterceptEnd The end of the path to intercept.
     * @param pathToInterceptAngularWidth The angular width of the path to intercept, in radians.
     * @param onlyHandleInitialPointPastIntercept Whether to only handle cases where the start point is located beyond
     * the path to intercept as measured along the intercept course.
     * @param forceFallback Whether to treat the case where the path to intercept can be intercepted from the starting
     * point and intercept course as a fallback case. If `true`, the natural intercept point will be returned as the
     * fallback intercept point.
     * @param out The vector to which to write the result.
     * @returns The fallback intercept point, or `undefined` if a fallback is not necessary.
     */
    private calculateFallbackIntercept;
    /**
     * Gets the true intercept course bearing defined by a flight plan leg.
     * @param legs A sequence of leg definitions.
     * @param index The index in the sequence of the leg from which to get the course.
     * @param state The current flight path state.
     * @returns The true intercept course bearing defined by the flight plan leg, or undefined if it could not be
     * determined.
     */
    protected abstract getInterceptCourse(legs: LegDefinition[], index: number, state: FlightPathState): number | undefined;
    /**
     * Gets the geo circle path to intercept defined by a flight plan leg.
     * @param legs A sequence of leg definitions.
     * @param index The index in the sequence of the leg from which to get the course.
     * @param state The current flight path state.
     * @param out The path info object to which to write the result.
     * @returns Information on the geo circle path to intercept defined by the flight plan leg.
     */
    protected abstract getInterceptPathInfo(legs: LegDefinition[], index: number, state: FlightPathState, out: CircleInterceptPathInfo): CircleInterceptPathInfo;
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
declare class CourseToDmeLegCalculator extends CircleInterceptLegCalculator {
    private readonly dmeCircle;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    /** @inheritdoc */
    protected getInterceptCourse(legs: LegDefinition[], index: number): number | undefined;
    /** @inheritdoc */
    protected getInterceptPathInfo(legs: LegDefinition[], index: number, state: FlightPathState, out: CircleInterceptPathInfo): CircleInterceptPathInfo;
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
declare class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    private readonly radialCircle;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    /** @inheritdoc */
    protected getInterceptCourse(legs: LegDefinition[], index: number): number | undefined;
    /** @inheritdoc */
    protected getInterceptPathInfo(legs: LegDefinition[], index: number, state: FlightPathState, out: CircleInterceptPathInfo): CircleInterceptPathInfo;
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
declare class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    /** @inheritdoc */
    protected getInterceptCourse(legs: LegDefinition[], index: number, state: FlightPathState): number | undefined;
    /** @inheritdoc */
    protected getInterceptPathInfo(legs: LegDefinition[], index: number, state: FlightPathState, out: CircleInterceptPathInfo): CircleInterceptPathInfo;
    private readonly predictLegPathCache;
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    private predictLegPath;
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
declare class FixToDmeLegCalculator extends AbstractFlightPathLegCalculator {
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly intersectionCache;
    private readonly greatCircleBuilder;
    private readonly directToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
declare class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly greatCircleBuilder;
    private readonly directToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
declare class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    private static readonly FALLBACK_INELIGIBLE_LEG_TYPES;
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly intersectionCache;
    private readonly circleVectorBuilder;
    private readonly greatCircleBuilder;
    private readonly joinGreatCircleToPointBuilder;
    private readonly procTurnBuilder;
    private readonly directToPointBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    /** @inheritdoc */
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for procedure turn legs.
 */
declare class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly greatCircleBuilder: GreatCircleBuilder;
    protected readonly joinGreatCircleToPointBuilder: JoinGreatCircleToPointBuilder;
    protected readonly procTurnBuilder: ProcedureTurnBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    private predictLegFinalTrueCourse;
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    private predictLegInitialTrueCourse;
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
declare class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly geoPointCache: GeoPoint[];
    protected readonly greatCircleBuilder: GreatCircleBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
declare class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly vec3Cache: Float64Array[];
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly greatCircleBuilder: GreatCircleBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}
/**
 * Calculates flight path vectors for hold legs.
 */
declare class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    protected readonly geoPointCache: GeoPoint[];
    protected readonly geoCircleCache: GeoCircle[];
    protected readonly greatCircleBuilder: GreatCircleBuilder;
    protected readonly circleVectorBuilder: CircleVectorBuilder;
    protected readonly turnToCourseBuilder: TurnToCourseBuilder;
    protected readonly joinGreatCircleToPointBuilder: JoinGreatCircleToPointBuilder;
    protected readonly procTurnBuilder: ProcedureTurnBuilder;
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache: Map<string, Facility>);
    /** @inheritdoc */
    protected calculateMagVar(legs: LegDefinition[], calculateIndex: number): void;
    protected calculateVectors(legs: LegDefinition[], calculateIndex: number, activeLegIndex: number, state: FlightPathState): void;
}

/**
 * An array of breakpoints defining a lookup table for bank angle, in degrees, versus airplane speed, in knots.
 */
declare type FlightPathBankAngleBreakpoints = readonly (readonly [bankAngle: number, speed: number])[];
/**
 * Modes for calculating airplane speed for use in flight path calculations.
 */
declare enum FlightPathAirplaneSpeedMode {
    /** The default airplane speed is always used. */
    Default = "Default",
    /** Ground speed is used. */
    GroundSpeed = "GroundSpeed",
    /** True airspeed is used. */
    TrueAirspeed = "TrueAirspeed",
    /** True airspeed plus wind speed is used. */
    TrueAirspeedPlusWind = "TrueAirspeedPlusWind"
}
/**
 * Options for the flight path calculator.
 */
interface FlightPathCalculatorOptions {
    /** The default climb rate, in feet per minute, if the plane is not yet at flying speed. */
    defaultClimbRate: number;
    /**
     * The default airplane speed, in knots. This speed is used if the airplane speed mode is `Default` or if the
     * airplane speed calculated through other means is slower than this speed.
     */
    defaultSpeed: number;
    /**
     * The bank angle, in degrees, with which to calculate general turns, or breakpoints defining a linearly-interpolated
     * lookup table for bank angle versus airplane speed, in knots.
     */
    bankAngle: number | FlightPathBankAngleBreakpoints;
    /**
     * The bank angle, in degrees, with which to calculate turns in holds, or breakpoints defining a
     * linearly-interpolated lookup table for bank angle versus airplane speed, in knots. If `null`, the general turn
     * bank angle will be used for holds.
     */
    holdBankAngle: number | FlightPathBankAngleBreakpoints | null;
    /**
     * The bank angle, in degrees, with which to calculate turns in course reversals (incl. procedure turns), or
     * breakpoints defining a linearly-interpolated lookup table for bank angle versus airplane speed, in knots. If
     * `null`, the general turn bank angle will be used for course reversals.
     */
    courseReversalBankAngle: number | FlightPathBankAngleBreakpoints | null;
    /**
     * The bank angle, in degrees, with which to calculate turn anticipation, or breakpoints defining a
     * linearly-interpolated lookup table for bank angle versus airplane speed, in knots. If `null`, the general turn
     * bank angle will be used for turn anticipation.
     */
    turnAnticipationBankAngle: number | FlightPathBankAngleBreakpoints | null;
    /** The maximum bank angle, in degrees, to use to calculate all turns. */
    maxBankAngle: number;
    /** The mode to use to calculate airplane speed. */
    airplaneSpeedMode: FlightPathAirplaneSpeedMode;
}
/**
 * Calculates the flight path vectors for a given set of legs.
 */
declare class FlightPathCalculator {
    private readonly facilityLoader;
    private readonly bus;
    private readonly facilityCache;
    private readonly legCalculatorMap;
    private readonly turnCalculator;
    private bankAngleTable;
    private holdBankAngleTable?;
    private courseReversalBankAngleTable?;
    private turnAnticipationBankAngleTable?;
    private readonly state;
    private readonly options;
    private readonly calculateQueue;
    private isBusy;
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     * @param bus An instance of the EventBus.
     */
    constructor(facilityLoader: FacilityLoader, options: FlightPathCalculatorOptions, bus: EventBus);
    /**
     * Method to update this calculator's options.
     * @param newOptions A Partial FlightPathCalculatorOptions object.
     */
    private setOptions;
    /**
     * Builds a bank angle lookup table.
     * @param angle A constant bank angle, in degrees, or an array of bank angle (degrees) versus airplane speed (knots)
     * breakpoints.
     * @returns A bank angle lookup table.
     */
    private buildBankAngleTable;
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    protected createLegCalculatorMap(): Record<LegType, FlightPathLegCalculator>;
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculation is finished.
     */
    calculateFlightPath(legs: LegDefinition[], activeLegIndex: number, initialIndex?: number, count?: number): Promise<void>;
    /**
     * Executes a calculate operation. When the operation is finished, the next operation in the queue, if one exists,
     * will be started.
     * @param resolve The Promise resolve function to invoke when the calculation is finished.
     * @param reject The Promise reject function to invoke when an error occurs during calculation.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculate operation is finished, or rejected if an error occurs
     * during calculation.
     */
    private doCalculate;
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    private loadFacilities;
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    private stageFacilityLoad;
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    private initCurrentLatLon;
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    private initCurrentCourse;
    /**
     * Initializes the fallback state.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    private initIsFallback;
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    private calculateLegPaths;
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    private calculateLegPath;
    /**
     * Resolves the ingress to egress vectors for a set of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to resolve.
     * @param count The number of legs to resolve.
     */
    private resolveLegsIngressToEgress;
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    private updateLegDistances;
}

/**
 * Control Events for the Flight Path Calculator.
 */
interface FlightPathCalculatorControlEvents {
    /** Event to set some or all FlightPathCalculatorOptions. */
    flightpath_set_options: Partial<FlightPathCalculatorOptions>;
}

/**
 * A flight path calculator for turns between legs.
 */
declare class FlightPathTurnCalculator {
    private static readonly vector3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private static readonly intersectionVecArrayCache;
    private static readonly intersectionGeoPointArrayCache;
    private readonly procTurnBuilder;
    /**
     * Computes leg to leg turns for a given sequence of legs. Turns will only be calculated between legs with defined
     * flight path vectors and no pre-existing egress/ingress transition (unless it is a leg-to-leg turn) at the junction
     * of the turn.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     * @param desiredTurnRadius The desired general turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     */
    computeTurns(legs: LegDefinition[], startIndex: number, count: number, desiredTurnRadius: number, desiredCourseReversalTurnRadius: number, desiredTurnAnticipationTurnRadius: number): void;
    /**
     * Calculates a leg-to-leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param isRestrictedByPrevTurn Whether turn anticipation is restricted by the previous leg-to-leg turn. If `true`,
     * turn anticipation will be restricted so that the turn does not overlap the previous turn if they share a common
     * flight path vector.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined and `isRestrictedByPrevTurn` is `true`, the
     * anticipation of both turns will be adjusted if necessary such that the turns do not overlap if they share a common
     * flight path vector. If the value is undefined, the anticipation of the current turn will be restricted by the
     * previous turn, if necessary, without changing the anticipation of the previous turn.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    private computeTrackTrackTurn;
    /**
     * Computes a leg-to-leg course reversal.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param fromTrackBearing The true course bearing of the track vector on which the turn begins, at the end of the vector.
     * @param toTrackBearing The true course bearing of the track vector on which the turn ends, at the beginning of the vector.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    private computeTrackTrackCourseReversal;
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    private computeArcTrackTurn;
    /**
     * Removes all ingress and egress flight path vectors from a pair of legs at their junction.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    private setEmptyTurn;
    private static readonly setAnticipatedTurnCache;
    /**
     * Adds flight path vectors to a pair of legs for an anticipated leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     */
    private setAnticipatedTurn;
}

/**
 * Utility class for working with flight path calculations.
 */
declare class FlightPathUtils {
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector(): CircleVector;
    /**
     * Sets the parameters of a circle vector.
     * @param vector The circle vector to set.
     * @param circle The GeoCircle defining the vector's path.
     * @param start The start of the vector.
     * @param end The end of the vector.
     * @param flags The flags to set on the vector.
     * @returns The circle vector, after its parameters have been set.
     */
    static setCircleVector(vector: CircleVector, circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, flags: number): CircleVector;
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector: CircleVector): boolean;
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector: CircleVector, out: GeoCircle): GeoCircle;
    /**
     * Gets the direction of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The direction of the turn described by the flight path circle vector.
     */
    static getVectorTurnDirection(vector: CircleVector): VectorTurnDirection;
    /**
     * Gets the radius of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The radius of the turn described by the flight path circle vector, in great-arc radians.
     */
    static getVectorTurnRadius(vector: CircleVector): number;
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector: FlightPathVector): number;
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
     */
    static getVectorFinalCourse(vector: FlightPathVector): number;
    /**
     * Gets the true course for a flight plan leg.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation if `magVarFacility` is not defined.
     * @param magVarFacility The VOR facility which defines the magnetic variation used for the leg's course.
     * @returns The true course for the specified flight plan leg.
     */
    static getLegTrueCourse(leg: FlightPlanLeg, point: LatLonInterface, magVarFacility?: VorFacility): number;
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns The final position of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalPosition(legCalc: LegCalculations, out: GeoPoint): GeoPoint | undefined;
    /**
     * Gets the final true course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns The final true course of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalCourse(legCalc: LegCalculations): number | undefined;
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center: ReadonlyFloat64Array | LatLonInterface, radius: number, turnDirection: VectorTurnDirection, out: GeoCircle): GeoCircle;
    /**
     * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
     * @param circle The turn circle to reverse.
     * @param out A GeoCircle object to which to write the result.
     * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
     */
    static reverseTurnCircle(circle: GeoCircle, out: GeoCircle): GeoCircle;
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle: GeoCircle): VectorTurnDirection;
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle: GeoCircle): number;
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle<T extends GeoPoint | Float64Array>(circle: GeoCircle, out: T): T;
    /**
     * Calculates and returns a circle describing a turn starting from a path at a specified point.
     * @param start The starting point of the turn.
     * @param path The circle describing the path from which the turn starts.
     * @param turnRadius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the specified turn.
     */
    static getTurnCircleStartingFromPath(start: ReadonlyFloat64Array | LatLonInterface, path: GeoCircle, turnRadius: number, turnDirection: VectorTurnDirection, out: GeoCircle): GeoCircle;
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
     * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
     * circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
     */
    static getAlongArcSignedDistance(circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, pos: ReadonlyFloat64Array | LatLonInterface, tolerance?: number): number;
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
     * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
     * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
     * diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The normalized distance along the arc from the start point to the query point.
     */
    static getAlongArcNormalizedDistance(circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, pos: ReadonlyFloat64Array | LatLonInterface, tolerance?: number): number;
    /**
     * Checks if a point lies between the start and end points of an arc along a geo circle. The start, end, and query
     * points will be projected onto the arc's parent circle if they do not already lie on it.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param inclusive Whether the arc includes the start and end points. Defaults to `true`.
     * @param tolerance The error tolerance, in great-arc radians. Defaults to {@link GeoCircle.ANGULAR_TOLERANCE}.
     * @returns Whether the query point lies between the start and end points of the specified arc.
     */
    static isPointAlongArc(circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, end: ReadonlyFloat64Array | LatLonInterface, pos: ReadonlyFloat64Array | LatLonInterface, inclusive?: boolean, tolerance?: number): boolean;
    /**
     * Checks if a point lies between the start and end points (inclusive) of an arc along a geo circle. The start and
     * query points will be projected onto the arc's parent circle if they do not already lie on it.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param angularWidth The angular width of the arc, in radians.
     * @param pos The query point.
     * @param inclusive Whether the arc includes the start and end points. Defaults to `true`.
     * @param tolerance The error tolerance, in great-arc radians. Defaults to {@link GeoCircle.ANGULAR_TOLERANCE}.
     * @returns Whether the query point lies between the start and end points (inclusive) of the specified arc.
     */
    static isPointAlongArc(circle: GeoCircle, start: ReadonlyFloat64Array | LatLonInterface, angularWidth: number, pos: ReadonlyFloat64Array | LatLonInterface, inclusive?: boolean, tolerance?: number): boolean;
    /**
     * Projects an instantaneous velocity at a point along a bearing onto a geo circle.
     *
     * The projected velocity is defined as the limit as dt goes to 0 of:
     *
     * `distance( project(p(0)), project(p(dt)) ) / dt`
     *
     * * `p(0)` is the position at which the velocity to project is measured.
     * * `p(x)` returns `p(0)` offset by the velocity to project after `x` time has elapsed.
     * * `project(x)` projects `x` onto the geo circle onto which the velocity is to be projected.
     * * `distance(x, y)` returns the distance from `x` to `y` along the geo circle onto which the velocity is to be
     * projected, in the range `(-c / 2, c / 2]`, where `c` is the circumference of the geo circle.
     * @param speed The magnitude of the velocity to project.
     * @param position The position at which the velocity is measured.
     * @param bearing The true bearing, in degrees, defining the direction of the velocity to project.
     * @param projectTo The geo circle to which to project the velocity.
     * @returns The signed magnitude of the velocity projected onto the specified geo circle. A positive sign indicates
     * the projected velocity follows the same direction as the circle, while a negative sign indicates the projected
     * velocity follows the opposite direction as the circle.
     */
    static projectVelocityToCircle(speed: number, position: LatLonInterface | ReadonlyFloat64Array, bearing: number, projectTo: GeoCircle): number;
    /**
     * Projects an instantaneous velocity at a point along a geo circle onto another geo circle.
     *
     * The projected velocity is defined as the limit as dt goes to 0 of:
     *
     * `distance( project(p(0)), project(p(dt)) ) / dt`
     *
     * * `p(0)` is the position at which the velocity to project is measured.
     * * `p(x)` returns `p(0)` offset by the velocity to project after `x` time has elapsed.
     * * `project(x)` projects `x` onto the geo circle onto which the velocity is to be projected.
     * * `distance(x, y)` returns the distance from `x` to `y` along the geo circle onto which the velocity is to be
     * projected, in the range `(-c / 2, c / 2]`, where `c` is the circumference of the geo circle.
     * @param speed The magnitude of the velocity to project.
     * @param position The position at which the velocity is measured.
     * @param path The geo circle defining the path parallel to the velocity to project.
     * @param projectTo The geo circle to which to project the velocity.
     * @returns The signed magnitude of the velocity projected onto the specified geo circle. A positive sign indicates
     * the projected velocity follows the same direction as the circle, while a negative sign indicates the projected
     * velocity follows the opposite direction as the circle.
     */
    static projectVelocityToCircle(speed: number, position: LatLonInterface | ReadonlyFloat64Array, path: GeoCircle, projectTo: GeoCircle): number;
    /**
     * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
     * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
     * while following the flight path defined by the vectors in the `flightPath` array.
     * @param legCalc A set of flight plan leg calculations.
     * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
     */
    static resolveIngressToEgress<T extends LegCalculations>(legCalc: T): T;
}

declare enum LegEventType {
    Added = "Added",
    Removed = "Removed",
    Changed = "Changed"
}
declare enum SegmentEventType {
    Added = "Added",
    Removed = "Removed",
    Changed = "Changed",
    Inserted = "Inserted"
}
declare enum ActiveLegType {
    Lateral = "Lateral",
    Vertical = "Vertical",
    Calculating = "Calculating"
}
declare enum OriginDestChangeType {
    OriginAdded = "OriginAdded",
    OriginRemoved = "OriginRemoved",
    DestinationAdded = "DestinationAdded",
    DestinationRemoved = "DestinationRemoved"
}
/** Direct To Metadata for Flight Plan. */
interface DirectToData {
    /** The segment index of the direct to target. */
    segmentIndex: number;
    /** The segment leg index of the direct to target. */
    segmentLegIndex: number;
}
/**
 * Events generated by changes in the flight plan.
 */
interface PlanEvents {
    /**
     * An event generated when there is a change in a leg.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    onLegChanged?(segmentIndex: number, index: number, type: LegEventType, leg: LegDefinition): void;
    /**
     * An event generated when there is a change in a segment.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    onSegmentChanged?(index: number, type: SegmentEventType, segment?: FlightPlanSegment): void;
    /**
     * An event generated when an active leg is changed.
     * @param index The global index of the leg.
     * @param segmentIndex The index of the flight plan segment.
     * @param previousSegmentIndex The index of the previously active segment.
     * @param previousLegIndex The index of the previously active leg in the previously active segment.
     * @param type The type of leg that was changed.
     */
    onActiveLegChanged?(index: number, segmentIndex: number, legIndex: number, previousSegmentIndex: number, previousLegIndex: number, type: ActiveLegType): void;
    /**
     * An event fired when a flight plan vectorization completes.
     * @param index The index that the path was generated from.
     */
    onCalculated?(index?: number): void;
    /**
     * An event fired when the origin or destination changes.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    onOriginDestChanged?(type: OriginDestChangeType, airport?: string): void;
    /**
     * An event fired when the procedure details change.
     * @param details The details that were changed.
     */
    onProcedureDetailsChanged?(details: ProcedureDetails): void;
    /**
     * An event fired when user data is set in the plan.
     * @param key The key of the user data.
     * @param data The data that was set.
     */
    onUserDataSet?(key: string, data: any): void;
    /**
     * An event fired when user data is deleted in the plan.
     * @param key The key of the user data to delete.
     */
    onUserDataDelete?(key: string): void;
    /**
     * An event fired when direct to data is changed in the plan.
     * @param directToData The direct to data.
     */
    onDirectDataChanged?(directToData: DirectToData): void;
}
/**
 * A flight plan managed by the flight plan system.
 */
declare class FlightPlan {
    planIndex: number;
    calculator: FlightPathCalculator;
    private onLegNameRequested;
    private _originAirport?;
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport(): string | undefined;
    private _destinationAirport?;
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport(): string | undefined;
    private _activeLateralLeg;
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg(): number;
    private _activeVerticalLeg;
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg(): number;
    private _activeCalculatingLeg;
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg(): number;
    /** The direct to metadata for this plan. */
    readonly directToData: DirectToData;
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length(): number;
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount(): number;
    /** Events fired when the plan is modified. */
    events: PlanEvents;
    /** The details about the selected procedures. */
    readonly procedureDetails: ProcedureDetails;
    /** The flight plan segments that make up this flight plan. */
    private readonly planSegments;
    /** User assignable data. */
    private readonly userData;
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(planIndex: number, calculator: FlightPathCalculator, onLegNameRequested: ((leg: FlightPlanLeg) => string | undefined));
    /**
     * Gets this flight plan's legs.
     * @param reverse Whether to get the legs in reverse order. False by default.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0` if `reverse` is
     * `false` or `this.length` if `reverse` is `true`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length` if `reverse`
     * is `false` or `-1` if `reverse` is `true`.
     * @returns A generator which yields this flight plan's legs.
     */
    legs(reverse?: boolean, startIndex?: number, endIndex?: number): Generator<LegDefinition, void>;
    /**
     * Gets this flight plan's legs in forward order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length`.
     * @yields This flight plan's legs in forward order.
     */
    private _legs;
    /**
     * Gets this flight plan's legs in reverse order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `this.length - 1`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `-1`.
     * @yields This flight plan's legs in reverse order.
     */
    private _legsReverse;
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    segments(): Generator<FlightPlanSegment, void>;
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    segmentsOfType(segmentType: FlightPlanSegmentType): Generator<FlightPlanSegment, void>;
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex: number, segmentType?: FlightPlanSegmentType, airway?: string, notify?: boolean): FlightPlanSegment;
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex: number, segmentType?: FlightPlanSegmentType, airway?: string, notify?: boolean): FlightPlanSegment;
    /**
     * Reflows the flight plan segments after an insert.
     */
    private reflowSegments;
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex: number, notify?: boolean): void;
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex: number, notify?: boolean): void;
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex?: number): FlightPlanSegment;
    /**
     * Attempts to get a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment, or `null` if it could not be found.
     */
    tryGetSegment(segmentIndex?: number): FlightPlanSegment | null;
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex: number, leg: FlightPlanLeg, segmentLegIndex?: number, flags?: number, notify?: boolean): LegDefinition;
    /**
     * Gets a leg from the flight plan.
     * @param segmentIndex The index of the segment containing the leg to get.
     * @param segmentLegIndex The index of the leg to get in its segment.
     * @returns A flight plan leg.
     * @throws An error if the leg could not be found.
     */
    getLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition;
    /**
     * Gets a leg from the flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns A flight plan leg.
     * @throws An error if the leg could not be found.
     */
    getLeg(globalLegIndex: number): LegDefinition;
    /**
     * Attempts to get a leg from the flight plan.
     * @param segmentIndex The index of the segment containing the leg to get.
     * @param segmentLegIndex The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    tryGetLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition | null;
    /**
     * Attempts to get a leg from the flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    tryGetLeg(globalLegIndex: number): LegDefinition | null;
    /**
     * Attempts to get a leg from the flight plan.
     * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
     * @param arg2 The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    private _tryGetLeg;
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex: number, segmentLegIndex?: number, notify?: boolean): LegDefinition | null;
    /**
     * Calculates the flight path for the plan.
     * @param globalLegIndex The global leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    calculate(globalLegIndex?: number, notify?: boolean): Promise<void>;
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao: string, notify?: boolean): void;
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify?: boolean): void;
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao: string, notify?: boolean): void;
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify?: boolean): void;
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(globalLegIndex: number, notify?: boolean): void;
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(globalLegIndex: number, notify?: boolean): void;
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(globalLegIndex: number, notify?: boolean): void;
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details: Partial<ProcedureDetails>, notify?: boolean): void;
    /**
     * Gets the global index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg: LegDefinition): number;
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg: LegDefinition): FlightPlanSegment | null;
    /**
     * Gets the segment index for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment index for.
     * @returns The segment index for the given global leg index, or -1 if not found.
     */
    getSegmentIndex(globalLegIndex: number): number;
    /**
     * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment leg index for.
     * @returns The segment leg index, or -1 if not found.
     */
    getSegmentLegIndex(globalLegIndex: number): number;
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex: number, legIndex: number): LegDefinition | null;
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex: number, legIndex: number): LegDefinition | null;
    /**
     * Sets the direct to data for this plan.
     * @param globalLegIndex The global leg index of the direct to target, or -1 if the direct to data is to be cleared.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setDirectToData(globalLegIndex: number, notify?: boolean): void;
    /**
     * Sets the direct to data for this plan.
     * @param segmentIndex The segment index of the direct to target, or -1 if the direct to data is to be cleared.
     * @param segmentLegIndex The segment leg index of the direct to target, or -1 if the direct to data is to be
     * cleared.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setDirectToData(segmentIndex: number, segmentLegIndex: number, notify?: boolean): void;
    /**
     * Sets the direct to data for this plan.
     * @param leg The target leg of the direct to, or null if the direct to data is to be cleared.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setDirectToData(leg: LegDefinition | null, notify?: boolean): void;
    /**
     * Sets the vertical data for this plan leg.
     * @param segmentIndex The segment index of the leg in the plan to add vertical data to.
     * @param segmentLegIndex The segment leg index of the leg in the plan to add vertical data to.
     * cleared.
     * @param verticalData The Vertical Data for this leg.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setLegVerticalData(segmentIndex: number, segmentLegIndex: number, verticalData: Partial<VerticalData>, notify?: boolean): void;
    /**
     * Sets the vertical data for this plan leg.
     * @param globalLegIndex The global leg index in the plan for the leg to add vertical data to.
     * @param verticalData The Vertical Data for this leg.
     * @param notify Whether to send an event for this change. Defaults to true.
     */
    setLegVerticalData(globalLegIndex: number, verticalData: Partial<VerticalData>, notify?: boolean): void;
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex: number, airway?: string, notify?: boolean): void;
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers.
     */
    setUserData<T>(key: string, data: T, notify?: boolean): void;
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key: string, notify?: boolean): void;
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData<T>(key: string): T | undefined;
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    private reflowSegmentOffsets;
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway?: OneWayRunway | undefined, notify?: boolean): void;
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway?: OneWayRunway | undefined, notify?: boolean): void;
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao?: string | undefined, departureIndex?: number, departureTransitionIndex?: number, departureRunwayIndex?: number, notify?: boolean): void;
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param arrivalRunway The oneway runway to set as the arrival runway, or undefined
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao?: string | undefined, arrivalIndex?: number, arrivalTransitionIndex?: number, arrivalRunwayTransitionIndex?: number, arrivalRunway?: OneWayRunway | undefined, notify?: boolean): void;
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao?: string | undefined, approachIndex?: number, approachTransitionIndex?: number, notify?: boolean): void;
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @returns The copied flight plan.
     */
    copy(planIndex?: number, copyCalcs?: boolean): FlightPlan;
    /**
     * Copies leg calcs from an existing leg to a new leg.
     * @param existingLeg The leg that we want to copy the calcs from.
     * @param newLeg The leg that we want to copy the calcs to.
     * @returns the newLeg with the copied calcs.
     */
    private copyLegCalculations;
    /**
     * Creates a default instance of a flight plan leg.
     * @param partial A portion of leg options to apply.
     * @returns A default instance of a flight plan leg.
     */
    static createLeg: (partial: Partial<FlightPlanLeg>) => FlightPlanLeg;
}

/**
 * Events published by the FlightPlanner class.
 */
interface FlightPlannerEvents {
    /** A flight plan has been modified from a secondary source */
    fplLegChange: FlightPlanLegEvent;
    /** A flight plan has been modified from a secondary source */
    fplSegmentChange: FlightPlanSegmentEvent;
    /** A flight plan has changed an active leg. */
    fplActiveLegChange: FlightPlanActiveLegEvent;
    /** A flight plan has calculated flight path vectors. */
    fplCalculated: FlightPlanCalculatedEvent;
    /** A flight plan has update origin/dest information. */
    fplOriginDestChanged: FlightPlanOriginDestEvent;
    /** A flight plan has updated procedure details. */
    fplProcDetailsChanged: FlightPlanProcedureDetailsEvent;
    /** A full flight plan has been loaded. */
    fplLoaded: FlightPlanIndicationEvent;
    /** A new flight plan has been created. */
    fplCreated: FlightPlanIndicationEvent;
    /** A flight plan has been deleted. */
    fplDeleted: FlightPlanIndicationEvent;
    /** The active flight plan index has changed in the Flight Planner. */
    fplIndexChanged: FlightPlanIndicationEvent;
    /** The flight plan has been copied. */
    fplCopied: FlightPlanCopiedEvent;
    /** User data has been set in the flight plan. */
    fplUserDataSet: FlightPlanUserDataEvent;
    /** User data has been deleted in the flight plan. */
    fplUserDataDelete: FlightPlanUserDataEvent;
    /** Direct to data has been changed in the flight plan. */
    fplDirectToDataChanged: FlightPlanDirectToDataEvent;
}
/**
 * An event fired when the flight plan is recalculated.
 */
interface FlightPlanCalculatedEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The index from which the calculations were generated. */
    readonly index?: number;
}
/**
 * An event fired when there are leg related changes.
 */
interface FlightPlanLegEvent {
    /** The type of the leg event. */
    readonly type: LegEventType;
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The index of the */
    readonly segmentIndex: number;
    /** The index of the changed leg in the segment. */
    readonly legIndex: number;
    /** The leg that was added, removed, or changed. */
    readonly leg: LegDefinition;
}
/**
 * An event fired when an active leg changes.
 */
interface FlightPlanActiveLegEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The global index of the active leg. */
    readonly index: number;
    /** The index of the segment in which the active leg is. */
    readonly segmentIndex: number;
    /** The index of the leg within the segment. */
    readonly legIndex: number;
    /** The index of the segment in which the previously active leg is. */
    readonly previousSegmentIndex: number;
    /** The index of the previously active leg within the previously active segment. */
    readonly previousLegIndex: number;
    /** The type of active leg that changed. */
    readonly type: ActiveLegType;
}
/**
 * An event fired when there are segment related changes.
 */
interface FlightPlanSegmentEvent {
    /** The type of the leg change. */
    readonly type: SegmentEventType;
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The current leg selected. */
    readonly segmentIndex: number;
    /** The segment that was added, removed, or changed. */
    readonly segment?: FlightPlanSegment;
}
/**
 * An event generated when the origin and/or destination information
 * is updated.
 */
interface FlightPlanOriginDestEvent {
    /** The type of change. */
    readonly type: OriginDestChangeType;
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The airport that was changed. */
    readonly airport?: string;
}
/**
 * An event generated when the flight plan procedure details changs.
 */
interface FlightPlanProcedureDetailsEvent {
    /** THe index of the flight plan. */
    readonly planIndex: number;
    /** The procedure details that changed. */
    readonly details: ProcedureDetails;
}
/**
 * An event generated when an instrument requests a full set
 * of plans from the bus.
 */
interface FlightPlanRequestEvent {
    /** A unique ID attached to the request. */
    readonly uid: number;
}
/**
 * An event generated when an instrument responds to a full
 * flight plan set request.
 */
interface FlightPlanResponseEvent {
    /** The unique ID of the request that triggered this response. */
    readonly uid: number;
    /** The plans contained by the flight planner. */
    readonly flightPlans: FlightPlan[];
    /** The index of the active plan. */
    readonly planIndex: number;
}
/**
 * An event generated when a full plan has been loaded, created, or became active.
 */
interface FlightPlanIndicationEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
}
/**
 * An event generated when the flight plan procedure details changs.
 */
interface FlightPlanCopiedEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The index that the flight plan was copied to. */
    readonly targetPlanIndex: number;
    /** Whether this copy should include flight plan calculations. */
    readonly copyCalcs: boolean;
}
/**
 * An event generated when user data is set in the flight plan.
 */
interface FlightPlanUserDataEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The key of the user data. */
    readonly key: string;
    /** The user data. */
    readonly data: any;
}
/**
 * An event generated when direct to data is changed in the flight plan.
 */
interface FlightPlanDirectToDataEvent {
    /** The index of the flight plan. */
    readonly planIndex: number;
    /** The direct to data. */
    readonly directToData: DirectToData;
}
/**
 * Manages the active flightplans of the navigational systems.
 */
declare class FlightPlanner {
    private readonly bus;
    private readonly calculator;
    private onLegNameRequested;
    private static INSTANCE?;
    /** The flight plans managed by this flight planner. */
    private readonly flightPlans;
    /** A publisher for publishing flight planner update events. */
    private readonly publisher;
    private ignoreSync;
    /** The active flight plan index. */
    private _activePlanIndex;
    private lastRequestUid?;
    flightPlanSynced: SubEvent<this, boolean>;
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex: number);
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex(): number;
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    private constructor();
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync(): void;
    /**
     * An event generated when a set of flight plans is requested.
     * @param data The event data.
     */
    private onFlightPlanRequest;
    /**
     * Sends a flight plan request event.
     */
    private sendFlightPlanRequest;
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    private onFlightPlanResponse;
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex: number): boolean;
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex: number): FlightPlan;
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex: number, notify?: boolean): FlightPlan;
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    private onPlanCreated;
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    private sendPlanCreated;
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex: number, notify?: boolean): void;
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    private onPlanDeleted;
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    private sendPlanDeleted;
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    private buildPlanEventHandlers;
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan(): boolean;
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan(): FlightPlan;
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex: number, targetPlanIndex: number, copyCalcs?: boolean, notify?: boolean): void;
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    private onPlanCopied;
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     * @param copyCalcs Whether to leg calculations were copied.
     */
    private sendPlanCopied;
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    private onLegChanged;
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    private sendLegChanged;
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    private onSegmentChanged;
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    private sendSegmentChanged;
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    private onActiveLegChanged;
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     */
    private sendActiveLegChange;
    /**
     * A callback which is called in response to calculation sync events.
     * @param data The event data.
     */
    private onCalculated;
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The index that the path was generated from.
     */
    private sendCalculated;
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    private onOriginDestChanged;
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    private sendOriginDestChanged;
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    private onProcedureDetailsChanged;
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     */
    private sendProcedureDetailsChanged;
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    private onPlanIndexChanged;
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    private sendPlanIndexChanged;
    /**
     * A callback which is called in response to user data set sync events.
     * @param data The event data.
     */
    private onUserDataSet;
    /**
     * A callback which is called in response to user data delete sync events.
     * @param data The event data.
     */
    private onUserDataDelete;
    /**
     * Sends a user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     */
    private sendUserDataSet;
    /**
     * Sends a user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     */
    private sendUserDataDelete;
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    private onDirectToDataChanged;
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     */
    private sendDirectToData;
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex: number): void;
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    private sendEvent;
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus: EventBus, calculator: FlightPathCalculator, onLegNameRequested?: ((leg: FlightPlanLeg) => string | undefined)): FlightPlanner;
    /**
     * Default Method for leg naming - builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildDefaultLegName(leg: FlightPlanLeg): string;
}

/**
 * A cursor for storing data while iterating
 * over the current flight plan.
 */
interface IteratorCursor {
    /** The current plan segment. */
    segment: FlightPlanSegment;
    /** The current leg index within the segment. */
    legIndex: number;
    /** The current leg definition. */
    legDefinition: LegDefinition;
    /** The current iterator index. */
    index: number;
}
/**
 * A Utility Class that supports iterating through a flight plan either forward or reverse.
 */
declare class FlightPlanLegIterator {
    private readonly cursor;
    private cursorIsBusy;
    /**
     * Method that checks whether the FlightPlanLegIterator is busy.
     * @returns Whether the cursor is busy.
     */
    isBusy(): boolean;
    /**
     * Iterates through the active flight plan in reverse order.
     * @param lateralPlan The lateral flight plan to iterate through.
     * @param each The function to call for each flight plan leg.
     * @throws an Error if the cursor is busy.
     */
    iterateReverse(lateralPlan: FlightPlan, each: (data: IteratorCursor) => void): void;
    /**
     * Iterates through the active flight plan in forward order.
     * @param lateralPlan The lateral flight plan to iterate through.
     * @param each The function to call for each flight plan leg.
     * @throws an Error if the cursor is busy.
     */
    iterateForward(lateralPlan: FlightPlan, each: (data: IteratorCursor) => void): void;
}

/**
 * Utility class for working with flight plans.
 */
declare class FlightPlanUtils {
    /** Array of "to altitude" leg types. */
    private static readonly ALTITUDE_LEG_TYPES;
    /** Array of "heading to" leg types. */
    private static readonly HEADING_LEG_TYPES;
    /** Array of "hold" leg types. */
    private static readonly HOLD_LEG_TYPES;
    /** Array of manual termination leg types that end in a discontinuity. */
    private static readonly MANUAL_DISCO_LEG_TYPES;
    /** Array of discontinuity leg types. */
    private static readonly DISCO_LEG_TYPES;
    /**
     * Checks if a leg type is an "to altitude" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType: LegType): legType is ArrayType<typeof FlightPlanUtils.ALTITUDE_LEG_TYPES>;
    /**
     * Checks if a leg type is a "heading to" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType: LegType): legType is ArrayType<typeof FlightPlanUtils.HEADING_LEG_TYPES>;
    /**
     * Checks if a leg type is a "hold" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "hold" leg type.
     */
    static isHoldLeg(legType: LegType): legType is ArrayType<typeof FlightPlanUtils.HOLD_LEG_TYPES>;
    /**
     * Checks if a leg type is a manual termination leg type that ends in a discontinuity.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a manual termination leg type that ends in a discontinuity.
     */
    static isManualDiscontinuityLeg(legType: LegType): legType is ArrayType<typeof FlightPlanUtils.MANUAL_DISCO_LEG_TYPES>;
    /**
     * Checks if a leg type is a discontinuity leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a discontinuity leg type.
     */
    static isDiscontinuityLeg(legType: LegType): legType is ArrayType<typeof FlightPlanUtils.DISCO_LEG_TYPES>;
    /**
     * Gets the ICAO of the facility defining the terminator of a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The ICAO of the facility defining the terminator of the specified flight plan leg, or `undefined` if
     * the leg's terminator is not defined by a facility.
     */
    static getTerminatorIcao(leg: FlightPlanLeg): string | undefined;
}

/**
 * A collection of unique string waypoint type keys.
 */
declare enum WaypointTypes {
    Custom = "Custom",
    Airport = "Airport",
    NDB = "NDB",
    VOR = "VOR",
    Intersection = "Intersection",
    Runway = "Runway",
    User = "User",
    Visual = "Visual",
    FlightPlan = "FlightPlan",
    VNAV = "VNAV"
}
/**
 * A navigational waypoint.
 */
interface Waypoint {
    /** The geographic location of the waypoint. */
    readonly location: Subscribable<GeoPointInterface>;
    /** A unique string ID assigned to this waypoint. */
    readonly uid: string;
    /**
     * Checks whether this waypoint and another are equal.
     * @param other The other waypoint.
     * @returns whether this waypoint and the other are equal.
     */
    equals(other: Waypoint): boolean;
    /** The unique string type of this waypoint. */
    readonly type: string;
}
/**
 * An abstract implementation of Waypoint.
 */
declare abstract class AbstractWaypoint implements Waypoint {
    abstract get location(): Subscribable<GeoPointInterface>;
    abstract get uid(): string;
    abstract get type(): string;
    equals(other: Waypoint): boolean;
}
/**
 * A waypoint with custom defined lat/lon coordinates.
 */
declare class CustomWaypoint extends AbstractWaypoint {
    private readonly _location;
    private readonly _uid;
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param uidPrefix The prefix of this waypoint's UID.
     */
    constructor(lat: number, lon: number, uidPrefix: string);
    /**
     * Constructor.
     * @param location A subscribable which provides the location of this waypoint.
     * @param uid This waypoint's UID.
     */
    constructor(location: Subscribable<GeoPointInterface>, uid: string);
    /** @inheritdoc */
    get location(): Subscribable<GeoPointInterface>;
    /** @inheritdoc */
    get uid(): string;
    /** @inheritdoc */
    get type(): string;
}
/**
 * A waypoint associated with a facility.
 */
interface FacilityWaypoint<T extends Facility = Facility> extends Waypoint {
    /** A flag which marks this waypoint as a FacilityWaypoint. */
    readonly isFacilityWaypoint: true;
    /** The facility associated with this waypoint. */
    readonly facility: Subscribable<T>;
}
/**
 * A basic implementation of {@link FacilityWaypoint}.
 */
declare class BasicFacilityWaypoint<T extends Facility = Facility> extends AbstractWaypoint implements FacilityWaypoint<T> {
    private readonly bus;
    /** @inheritdoc */
    readonly isFacilityWaypoint = true;
    private _facility;
    private readonly _location;
    private readonly _type;
    private facChangeSub?;
    /**
     * Constructor.
     * @param facility The facility associated with this waypoint.
     * @param bus The event bus.
     */
    constructor(facility: T, bus: EventBus);
    /** @inheritdoc */
    get location(): Subscribable<GeoPointInterface>;
    /** @inheritdoc */
    get uid(): string;
    /** @inheritdoc */
    get type(): string;
    /**
     * The facility associated with this waypoint.
     */
    get facility(): Subscribable<T>;
    /**
     * Gets a waypoint type from a facility.
     * @param facility A facility.
     * @returns The waypoint type corresponding to the facility.
     */
    private static getType;
}
/**
 * A utility class for working with FacilityWaypoint.
 */
declare class FacilityWaypointUtils {
    /**
     * Checks whether a waypoint is a {@link FacilityWaypoint}.
     * @param waypoint The waypoint to check.
     * @returns Whether the specified waypoint is a {@link FacilityWaypoint}.
     */
    static isFacilityWaypoint(waypoint: Waypoint): waypoint is FacilityWaypoint<Facility>;
    /**
     * Checks whether a waypoint is a {@link FacilityWaypoint} of a given facility type.
     * @param waypoint The waypoint to check.
     * @param facilityType The facility type to check against.
     * @returns Whether the specified waypoint is a {@link FacilityWaypoint} of the specified facility type.
     */
    static isFacilityWaypoint<T extends FacilityType>(waypoint: Waypoint, facilityType: T): waypoint is FacilityWaypoint<FacilityTypeMap[T]>;
}
/**
 * A flight path waypoint.
 */
declare class FlightPathWaypoint extends AbstractWaypoint {
    static readonly UID_PREFIX = "FLPTH";
    /** The ident string of this waypoint. */
    readonly ident: string;
    /** The flight plan leg associated with this waypoint. */
    readonly leg: LegDefinition;
    private readonly _location;
    private readonly _uid;
    /** @inheritdoc */
    get location(): Subscribable<GeoPointInterface>;
    /** @inheritdoc */
    get uid(): string;
    /** @inheritdoc */
    get type(): string;
    /**
     * Constructor.
     * @param lat The latitude of this waypoint.
     * @param lon The longitude of this waypoint.
     * @param leg The flight plan leg associated with this waypoint.
     * @param uid This waypoint's UID, which will be prefixed with {@link FlightPathWaypoint.UID_PREFIX}.
     * @param ident The ident string of this waypoint.
     */
    constructor(lat: number, lon: number, leg: LegDefinition, uid: string, ident: string);
    /**
     * Constructor.
     * @param location A subscribable which provides the location of this waypoint.
     * @param leg The flight plan leg associated with this waypoint.
     * @param uid This waypoint's UID, which will be prefixed with {@link FlightPathWaypoint.UID_PREFIX}.
     * @param ident The ident string of this waypoint.
     */
    constructor(location: Subscribable<GeoPointInterface>, leg: LegDefinition, uid: string, ident: string);
}
/**
 * A VNAV waypoint.
 */
declare class VNavWaypoint extends AbstractWaypoint {
    readonly ident: string;
    private static readonly vec3Cache;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private readonly _location;
    private readonly _uid;
    /** @inheritdoc */
    get type(): string;
    /** @inheritdoc */
    get location(): Subscribable<GeoPointInterface>;
    /** @inheritdoc */
    get uid(): string;
    /**
     * Constructor.
     * @param leg The leg that the VNAV waypoint is contained in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param uid A unique ID to assign to the VNAV waypoint.
     * @param ident This waypoint's ident string.
     */
    constructor(leg: LegDefinition, distanceFromEnd: number, uid: string, ident: string);
    /**
     * Sets this waypoint's location.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     */
    setLocation(leg: LegDefinition, distanceFromEnd: number): void;
    /**
     * Gets the waypoint's location in space.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param out The GeoPoint object to which to write the location.
     * @returns The waypoint's location.
     */
    private getWaypointLocation;
}

/**
 * A cache of facility waypoints.
 */
interface FacilityWaypointCache {
    /**
     * Gets a waypoint from the cache for a specific facility. If one does not exist, a new waypoint will be created.
     * @param facility The facility for which to get a waypoint.
     * @returns A waypoint.
     */
    get<T extends Facility>(facility: Facility): FacilityWaypoint<T>;
}

/**
 * A default implementation of {@link FacilityWaypointCache}.
 */
declare class DefaultFacilityWaypointCache implements FacilityWaypointCache {
    private readonly bus;
    readonly size: number;
    private static INSTANCE;
    private readonly cache;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param size The maximum size of this cache.
     */
    private constructor();
    /** @inheritdoc */
    get<T extends Facility>(facility: Facility): FacilityWaypoint<T>;
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param key The key of the waypoint to add.
     * @param waypoint The waypoint to add.
     */
    private addToCache;
    /**
     * Gets a FacilityWaypointCache instance.
     * @param bus The event bus.
     * @returns A FacilityWaypointCache instance.
     */
    static getCache(bus: EventBus): FacilityWaypointCache;
    /**
     * Gets the cache key for a facility.
     * @param facility A facility.
     * @returns The cache key for the specified facility.
     */
    private static getFacilityKey;
}

/**
 * A cache for LodBoundary objects.
 */
declare class DefaultLodBoundaryCache {
    static readonly SIZE = 500;
    static readonly DISTANCE_THRESHOLDS: readonly number[];
    static readonly VECTOR_COUNT_TARGETS: readonly number[];
    private static INSTANCE?;
    /**
     * Gets an instance of DefaultLodBoundaryCache.
     * @returns An instance of DefaultLodBoundaryCache.
     */
    static getCache(): LodBoundaryCache;
}

/**
 * A singleton context of all nearest facility information.
 */
declare class NearestContext {
    private readonly facilityLoader;
    private readonly bus;
    /** The nearest airports. */
    readonly airports: NearestAirportSubscription;
    /** The nearest VOR stations. */
    readonly vors: NearestVorSubscription;
    /** The nearest intersections. */
    readonly intersections: NearestIntersectionSubscription;
    /** The nearest NDB stations. */
    readonly ndbs: NearestNdbSubscription;
    /** The nearest USR facilities. */
    readonly usrs: NearestUsrSubscription;
    /** The max number of airports in the context.*/
    maxAirports: number;
    /** The max number of VORs in the context. */
    maxVors: number;
    /** The max number of intersections in the context. */
    maxIntersections: number;
    /** The max number of NDBs in the context. */
    maxNdbs: number;
    /** The max number of user facilities in the context. */
    maxUsrs: number;
    /** The search radius for airports, in nautical miles. */
    airportRadius: number;
    /** The search radius for VORs, in nautical miles. */
    vorRadius: number;
    /** The search radius for intersections, in nautical miles. */
    intersectionRadius: number;
    /** The search radius for NDBs, in nautical miles. */
    ndbRadius: number;
    /** The search radius for user facilities, in nautical miles */
    usrRadius: number;
    private static instance?;
    private readonly position;
    private static readonly initializedSubEvent;
    /**
     * Gets an instance of the NearestContext.
     * @returns An instance of the NearestContext.
     * @throws An error if the NearestContext has not yet been initailized.
     */
    static getInstance(): NearestContext;
    /**
     * Initialized the NearestContext instance.
     * @param facilityLoader The facility loader to use for the instance.
     * @param bus The EventBus to use with this instance.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     * @throws An error if the NearestContext is already initialized.
     */
    static initialize(facilityLoader: FacilityLoader, bus: EventBus, planePos?: Subscribable<GeoPointInterface>): void;
    /**
     * Subscribes to this NearestContext being initialized, or invokes the handler immediately if it is already initialized
     *
     * @param handler the handler
     *
     * @returns the subscription, if the action was not immediately performed
     */
    static onInitialized(handler: (instance: NearestContext) => void): Subscription | null;
    /**
     * Creates an instance of a NearestContext.
     * @param facilityLoader The facility loader to use for this instance.
     * @param bus An instance of the EventBus.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     */
    private constructor();
    /**
     * Updates the NearestContext.
     */
    update(): Promise<void>;
    /**
     * Get the local ICAO region code based on nearby facility data.
     * @returns The region code.
     */
    getRegionCode(): string | undefined;
    /**
     * Get the variant of the region code used in airport idents.   Generally this will
     * be the region code except for the case of the US, where it will just be 'K'.
     * @returns The region code or just 'K' for the US.
     */
    getRegionIdent(): string | undefined;
    /**
     * Gets the first letter of the local ICAO region code.
     * @returns The airport region letter.
     */
    getRegionLetter(): string | undefined;
    /**
     * Gets the nearest facility for a given type.
     * @param facilityType The type of facility.
     * @returns The nearest facility for a given type.
     */
    getNearest<T extends FacilityType>(facilityType: T): FacilityTypeMap[T] | undefined;
    /**
     * Finds the nearest facility in an array.
     * @param array A non-empty array of facilities.
     * @returns The nearest facility in the specified array.
     */
    private findNearest;
    /**
     * Orders facilities by their distance to the plane PPOS.
     * @param a The first facility.
     * @param b The second facility.
     * @returns The comparison order number.
     */
    private orderByPPosDistance;
}
/**
 * A singleton context of all nearest facility information which uses adaptive searches.
 */
declare class AdaptiveNearestContext {
    private readonly facilityLoader;
    private readonly bus;
    /** The nearest airports. */
    readonly airports: AdaptiveNearestSubscription<NearestAirportSubscription>;
    /** The nearest VOR stations. */
    readonly vors: AdaptiveNearestSubscription<NearestVorSubscription>;
    /** The nearest intersections. */
    readonly intersections: AdaptiveNearestSubscription<NearestIntersectionSubscription>;
    /** The nearest NDB stations. */
    readonly ndbs: AdaptiveNearestSubscription<NearestNdbSubscription>;
    /** The nearest USR facilities. */
    readonly usrs: AdaptiveNearestSubscription<NearestUsrSubscription>;
    /** The maximum number of airports in the context. */
    maxAirports: number;
    /** The maximum number of VORs in the context. */
    maxVors: number;
    /** The maximum number of intersections in the context. */
    maxIntersections: number;
    /** The maximum number of NDBs in the context. */
    maxNdbs: number;
    /** The maximum number of user facilities in the context. */
    maxUsrs: number;
    /** The maximum number of airports returned by this context's inner searches. */
    get maxAirportsAbsolute(): number;
    set maxAirportsAbsolute(val: number);
    /** The maximum number of VORs returned by this context's inner searches. */
    get maxVorsAbsolute(): number;
    set maxVorsAbsolute(val: number);
    /** The maximum number of intersections returned by this context's inner searches. */
    get maxIntersectionsAbsolute(): number;
    set maxIntersectionsAbsolute(val: number);
    /** The maximum number of NDBs returned by this context's inner searches. */
    get maxNdbsAbsolute(): number;
    set maxNdbsAbsolute(val: number);
    /** The maximum number of user facilities returned by this context's inner searches. */
    get maxUsrsAbsolute(): number;
    set maxUsrsAbsolute(val: number);
    /** The search radius for airports, in nautical miles. */
    airportRadius: number;
    /** The search radius for VORs, in nautical miles. */
    vorRadius: number;
    /** The search radius for intersections, in nautical miles. */
    intersectionRadius: number;
    /** The search radius for NDBs, in nautical miles. */
    ndbRadius: number;
    /** The search radius for user facilities, in nautical miles. */
    usrRadius: number;
    private static instance?;
    private readonly position;
    private readonly _maxAirportsAbsolute;
    private readonly _maxVorsAbsolute;
    private readonly _maxIntersectionsAbsolute;
    private readonly _maxNdbsAbsolute;
    private readonly _maxUsrsAbsolute;
    private static readonly initializedSubEvent;
    /**
     * Gets an instance of the AdaptiveNearestContext.
     * @returns An instance of the AdaptiveNearestContext.
     * @throws An error if the AdaptiveNearestContext has not yet been initailized.
     */
    static getInstance(): AdaptiveNearestContext;
    /**
     * Initialized the AdaptiveNearestContext instance.
     * @param facilityLoader The facility loader to use for the instance.
     * @param bus The EventBus to use with this instance.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     * @throws An error if the AdaptiveNearestContext is already initialized.
     */
    static initialize(facilityLoader: FacilityLoader, bus: EventBus, planePos?: Subscribable<GeoPointInterface>): void;
    /**
     * Subscribes to this NearestContext being initialized, or invokes the handler immediately if it is already initialized
     *
     * @param handler the handler
     *
     * @returns the subscription, if the action was not immediately performed
     */
    static onInitialized(handler: (instance: AdaptiveNearestContext) => void): Subscription | null;
    /**
     * Creates an instance of a AdaptiveNearestContext.
     * @param facilityLoader The facility loader to use for this instance.
     * @param bus An instance of the EventBus.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     */
    private constructor();
    /**
     * Updates this context.
     */
    update(): Promise<void>;
    /**
     * Gets the airport region letter to use for the first character in waypoint inputs.
     * @returns The airport region letter.
     */
    getRegionLetter(): string | undefined;
    /**
     * Gets the nearest facility for a given type.
     * @param facilityType The type of facility.
     * @returns The nearest facility for a given type.
     */
    getNearest<T extends FacilityType>(facilityType: T): FacilityTypeMap[T] | undefined;
    /**
     * Finds the nearest facility in an array.
     * @param array A non-empty array of facilities.
     * @returns The nearest facility in the specified array.
     */
    private findNearest;
    /**
     * Orders facilities by their distance to the plane PPOS.
     * @param a The first facility.
     * @param b The second facility.
     * @returns The comparison order number.
     */
    private orderByPPosDistance;
}

/** Type for setting an indexed instrument source */
declare type IndexedNavSourceSetting = {
    /** The index of the specific device to increment  */
    index: number;
    /** The source to set this device to */
    source: NavSourceId;
};
/** Control events, for where HEvents don't exist */
interface ControlEvents {
    /** increment the CDI source */
    cdi_src_switch: boolean;
    /** explicitly set a CDI source */
    cdi_src_set: NavSourceId;
    /** toggle CDI source between GPS and NAV */
    cdi_src_gps_toggle: boolean;
    /** Set the source of a given bearing needle */
    brg_src_set: IndexedNavSourceSetting;
    /** Increment the source of a given bearing needle number */
    brg_src_switch: number;
    /** Publish radio state */
    publish_radio_states: boolean;
    /** Set new xpdr code */
    [publish_xpdr_code: IndexedEventType<'publish_xpdr_code'>]: number;
    /** Set new xpdr mode */
    [publish_xpdr_mode: IndexedEventType<'publish_xpdr_mode'>]: XPDRMode;
    /** Tell XPDR to send ident to ATC */
    [xpdr_send_ident: IndexedEventType<'xpdr_send_ident'>]: boolean;
    /** Init the CDI Source */
    init_cdi: boolean;
    /** toggle DME window */
    dme_toggle: boolean;
    /** Set the current standby com frequency as a string. */
    standby_com_freq: string;
    /** Set the COM spacing for a radio. */
    com_spacing_set: ComSpacingChangeEvent;
    /** Set the current standby nav frequency as a string. */
    standby_nav_freq: string;
    /** Event when user presses 'B' to auto set pressure. */
    baro_set: boolean;
    /** Event when a user suspends LNAV leg sequencing. */
    suspend_sequencing: boolean;
    /** Whether LNAV should automatically inhibit the next attempt to sequence to the next flight plan leg. */
    lnav_inhibit_next_sequence: boolean;
    /** Event for setting missed approach state. */
    activate_missed_approach: boolean;
    /** Approach Frequency Set by FMS. */
    approach_freq_set: FacilityFrequency | undefined;
    /** Whether or not an approach is available for guidance. */
    approach_available: boolean;
}
/**
 * A publisher for control interactions.
 * This is meant to handle the events for which there aren't existing HEvents
 * in the sim to allow us to maintain a decoupled, event-driven architecture.
 */
declare class ControlPublisher extends BasePublisher<ControlEvents> {
    /**
     * Create a ControlPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus: EventBus, pacer?: PublishPacer<ControlEvents> | undefined);
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent<K extends keyof ControlEvents>(event: K, value: ControlEvents[K]): void;
    /** debug logger */
    startPublish(): void;
}

/** Base props for an XML gauge. */
interface XMLGaugeProps extends ComponentProps {
    /** The style definiton. */
    style: Partial<XMLGaugeStyle>;
    /** The minimum value. */
    minimum: CompositeLogicXMLElement;
    /** The maximum value. */
    maximum: CompositeLogicXMLElement;
    /** A list of color zones. */
    colorZones: Array<XMLGaugeColorZone>;
    /** A list of colir lines. */
    colorLines: Array<XMLGaugeColorLine>;
    /** The first possible value. */
    value1: CompositeLogicXMLElement;
    /** The second possible value for dual elements. */
    value2: CompositeLogicXMLElement;
    /** The title of the gauge. */
    title: string;
    /** The units measured by the gauge. */
    unit: string;
    /** The length of individual graduations. */
    graduationLength: number;
    /** Do the graduations have text? */
    graduationHasText: boolean;
    /** Text at the beginning of the gauge. */
    beginText: string;
    /** Text at the end of the gauge. */
    endText: string;
    /** The label of the first cursor. */
    cursorText1: string;
    /** The labe of the second cursor, for  */
    cursorText2: string;
    /** The class ID of the gauge. */
    id: string;
    /** Any triggers for blinking the element red. */
    redBlink: CompositeLogicXMLElement;
    /** A reference bug definition, if present. */
    referenceBugs: Array<XMLGaugeReferenceBug>;
}
/**
 * I don't want to make the logic host a defined part of the base gauge
 * interface, because I feel like that breaks abstraction boundaries and
 * ties this code too much to our specific implementation.   But I don't()
 * want people to have to subclass their own type of every gauge type in
 * order to pass the logic host in as a prop, so I'll make an additonal
 * interface for that which can be mixed in by people who want to use it.
 */
interface XMLHostedLogicGauge {
    /** The logic host. */
    logicHost: CompositeLogicXMLHost;
}
/** An XML gauge style definition. */
interface XMLGaugeStyle {
    /** TODO The scaling ratio on the gauge? */
    sizePercent: number;
    /** Left margin. */
    marginLeft: number;
    /** Right margin. */
    marginRight: number;
    /** Top margin. */
    marginTop: number;
    /** Bottom margin. */
    marginBottom: number;
}
/** A color zone definition. */
interface XMLGaugeColorZone {
    /** The name of the color to use. */
    color: string;
    /** The beginning value of the zone. */
    begin: CompositeLogicXMLElement;
    /** The ending value of the zone. */
    end: CompositeLogicXMLElement;
    /** An optional linear smoothing factor for value updates. */
    smoothFactor?: number;
}
/** A color line definition. */
interface XMLGaugeColorLine {
    /** The name of the color to use. */
    color: string;
    /** The value position of the color line. */
    position: CompositeLogicXMLElement;
    /** An optional linear smoothing factor for value updates. */
    smoothFactor?: number;
}
/** Style for a reference bug. */
interface XMLGaugeReferenceBugStyle extends XMLGaugeStyle {
    /** The color of the bug. */
    color: string;
}
/** A reference bug definition. */
interface XMLGaugeReferenceBug {
    /** The positioning logic. */
    position: CompositeLogicXMLElement;
    /** Logic to toggle display on and off. */
    displayLogic: CompositeLogicXMLElement;
    /** An optional style to use. */
    style?: Partial<XMLGaugeReferenceBugStyle>;
    /** An optional linear smoothing factor for value updates. */
    smoothFactor?: number;
}

/** Props for a circular gauge */
interface XMLCircularGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLCircularGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLCircularGaugeStyle extends XMLGaugeStyle {
    /** TODO What text color to force? */
    forceTextColor: string;
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** The arc position to begin on. */
    beginAngle: number;
    /** The arc position to end on. */
    endAngle: number;
    /** The style of cursor to use. */
    cursorType: XMLCircularGaugeCursor;
    /** Where to put the value. */
    valuePos: XMLCircularGaugeValuePos;
    /** The precision to use in text display. */
    valuePrecision: number;
}
/**
 * The style of cursor to use on a circular gauge.
 * This is treated as though it may have multiple options in the original
 * source.  For the sake of future expansion we'll make this an enum even
 * though it currently only has one option.  Maybe it can be used for future
 * expansion.
 */
declare enum XMLCircularGaugeCursor {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    Triangle = 1
}
/**
 * The possible locations for value text.
 * This is treated as though it may have multiple options in the original
 * source.  For the sake of future expansion we'll make this an enum even
 * though it currently only has one option.  Maybe it can be used for future
 * expansion.
 */
declare enum XMLCircularGaugeValuePos {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    End = 1
}

/** Props for a horizontal gauge */
interface XMLHorizontalGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLHorizontalGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLHorizontalGaugeStyle extends XMLGaugeStyle {
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** Where to put the value. */
    valuePos: XMLHorizontalGaugeValuePos;
    /** What kind of pointer to use. */
    pointerStyle: 'standard' | 'arrow';
    /** The color of the cursor. */
    cursorColor: string;
    /** TODO Width in pixels? as a float. */
    width: number;
    /** TODO dunno what this does yet */
    reverseY: boolean;
    /** The precision of the value as an int. */
    valuePrecision: number;
}
/**
 * This provides the valid values for the ValuePos tag on a horizontal gauge.
 */
declare enum XMLHorizontalGaugeValuePos {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    End = 1,
    Right = 2
}

/** Props for a horizontal gauge */
interface XMLVerticalGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLVerticalGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLVerticalGaugeStyle extends XMLGaugeStyle {
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** Where to put the value. */
    valuePos: XMLVerticalGaugeValuePos;
    /** The color of the cursor. */
    cursorColor: string;
}
/**
 * This provides the valid values for the ValuePos tag on a vertical gauge.
 */
declare enum XMLVerticalGaugeValuePos {
    /** Starting the enum at 1 to match its value in the stock XMLEngineDisplay.js */
    None = 1
}

/** Props for a horizontal gauge */
interface XMLDoubleHorizontalGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLDoubleHorizontalGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLDoubleHorizontalGaugeStyle extends XMLGaugeStyle {
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** The value precision. */
    valuePrecision: number;
    /** Where to put the value. */
    valuePos: XMLDoubleHorizontalGaugeValuePos;
    /** What kind of pointer to use. */
    pointerStyle: 'standard' | 'arrow';
}
/**
 * The possible locations for value text.
 * This is treated as though it may have multiple options in the original
 * source.  For the sake of future expansion we'll make this an enum even
 * though it currently only has one option.  Maybe it can be used for future
 * expansion.
 */
declare enum XMLDoubleHorizontalGaugeValuePos {
    /** Starting the enum at 2 to match its value in the stock XMLEngineDisplay.js */
    Right = 2
}

/** Props for a horizontal gauge */
interface XMLDoubleVerticalGaugeProps extends XMLGaugeProps {
    /** A style */
    style: Partial<XMLDoubleVerticalGaugeStyle>;
}
/** A circular gauge style definition */
interface XMLDoubleVerticalGaugeStyle extends XMLGaugeStyle {
    /** TODO Gradation labels on the arc? */
    textIncrement: number;
    /** TODO Height of the gauge in what? */
    height: number;
}

/** Props for an XML text element. */
interface XMLTextElementProps extends ComponentProps {
    /** The HTML class of the element. */
    class?: string;
    /** The left side text. */
    left?: XMLTextColumnProps;
    /** The central text. */
    center?: XMLTextColumnProps;
    /** The right side text. */
    right?: XMLTextColumnProps;
    /** Style information. */
    style?: Partial<XMLGaugeStyle>;
}
/** The configuration of an individual column of text. */
interface XMLTextColumnProps {
    /** The HTML class of the element. */
    class?: string;
    /** The text content of the column. */
    content: CompositeLogicXMLElement;
    /** The color of the text. */
    color?: CompositeLogicXMLElement;
    /** The font size to use. */
    fontSize?: string;
}

/**
 * The type of gauges available, as defined in XMLEngineDisplay.js.
 */
declare enum XMLGaugeType {
    Circular = "Circular",
    Horizontal = "Horizontal",
    DoubleHorizontal = "DoubleHorizontal",
    Vertical = "Vertical",
    DoubleVertical = "DoubleVertical",
    Text = "Text",
    ColumnGroup = "ColumnGroup",
    Column = "Column",
    Cylinder = "Cylinder",
    TwinCylinder = "TwinCylinder"
}
/**
 * The specification for a single gauge configuration.
 */
declare type XMLGaugeSpec = {
    /** The type of gauge this is. */
    gaugeType: XMLGaugeType;
    /** The correct configuration interface for this gauge type. */
    configuration: XMLGaugeProps | GaugeColumnProps | GaugeColumnGroupProps | XMLTextElementProps;
};
/**
 * The data for a function.
 */
declare type XMLFunction = {
    /** The function's name. */
    name: string;
    /** The XML logic the function runs. */
    logic: CompositeLogicXMLElement;
};
/**
 * A full set of gauges.
 */
declare type XMLExtendedGaugeConfig = {
    /** Whether this should override the temporary enhanced default configs. */
    override: boolean;
    /** Any configured functions. */
    functions: Map<string, XMLFunction>;
    /** The engine page. */
    enginePage: Array<XMLGaugeSpec>;
    /** The lean page, if it exists. */
    leanPage?: Array<XMLGaugeSpec>;
    /** The system page, if it exists. */
    systemPage?: Array<XMLGaugeSpec>;
};
/**
 * Parse an XMLEngineDisplay configuration into an array of gauge specs.
 */
declare class XMLGaugeConfigFactory {
    private instrument;
    private bus;
    /**
     * Create an XMLGaugeConfigFactory.
     * @param instrument The instrument that holds this engine display.
     * @param bus An event bus for gauges that need it.
     */
    constructor(instrument: BaseInstrument, bus: EventBus);
    /**
     * Convenience method to take a full XML instrument config and parse out the display config
     * section. This will check first to see if we are using an enhanced, multi-page config by
     * looking for an EnginePage tag in the EngineDisplay element.   If it finds it, it will
     * assume we have an advanced config, and return the content along with that of LeanPage
     * and SystemPag, if present.  If no EnginePage exists, we assume we're dealing with a
     * legacy configuration and just return the content of EngineDisplay itself as our engine
     * page with everything else undefined.
     * @param document The XML configuation document.
     * @returns An XMLEnhancedGaugeConfig with the full gauge configuration.
     */
    parseConfig(document: Document): XMLExtendedGaugeConfig;
    /**
     * Parse an engine display setup.
     * @param config An instrument XML config document.
     * @returns An array of the gauges defined in the configuration.
     */
    private _parseConfig;
    /**
     * Construct a single column of text for a text element.  This can be any
     * one of Left, Right, or Center.
     * @param columnDef The XML definition for the given column.
     * @returns an XMLTextColumn configuration.
     */
    private makeTextColumn;
    /**
     * Make a function.
     * @param functionDef The XML definition for the function.
     * @returns an XMLFunction type or undefined if there's an error
     */
    private makeFunction;
    /**
     * Create a base XMLGaugeProps definition.  This will be combined with the
     * props for a speciific gauge type to fully define the config interface.
     * @param gauge The gauge definition
     * @returns A set of XMLGaugeProps
     */
    private parseGaugeDefinition;
    /**
     * Create a circular gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createCircularGauge;
    /**
     * Create a horizontal gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createHorizontalGauge;
    /**
     * Create a double horizontal gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createDoubleHorizontalGauge;
    /**
     * Create a single vertical gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createVerticalGauge;
    /**
     * Create a double vertical gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createDoubleVerticalGauge;
    /**
     * Create a cylinder gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    private createCylinderGauge;
    /**
     * Create a column group.
     * @param gaugeDef AN XML element defining the group.
     * @returns The props for the group with all contained columns.
     */
    private createColumnGroup;
    /**
     * Create a column of gauges.
     * @param gaugeDef An XML element defining the column.
     * @returns The props of the column with all contained gauges.
     */
    private createColumn;
    /**
     * Check the value of a setting and, if it's defined, assign it to the
     * property of an object with optional type conversion.
     * @param obj The object to manipulate.
     * @param elem The element to get the value from.
     * @param prop The name of the property to set.
     * @param tag The tag name to retrieve.
     * @param converter A type conversion used if the value is defined.
     */
    private static getAndAssign;
    /**
     * Create a basic XML style from a gauge definition.
     * @param styleDoc A style definition block
     * @returns An XMLGaugeStyle
     */
    private static parseStyleDefinition;
    /**
     * Get the SmoothFactor value from a gauge definition if present.
     * @param element The HTML element to search for the parameter.
     * @returns The smoothing factor as a number, or undefined if not found.
     */
    private parseSmoothFactor;
    /**
     * Create an array of color zones if a definition exists.
     * @param zones An array of color zone definitions.
     * @returns An array of XMLGaugeColorZones
     */
    private makeColorZones;
    /**
     * Create an array of color lines if a definition exists.
     * @param lines An array of color line definitions.
     * @returns An array of XMLGaugeColorLines
     */
    private makeColorLines;
    /**
     * Create an array of reference bugs if a definition exists.
     * @param bugs An array of reference bug definitions.
     * @returns An array of XMLGaugeReferenceBugs
     */
    private makeReferenceBugs;
}

/** Properties of a column group. */
interface GaugeColumnGroupProps {
    /** The HTML class name to use for the column group. */
    id?: string;
    /** An event bus for our contained gauges that need it. */
    bus: EventBus;
    /** The columns in the group. */
    columns: Array<GaugeColumnProps>;
}
/** Properties of a gauge column. */
interface GaugeColumnProps {
    /** The HTML class name to use for the column. */
    id?: string;
    /** The width of the column, in percent of the parent. */
    width?: number;
    /** The gauges in the group. */
    gauges: Array<XMLGaugeSpec>;
}

/** Props for a cylinder gauge */
interface XMLCylinderGaugeProps extends XMLGaugeProps {
    /** An event bus for leaning events. */
    bus: EventBus;
    /** The number of columns in the gauge. */
    numColumns: CompositeLogicXMLElement;
    /** The number of boxes each column should have. */
    numRows: CompositeLogicXMLElement;
    /** What's the order of the hottest cylinders? */
    tempOrder?: Array<number>;
    /** The gauge styling. */
    style: Partial<XMLCylinderGaugeStyle>;
}
/** A cylinder gauge style definition. */
interface XMLCylinderGaugeStyle extends XMLGaugeStyle {
    /** Increment used for text value display. */
    textIncrement: number;
    /** Should there be a redline present? */
    redline?: boolean;
    /** Should we show peak temperatures when leaning? */
    peakTemps?: boolean;
}

/** A type that pairs a logic element with its callback handler. */
declare type LogicHandler<T> = {
    /** A logic element instance to evaluate. */
    logic: CompositeLogicXMLElement;
    /** A handler to call back to when there's a value change. */
    handler: (data: T) => void;
    /** A precision to use for numeric values. */
    precision?: number;
    /** A linear smoothing factor for value changes. */
    smoothFactor?: number;
};
/** The kind of data to return. */
declare enum CompositeLogicXMLValueType {
    Any = 0,
    Number = 1,
    String = 2
}
/**
 *
 */
declare class CompositeLogicXMLHost {
    private anyHandlers;
    private stringHandlers;
    private numberHandlers;
    private anyResultCache;
    private stringResultCache;
    private numberResultCache;
    private context;
    private isPaused;
    /**
     * Ctor
     * @param startPaused True to start paused.
     */
    constructor(startPaused?: boolean);
    /**
     * Set to pause the logic update loop.
     * @param isPaused True to pause, false to resume.
     */
    setIsPaused(isPaused: boolean): void;
    /**
     * Add a new logic element to calcluate a number or a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values of either type.
     * @returns The current value of the logic.
     */
    addLogic(logic: CompositeLogicXMLElement, handler: (data: string | number) => void): number | string;
    /**
     * Add a new logic element to calcluate a number.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as numbers.
     * @param precision An optional precision to require for updates to be sent.
     * @param smoothFactor An optional linear smoothing factor to apply to the value when updating.
     * @returns The current value of the logic.
     */
    addLogicAsNumber(logic: CompositeLogicXMLElement, handler: (data: number) => void, precision: number, smoothFactor?: number): number;
    /**
     * Add a new logic element to calcluate a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as strings.
     * @returns The current value of the logic.
     */
    addLogicAsString(logic: CompositeLogicXMLElement, handler: (data: string) => void): string;
    /**
     * Add a function to the logic context.
     * @param funcSpec The XMLFunction configuration.
     * @returns The function's current value.
     */
    addFunction(funcSpec: XMLFunction): number | string;
    /**
     * Update every logic element and publish updates.
     * @param deltaTime The time since the last update, in ms.
     */
    update(deltaTime: number): void;
}

declare namespace DataStore {
    /**
     * Writes a keyed value to the data store.
     * @param key A key.
     * @param value The value to set.
     */
    function set<T extends boolean | number | string>(key: string, value: T): void;
    /**
     * Retrieves a keyed value from the data store.
     * @param key A key.
     * @returns the value stored under the key, or undefined if one could not be retrieved.
     */
    function get<T extends boolean | number | string>(key: string): T | undefined;
    /**
     * Removes a key from the data store.
     * @param key The key to remove.
     */
    function remove(key: string): void;
}

/**
 * A subscribable subject which derives its value from an event consumer.
 */
declare class ConsumerSubject<T> extends AbstractSubscribable<T> {
    private readonly equalityFunc;
    private readonly mutateFunc?;
    private readonly consumerHandler;
    private value;
    private consumerSub?;
    private _isPaused;
    /**
     * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
     * update.
     */
    get isPaused(): boolean;
    private isDestroyed;
    /**
     * Constructor.
     * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
     * not be updated until its consumer is set to a non-null value.
     * @param initialVal This subject's initial value.
     * @param equalityFunc The function this subject uses check for equality between values.
     * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
     * instead.
     */
    private constructor();
    /**
     * Creates a new instance of ConsumerSubject.
     * @param consumer The consumer from which the new subject obtains its value. If null, the new subject's value will
     * not be updated until the subject's consumer is set to a non-null value.
     * @param initialVal The new subject's initial value.
     * @param equalityFunc The function to use to check for equality between values. Defaults to the strict equality
     * comparison (`===`).
     */
    static create<T>(consumer: Consumer<T> | null, initialVal: T, equalityFunc?: (a: T, b: T) => boolean): ConsumerSubject<T>;
    /**
     * Creates a new instance of ConsumerSubject.
     * @param consumer The consumer from which the new subject obtains its value. If null, the new subject's value will
     * not be updated until the subject's consumer is set to a non-null value.
     * @param initialVal The new subject's initial value.
     * @param equalityFunc The function to use to check for equality between values.
     * @param mutateFunc The function to use to change the new subject's value.
     */
    static create<T>(consumer: Consumer<T> | null, initialVal: T, equalityFunc: (a: T, b: T) => boolean, mutateFunc: (oldVal: T, newVal: T) => void): ConsumerSubject<T>;
    /**
     * Consumes an event.
     * @param value The value of the event.
     */
    private onEventConsumed;
    /**
     * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This subject, after its consumer has been set.
     */
    setConsumer(consumer: Consumer<T> | null): this;
    /**
     * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
     * @returns This subject, after it has been paused.
     */
    pause(): this;
    /**
     * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
     * events.
     * @returns This subject, after it has been resumed.
     */
    resume(): this;
    /** @inheritdoc */
    get(): T;
    /**
     * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
     */
    destroy(): void;
}

/**
 * Key intercept event data.
 */
declare type KeyEventData = {
    /** The key. */
    key: string;
    /** The first data value of the key event. */
    value0?: number;
    /** The second data value of the key event (this is often the index for indexed events). */
    value1?: number;
    /** The third data value of the key event. */
    value2?: number;
};
/**
 * Key events.
 */
declare type KeyEvents = {
    /** A key intercept event. */
    key_intercept: KeyEventData;
};
/**
 * A manager for key events. Allows key events to be triggered and intercepted, and also publishes intercepted key
 * events on the event bus.
 */
declare class KeyEventManager {
    private readonly keyListener;
    private readonly bus;
    private static INSTANCE?;
    private static isCreatingInstance;
    private static readonly pendingPromiseResolves;
    /**
     * Constructor.
     * @param keyListener The Coherent key intercept view listener.
     * @param bus The event bus.
     */
    private constructor();
    /**
     * Responds to key intercept events.
     * @param key The key that was intercepted.
     * @param value1 The second data value of the key event.
     * @param value0 The first data value of the key event.
     * @param value2 The third data value of the key event.
     */
    private onKeyIntercepted;
    /**
     * Triggers a key event.
     * @param key The key to trigger.
     * @param bypass Whether the event should bypass intercepts.
     * @param value0 The first data value of the key event. Defaults to `0`.
     * @param value1 The second data value of the key event. Defaults to `0`.
     * @param value2 The third data value of the key event. Defaults to `0`.
     * @returns A Promise which is fulfilled after the key event has been triggered.
     */
    triggerKey(key: string, bypass: boolean, value0?: number, value1?: number, value2?: number): Promise<void>;
    /**
     * Enables interception for a key.
     * @param key The key to intercept.
     * @param passThrough Whether to pass the event through to the sim after it has been intercepted.
     */
    interceptKey(key: string, passThrough: boolean): void;
    /**
     * Gets an instance of KeyEventManager. If an instance does not already exist, a new one will be created.
     * @param bus The event bus.
     * @returns A Promise which will be fulfilled with an instance of KeyEventManager.
     */
    static getManager(bus: EventBus): Promise<KeyEventManager>;
    /**
     * Creates an instance of KeyEventManager and fulfills all pending Promises to get the manager instance once
     * the instance is created.
     * @param bus The event bus.
     */
    private static createInstance;
    /**
     * Creates an instance of KeyEventManager.
     * @param bus The event bus.
     * @returns A Promise which is fulfilled with a new instance of KeyEventManager after it has been created.
     */
    private static create;
}

/**
 * A utility class which provides the current game state.
 */
declare class GameStateProvider {
    private static INSTANCE?;
    private readonly gameState;
    /**
     * Constructor.
     */
    private constructor();
    /**
     * Responds to changes in document attributes.
     */
    private onAttributesChanged;
    /**
     * Gets a subscribable which provides the current game state.
     * @returns A subscribable which provides the current game state.
     */
    static get(): Subscribable<GameState | undefined>;
}

declare enum IcaoSearchFilter {
    ALL = 0,
    AIRPORT = 1,
    VOR = 2,
    NDB = 3,
    INTERSECTION = 4,
    USR = 5
}
/**
 * An ICAO search session, which allows searching for ICAO strings that match a particular ident string.
 */
declare class IcaoSearch {
    private readonly facilityRepo;
    private readonly filter;
    private readonly searchGuid;
    private batch;
    private readonly MAX_RETRIES;
    private filterMap;
    private opId;
    /**
     * Constructor.
     * @param facilityRepo The local facility repository included in this search session.
     * @param filter The filter applied to this search session.
     */
    constructor(facilityRepo: FacilityRepository, filter: IcaoSearchFilter);
    /**
     * Executes a new search in this session with a specified ident string to match. Only one active search can run
     * simultaneously. Therefore, if doSearch() is called while a previous search is still running, the newer search will
     * pre-empt the older one, causing the older one to fail.
     * @param ident An ident string.
     * @returns a Promise which is fulfilled with an array of ICAO strings that matched the ident string.
     * @throws Error if the search was pre-empted by a newer one.
     */
    doSearch(ident: string): Promise<string[]>;
    /**
     * Maps the search results to an array of ICAO strings.
     * @param items The search results.
     * @returns an array of ICAO strings.
     */
    private mapResult;
    /**
     * Artificial delay for skipping cycles during search.
     * @param time The time to wait.
     * @returns a Promise which fulfills when the delay expires.
     */
    private delay;
    /**
     * Generates a unique id for search context.
     * @returns A unique ID string.
     */
    private genGuid;
}

/**
 * A model for maps. Specific functionality is added by adding one or more modules to the model. Each module added to
 * the model is assigned a name which is used to retrieve it from the model.
 */
declare class MapModel<M> {
    private readonly modules;
    /**
     * Gets a module from this model.
     * @param name The name of the module.
     * @returns A module.
     */
    getModule<K extends keyof M & string>(name: K): M[K];
    /**
     * Gets a module instance from the model and assigns it
     * to the provided type.
     * @param module The module to get.
     * @returns The requested map data module.
     */
    getModule<T>(module: new (...args: any) => T): T;
    /**
     * Adds a module to this model.
     * @param name The name of the module to add.
     * @param module The module to add.
     */
    addModule<K extends keyof M & string>(name: K, module: M[K]): void;
}

/**
 * A parameter object for MapProjection.
 */
declare type MapProjectionParameters = {
    /**
     * The target of the projection. The target is guaranteed to be projected to a specific point in the projected
     * window defined by the center of the window plus the target projected offset.
     */
    target?: GeoPointInterface;
    /** The projected offset from the center of the projected window of the projection's target, in pixels. */
    targetProjectedOffset?: ReadonlyFloat64Array;
    /**
     * The range of the projection, in great-arc radians. The range is measured between the projection's two range
     * endpoints.
     */
    range?: number;
    /**
     * The endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`. Each
     * component is expressed in relative projected coordinates, where `0` is the left/top of the projected window, and
     * `1` is the right/bottom of the projected window.
     */
    rangeEndpoints?: ReadonlyFloat64Array;
    /** The post-projected rotation angle, in radians. */
    rotation?: number;
    /** The size of the projected window, in pixels. */
    projectedSize?: ReadonlyFloat64Array;
};
/**
 * The different types of map projection changes.
 */
declare enum MapProjectionChangeType {
    Target = 1,
    Center = 2,
    TargetProjected = 4,
    Range = 8,
    RangeEndpoints = 16,
    ScaleFactor = 32,
    Rotation = 64,
    ProjectedSize = 128,
    ProjectedResolution = 256
}
/**
 * A change listener callback for a MapProjection.
 */
interface MapProjectionChangeListener {
    (source: MapProjection, changeFlags: number): void;
}
/**
 * A geographic projection model for a map. MapProjection uses a mercator projection.
 */
declare class MapProjection {
    private static readonly DEFAULT_SCALE_FACTOR;
    private static readonly SCALE_FACTOR_MAX_ITER;
    private static readonly SCALE_FACTOR_TOLERANCE;
    private static readonly tempVec2_1;
    private static readonly tempVec2_2;
    private static readonly tempVec2_3;
    private static readonly tempVec2_4;
    private static readonly tempGeoPoint_1;
    private static readonly tempGeoPoint_2;
    private static readonly vec3Cache;
    private readonly geoProjection;
    private readonly target;
    private readonly targetProjectedOffset;
    private readonly targetProjected;
    private range;
    private readonly rangeEndpoints;
    private readonly projectedSize;
    private readonly center;
    private readonly centerProjected;
    private projectedRange;
    private widthRange;
    private heightRange;
    private readonly oldParameters;
    private readonly queuedParameters;
    private updateQueued;
    private readonly changeListeners;
    /**
     * Creates a new map projection.
     * @param projectedWidth The initial width of the projection window, in pixels.
     * @param projectedHeight The initial height of the projection window, in pixels.
     */
    constructor(projectedWidth: number, projectedHeight: number);
    /**
     * Gets this map projection's GeoProjection instance.
     * @returns This map projection's GeoProjection instance.
     */
    getGeoProjection(): GeoProjection;
    /**
     * Gets the target geographic point of this projection. The target is guaranteed to be projected to a specific
     * point in the projected window defined by the center of the window plus the target projected offset.
     * @returns The target geographic point of this projection.
     */
    getTarget(): GeoPointReadOnly;
    /**
     * Gets the projected offset from the center of the projected window of the target of this projection.
     * @returns The projected offset from the center of the projected window of the target of this projection.
     */
    getTargetProjectedOffset(): ReadonlyFloat64Array;
    /**
     * Gets the projected location of the target of this projection.
     * @returns The projected location of the target of this projection.
     */
    getTargetProjected(): ReadonlyFloat64Array;
    /**
     * Gets the range of this projection, in great-arc radians, as measured between the projection's two range endpoints.
     * @returns The range of this projection, in great-arc radians.
     */
    getRange(): number;
    /**
     * Gets the endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`. Each
     * component is expressed in relative projected coordinates, where `0` is the left/top of the projected window, and
     * `1` is the right/bottom of the projected window.
     * @returns The endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`.
     */
    getRangeEndpoints(): ReadonlyFloat64Array;
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the center-left to the center-right of
     * the projected window.
     * @returns The range of this projection's projected window width, in great-arc radians.
     */
    getWidthRange(): number;
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the top-center to the bottom-center of
     * the projected window.
     * @returns The range of this projection's projected window height, in great-arc radians.
     */
    getHeightRange(): number;
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor(): number;
    /**
     * Gets the post-projected (planar) rotation angle of this projection in radians.
     * @returns The post-projected rotation angle of this projection.
     */
    getRotation(): number;
    /**
     * Gets the size of the projected window, in pixels.
     * @returns The size of the projected window.
     */
    getProjectedSize(): ReadonlyFloat64Array;
    /**
     * Gets the geographic point located at the center of this projection's projected window.
     * @returns The geographic point located at the center of this projection's projected window.
     */
    getCenter(): GeoPointReadOnly;
    /**
     * Gets the center of this projection's projected window.
     * @returns The center of this projection's projected window.
     */
    getCenterProjected(): ReadonlyFloat64Array;
    /**
     * Gets the average resolution, in great-arc radians per pixel, of the projected map along a line between the range
     * endpoints.
     * @returns The average resolution of the projected map along a line between the range endpoints.
     */
    getProjectedResolution(): number;
    /**
     * Calculates the true range of this projection, in great-arc radians, given a hypothetical projected center point.
     * @param centerProjected The projected location of the hypothetical center point to use for the calculation.
     * @returns The true range of this projection given the hypothetical projected center point.
     */
    private calculateRangeAtCenter;
    /**
     * Recomputes this projection's computed parameters.
     */
    private recompute;
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters: MapProjectionParameters): void;
    /**
     * Sets the projection parameters to be applied when applyQueued() is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters: MapProjectionParameters): void;
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued(): void;
    /**
     * Sets the size of the projected window.
     * @param size The new size, in pixels.
     */
    private setProjectedSize;
    /**
     * Sets the projected offset from the center of the projected window of the target of this projection.
     * @param offset The new offset, in pixels.
     */
    private setTargetProjectedOffset;
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    private storeParameters;
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    private computeChangeFlags;
    /**
     * Computes change flags for derived parameters given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags for derived parameters based on the specified old parameters.
     */
    private computeDerivedChangeFlags;
    /**
     * Projects a set of lat/lon coordinates.
     * @param point The point to project.
     * @param out The vector to which to write the result.
     * @returns The projected point, as a vector.
     */
    project(point: LatLonInterface, out: Float64Array): Float64Array;
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec The 2D position vector describing the location of the projected coordinates.
     * @param out The point to which to write the result.
     * @returns The inverted point.
     */
    invert(vec: ReadonlyFloat64Array, out: GeoPoint): GeoPoint;
    /**
     * Checks whether a point falls within certain projected bounds. The point can be specified as either a GeoPoint
     * object or a 2D vector. If a GeoPoint object is supplied, it will be projected before the bounds check takes
     * place.
     * @param point The point to check.
     * @param bounds The bounds to check against, expressed as a vector ([left, top, right, bottom]). Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point: LatLonInterface | ReadonlyFloat64Array, bounds?: ReadonlyFloat64Array): boolean;
    /**
     * Gets the geographic great-circle distance between two points in great-arc radians. The points can be specified as
     * either GeoPoint objects or 2D vectors. If 2D vectors are supplied, they are interpreted as projected points and
     * inverse projection will be used to convert them to geographic points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The geographic great-circle distance between the points.
     */
    geoDistance(point1: GeoPointInterface | ReadonlyFloat64Array, point2: GeoPointInterface | ReadonlyFloat64Array): number;
    /**
     * Gets the projected Euclidean distance between two points in pixels. The points can be specified as either GeoPoint
     * objects or 2D vectors. If GeoPoint objects are supplied, they will be projected to convert them to projected
     * points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The projected Euclidean distance between two points.
     */
    projectedDistance(point1: GeoPointInterface | ReadonlyFloat64Array, point2: GeoPointInterface | ReadonlyFloat64Array): number;
    /**
     * Notifies all registered change listeners that this projection has been changed.
     * @param changeFlags The types of changes that were made.
     */
    protected notifyChangeListeners(changeFlags: number): void;
    /**
     * Registers a change listener with this projection. The listener will be called every time this projection changes.
     * A listener can be registered multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to register.
     */
    addChangeListener(listener: MapProjectionChangeListener): void;
    /**
     * Removes a change listener from this projection. If the specified listener was registered multiple times, this
     * method will only remove one instance of the listener.
     * @param listener The listener to remove.
     * @returns Whether the listener was successfully removed.
     */
    removeChangeListener(listener: MapProjectionChangeListener): boolean;
}

/**
 * An interface for basic map layer properties.
 */
interface MapLayerProps<M> extends ComponentProps {
    /** A map model. */
    model: MapModel<M>;
    /** A map projection model. */
    mapProjection: MapProjection;
    /**
     * A subscribable which provides the maximum update frequency of the layer, in hertz. Note that the actual update
     * frequency will not exceed the update frequency of the layer's parent map. If not defined, the frequency will
     * default to that of the layer's parent map.
     */
    updateFreq?: Subscribable<number>;
    /** The CSS class(es) to apply to the root of this layer. */
    class?: string | SubscribableSet<string>;
}
/**
 * A base component for map layers.
 */
declare abstract class MapLayer<P extends MapLayerProps<any> = MapLayerProps<any>> extends DisplayComponent<P> {
    private _isVisible;
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible(): boolean;
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val: boolean): void;
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    onVisibilityChanged(isVisible: boolean): void;
    /**
     * This method is called when this layer is attached to its parent map component.
     */
    onAttached(): void;
    /**
     * This method is called when this layer's parent map is woken.
     */
    onWake(): void;
    /**
     * This method is called when this layer's parent map is put to sleep.
     */
    onSleep(): void;
    /**
     * This method is called when the map projection changes.
     * @param mapProjection - this layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * This method is called once every map update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time: number, elapsed: number): void;
    /**
     * This method is called when this layer is detached from its parent map component.
     */
    onDetached(): void;
}

/**
 * Component props for MapComponent.
 */
interface MapComponentProps<M> extends ComponentProps {
    /** A map model. */
    model: MapModel<M>;
    /** The event bus. */
    bus: EventBus;
    /** The update frequency of the map, in hertz. */
    updateFreq?: Subscribable<number>;
    /** The size, as `[width, height]` in pixels, of the map component's projected window. */
    projectedSize: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** A projection to inject. A default will be used if none is provided. */
    projection?: MapProjection;
}
/**
 * A component which displays a map. A map projects geographic coordinates onto a planar pixel grid. Each map component
 * maintains a MapProjection instance which handles the details of the projection. MapLayer objects added to the map
 * as children determine what is drawn on the map.
 */
declare abstract class MapComponent<P extends MapComponentProps<any> = MapComponentProps<any>> extends DisplayComponent<P> {
    /**
     * This map component's projection model.
     */
    readonly mapProjection: MapProjection;
    private readonly layerEntries;
    private readonly projectedSize;
    private lastUpdateTime;
    private _isAwake;
    private updateCycleSub?;
    private readonly updateCycleHandler;
    private projectedSizeSub?;
    /** @inheritdoc */
    constructor(props: P);
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize(): ReadonlyFloat64Array;
    /**
     * Whether this map is awake.
     */
    get isAwake(): boolean;
    /**
     * Puts this map to sleep. While asleep, this map will not be updated.
     */
    sleep(): void;
    /**
     * Wakes this map, allowing it to be updated.
     */
    wake(): void;
    /**
     * Sets this map's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this map's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    private setAwakeState;
    /** @inheritdoc */
    onAfterRender(thisNode: VNode): void;
    /**
     * Scans this component's VNode sub-tree for MapLayer components and attaches them when found. Only the top-most
     * level of MapLayer components are attached; layers that are themselves children of other layers are not attached.
     * @param thisNode This component's VNode.
     */
    protected attachLayers(thisNode: VNode): void;
    /**
     * This method is called when the map is awakened.
     */
    protected onWake(): void;
    /**
     * Calls the onWake() method of this map's layers.
     */
    protected wakeLayers(): void;
    /**
     * This method is called when the map is put to sleep.
     */
    protected onSleep(): void;
    /**
     * Calls the onSleep() method of this map's layers.
     */
    protected sleepLayers(): void;
    /**
     * This method is called when the map projection changes.
     * @param mapProjection This layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    protected onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * This method is called when the size of this map's projected window changes.
     */
    protected abstract onProjectedSizeChanged(): void;
    /**
     * Attaches a layer to this map component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    protected attachLayer(layer: MapLayer): void;
    /**
     * Detaches a layer from this map component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    protected detachLayer(layer: MapLayer): boolean;
    /**
     * Updates this map.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time: number): void;
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    protected onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this map's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    protected updateLayers(time: number, elapsed: number): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A text label to be displayed on a map.
 */
interface MapTextLabel {
    /** The text of this label. */
    readonly text: Subscribable<string>;
    /** The render priority of this label. */
    readonly priority: Subscribable<number>;
    /**
     * Draws this label to a canvas.
     * @param context The canvas rendering context to use to draw.
     * @param mapProjection The projection to use to project the location of the label.
     */
    draw(context: CanvasRenderingContext2D, mapProjection: MapProjection): void;
}
/**
 * Options for a AbstractMapTextLabel.
 */
interface AbstractMapTextLabelOptions {
    /**
     * The anchor point of the label, expressed relative to the width/height of the label. `[0, 0]` is the top-left
     * corner, and `[1, 1]` is the bottom-right corner. Defaults to `[0, 0]`.
     */
    anchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The font type of the label. Defaults to `''` (the default canvas font). */
    font?: string | Subscribable<string>;
    /** The font size of the label, in pixels. Defaults to 10 pixels. */
    fontSize?: number | Subscribable<number>;
    /** The font color of the label. Defaults to `'white'`. */
    fontColor?: string | Subscribable<string>;
    /** The font outline width of the label, in pixels. Defaults to 0. */
    fontOutlineWidth?: number | Subscribable<number>;
    /** The font outline color of the label. Defaults to `'black'`. */
    fontOutlineColor?: string | Subscribable<string>;
    /** Whether to show the background for the label. Defaults to `false`. */
    showBg?: boolean | Subscribable<boolean>;
    /** The label's background color. Defaults to `'black'`. */
    bgColor?: string | Subscribable<string>;
    /** The padding of the label's background, in pixels. Expressed as `[top, right, bottom, left]`. Defaults to `[0, 0, 0, 0]`. */
    bgPadding?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /** The border radius of the label's background, in pixels. Defaults to 0. */
    bgBorderRadius?: number | Subscribable<number>;
    /** The outline width of the label's background, in pixels. Defaults to 0. */
    bgOutlineWidth?: number | Subscribable<number>;
    /** The outline color of the label's background. Defaults to `'white'`. */
    bgOutlineColor?: string | Subscribable<string>;
}
/**
 * An abstract implementation of a map text label.
 */
declare abstract class AbstractMapTextLabel implements MapTextLabel {
    protected static readonly tempVec2: Float64Array;
    /** @inheritdoc */
    readonly text: Subscribable<string>;
    /** @inheritdoc */
    readonly priority: Subscribable<number>;
    /**
     * The anchor point of this label, expressed relative to this label's width/height. [0, 0] is the top-left corner,
     * and [1, 1] is the bottom-right corner.
     */
    readonly anchor: Subscribable<ReadonlyFloat64Array>;
    /** The font type of this label. */
    readonly font: Subscribable<string>;
    /** The font size of this label, in pixels. */
    readonly fontSize: Subscribable<number>;
    /** The font color of this label. */
    readonly fontColor: Subscribable<string>;
    /** The font outline width of this label, in pixels. */
    readonly fontOutlineWidth: Subscribable<number>;
    /** The font outline color of this label. */
    readonly fontOutlineColor: Subscribable<string>;
    /** Whether to show the background for this label. */
    readonly showBg: Subscribable<boolean>;
    /** This label's background color. */
    readonly bgColor: Subscribable<string>;
    /** The padding of this label's background, in pixels. Expressed as [top, right, bottom, left]. */
    readonly bgPadding: Subscribable<ReadonlyFloat64Array>;
    /** The border radius of this label's background. */
    readonly bgBorderRadius: Subscribable<number>;
    /** The outline width of this label's background. */
    readonly bgOutlineWidth: Subscribable<number>;
    /** The outline color of this label's background. */
    readonly bgOutlineColor: Subscribable<string>;
    private fontStr;
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text: string | Subscribable<string>, priority: number | Subscribable<number>, options?: AbstractMapTextLabelOptions);
    draw(context: CanvasRenderingContext2D, mapProjection: MapProjection): void;
    /**
     * Gets the projected position of the label, in pixels.
     * @param mapProjection The map projection to use.
     * @param out The vector to which to write the result.
     * @returns The projected position of the label.
     */
    protected abstract getPosition(mapProjection: MapProjection, out: Float64Array): Float64Array;
    /**
     * Loads this label's text style to a canvas rendering context.
     * @param context The canvas rendering context to use.
     */
    protected setTextStyle(context: CanvasRenderingContext2D): void;
    /**
     * Draws this label's text to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     */
    protected drawText(context: CanvasRenderingContext2D, centerX: number, centerY: number): void;
    /**
     * Draws this label's background to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     */
    protected drawBackground(context: CanvasRenderingContext2D, centerX: number, centerY: number, width: number, height: number): void;
    /**
     * Loads the path of this label's background to a canvas rendering context.
     * @param context The canvas rendering context to use.
     * @param left The x-coordinate of the left edge of the background, in pixels.
     * @param top The y-coordinate of the top edge of the background, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     * @param radius The border radius of the background, in pixels.
     */
    protected loadBackgroundPath(context: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, radius: number): void;
}
/**
 * Options for a MapLocationTextLabel.
 */
interface MapLocationTextLabelOptions extends AbstractMapTextLabelOptions {
    /** The offset of the label from its projected position, as `[x, y]` in pixels. Defaults to `[0, 0]`. */
    offset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
}
/**
 * A text label associated with a specific geographic location.
 */
declare class MapLocationTextLabel extends AbstractMapTextLabel {
    readonly location: Subscribable<GeoPointInterface>;
    readonly offset: Subscribable<ReadonlyFloat64Array>;
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text: string | Subscribable<string>, priority: number | Subscribable<number>, location: GeoPointInterface | Subscribable<GeoPointInterface>, options?: MapLocationTextLabelOptions);
    /** @inheritdoc */
    protected getPosition(mapProjection: MapProjection, out: Float64Array): Float64Array;
}

/**
 * A map text label which can be culled to prevent collision with other labels.
 */
interface MapCullableTextLabel extends MapTextLabel {
    /** Whether this label is immune to culling. */
    readonly alwaysShow: Subscribable<boolean>;
    /** The bounding box of this label. */
    readonly bounds: Float64Array;
    /** An invalidation event. */
    readonly invalidation: ReadonlySubEvent<this, void>;
    /**
     * Updates this label's bounding box.
     * @param mapProjection The map projection to use.
     */
    updateBounds(mapProjection: MapProjection): void;
}
/**
 * A cullable text label associated with a specific geographic location.
 */
declare class MapCullableLocationTextLabel extends MapLocationTextLabel implements MapCullableTextLabel {
    /** @inheritdoc */
    readonly alwaysShow: Subscribable<boolean>;
    /** @inheritdoc */
    readonly bounds: Float64Array;
    /** @inheritdoc */
    readonly invalidation: SubEventInterface<this, void>;
    private readonly subs;
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param alwaysShow Whether this label is immune to culling, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text: string | Subscribable<string>, priority: number | Subscribable<number>, location: GeoPointInterface | Subscribable<GeoPointInterface>, alwaysShow: boolean | Subscribable<boolean>, options?: MapLocationTextLabelOptions);
    /** @inheritdoc */
    updateBounds(mapProjection: MapProjection): void;
    /**
     * Destroys this label.
     */
    destroy(): void;
}
/**
 * Manages a set of MapCullableTextLabels. Colliding labels will be culled based on their render priority. Labels with
 * lower priorities will be culled before labels with higher priorities.
 */
declare class MapCullableTextLabelManager {
    private cullingEnabled;
    private static readonly SCALE_UPDATE_THRESHOLD;
    private static readonly ROTATION_UPDATE_THRESHOLD;
    private static readonly SORT_FUNC;
    private readonly registered;
    private _visibleLabels;
    /** An array of labels registered with this manager that are visible. */
    get visibleLabels(): readonly MapCullableTextLabel[];
    private needUpdate;
    private lastScaleFactor;
    private lastRotation;
    private readonly invalidationHandler;
    /**
     * Creates an instance of the MapCullableTextLabelManager.
     * @param cullingEnabled Whether or not culling of labels is enabled.
     */
    constructor(cullingEnabled?: boolean);
    /**
     * Registers a label with this manager. Newly registered labels will be processed with the next manager update.
     * @param label The label to register.
     */
    register(label: MapCullableTextLabel): void;
    /**
     * Deregisters a label with this manager. Newly deregistered labels will be processed with the next manager update.
     * @param label The label to deregister.
     */
    deregister(label: MapCullableTextLabel): void;
    /**
     * Sets whether or not text label culling is enabled.
     * @param enabled Whether or not culling is enabled.
     */
    setCullingEnabled(enabled: boolean): void;
    /**
     * Updates this manager.
     * @param mapProjection The projection of the map to which this manager's labels are to be drawn.
     */
    update(mapProjection: MapProjection): void;
    /**
     * Checks if two bounding boxes collide.
     * @param a The first bounding box, as a 4-tuple [left, top, right, bottom].
     * @param b The second bounding box, as a 4-tuple [left, top, right, bottom].
     * @returns whether the bounding boxes collide.
     */
    private static doesCollide;
}

/**
 * A waypoint which is renderable to a map.
 */
interface MapWaypoint {
    /** This waypoint's unique string ID. */
    readonly uid: string;
    /** The location of this waypoint. */
    readonly location: Subscribable<GeoPointInterface>;
}

/**
 * An icon for a waypoint displayed on a map.
 */
interface MapWaypointIcon<T extends MapWaypoint> {
    /** The waypoint associated with this icon. */
    readonly waypoint: T;
    /**
     * The render priority of this icon. Icons with higher priorities will be rendered on top of icons with lower
     * priorities.
     */
    readonly priority: Subscribable<number>;
    /**
     * Renders this icon to a canvas.
     * @param context The canvas 2D rendering context to which to render.
     * @param mapProjection The projection to use for rendering.
     */
    draw(context: CanvasRenderingContext2D, mapProjection: MapProjection): void;
}
/**
 * A blank waypoint icon.
 */
declare class MapBlankWaypointIcon<T extends MapWaypoint> implements MapWaypointIcon<T> {
    readonly waypoint: T;
    /** @inheritdoc */
    readonly priority: Subscribable<number>;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     */
    constructor(waypoint: T, priority: number | Subscribable<number>);
    /**
     * Does nothing.
     */
    draw(): void;
}
/**
 * Initialization options for an AbstractMapWaypointIcon.
 */
declare type AbstractMapWaypointIconOptions = {
    /**
     * The anchor point of the icon, expressed as `[x, y]` relative to its width and height. `[0, 0]` is the top-left
     * corner, and `[1, 1]` is the bottom-right corner. Defaults to `[0.5, 0.5]`.
     */
    anchor?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
    /**
     * The offset of the icon from the projected position of its associated waypoint, as `[x, y]` in pixels. Defaults to
     * `[0, 0]`.
     */
    offset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
};
/**
 * An abstract implementation of MapWaypointIcon which supports an arbitrary anchor point and offset.
 */
declare abstract class AbstractMapWaypointIcon<T extends MapWaypoint> implements MapWaypointIcon<T> {
    readonly waypoint: T;
    protected static readonly tempVec2: Float64Array;
    /** @inheritdoc */
    readonly priority: Subscribable<number>;
    /** The size of this icon, as `[width, height]` in pixels. */
    readonly size: Subscribable<ReadonlyFloat64Array>;
    /**
     * The anchor point of this icon, expressed relative to its width and height. [0, 0] is the top-left corner, and
     * [1, 1] is the bottom-right corner.
     */
    readonly anchor: Subscribable<ReadonlyFloat64Array>;
    /** The offset of this icon from the projected position of its associated waypoint, as `[x, y]` in pixels. */
    readonly offset: Subscribable<ReadonlyFloat64Array>;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon, or a subscribable which provides it. Icons with higher
     * priorities should be rendered above those with lower priorities.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint: T, priority: number | Subscribable<number>, size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, options?: AbstractMapWaypointIconOptions);
    /** @inheritdoc */
    draw(context: CanvasRenderingContext2D, mapProjection: MapProjection): void;
    /**
     * Draws the icon at the specified position.
     * @param context The canvas rendering context to use.
     * @param mapProjection The map projection to use.
     * @param left The x-coordinate of the left edge of the icon.
     * @param top The y-coordinate of the top edge of the icon.
     */
    protected abstract drawIconAt(context: CanvasRenderingContext2D, mapProjection: MapProjection, left: number, top: number): void;
}
/**
 * A waypoint icon with an image as the icon's graphic source.
 */
declare class MapWaypointImageIcon<T extends MapWaypoint> extends AbstractMapWaypointIcon<T> {
    protected readonly img: HTMLImageElement;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's image.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint: T, priority: number | Subscribable<number>, img: HTMLImageElement, size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, options?: AbstractMapWaypointIconOptions);
    /** @inheritdoc */
    protected drawIconAt(context: CanvasRenderingContext2D, mapProjection: MapProjection, left: number, top: number): void;
}
/**
 * A waypoint icon with a sprite as the icon's graphic source.
 */
declare class MapWaypointSpriteIcon<T extends MapWaypoint> extends AbstractMapWaypointIcon<T> {
    protected readonly img: HTMLImageElement;
    protected readonly frameWidth: number;
    protected readonly frameHeight: number;
    private spriteFrameHandler?;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's sprite's image source.
     * @param frameWidth The frame width of the sprite, in pixels.
     * @param frameHeight The frame height of the sprite, in pixels.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     * @param spriteFrameHandler An optional handler to determine the sprite frame to draw.
     */
    constructor(waypoint: T, priority: number | Subscribable<number>, img: HTMLImageElement, frameWidth: number, frameHeight: number, size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, options?: AbstractMapWaypointIconOptions, spriteFrameHandler?: ((mapProjection: MapProjection) => number) | undefined);
    /** @inheritdoc */
    protected drawIconAt(context: CanvasRenderingContext2D, mapProjection: MapProjection, left: number, top: number): void;
    /**
     * Gets the sprite frame to render.
     * @param mapProjection The map projection to use.
     * @returns The sprite frame to render.
     */
    protected getSpriteFrame(mapProjection: MapProjection): number;
}

/**
 * A waypoint icon factory.
 */
interface MapWaypointRendererIconFactory<W extends MapWaypoint> {
    /**
     * Gets an icon for a waypoint.
     * @param role The role that was selected for the waypoint for rendering.
     * @param waypoint A waypoint.
     * @returns a waypoint icon.
     */
    getIcon<T extends W>(role: number, waypoint: T): MapWaypointIcon<T> | null;
}
/**
 * A waypoint label factory.
 */
interface MapWaypointRendererLabelFactory<W extends MapWaypoint> {
    /**
     * Gets a label for a waypoint.
     * @param role The role that was selected for the waypoint for rendering.
     * @param waypoint A waypoint.
     * @returns a waypoint label.
     */
    getLabel<T extends W>(role: number, waypoint: T): MapCullableTextLabel | null;
}
/**
 * A render role definition.
 */
declare type MapWaypointRenderRoleDef<W extends MapWaypoint> = {
    /** The icon factory used to create icons for the render role. */
    iconFactory: MapWaypointRendererIconFactory<W> | null;
    /** The label factory used to create labels for the render role. */
    labelFactory: MapWaypointRendererLabelFactory<W> | null;
    /** The canvas rendering context used to draw icons and labels for the render role. */
    canvasContext: CanvasRenderingContext2D | null;
    /** A function which determines whether a waypoint is visible under the render role. */
    visibilityHandler: (waypoint: W) => boolean;
};
/**
 * A function which selects roles under which to render waypoints.
 */
declare type MapWaypointRenderRoleSelector<W extends MapWaypoint> = (entry: MapWaypointRendererEntry<W>, roleDefinitions: ReadonlyMap<number, Readonly<MapWaypointRenderRoleDef<W>>>) => number;
/**
 * Gets the waypoint type supported by a waypoint renderer.
 */
declare type MapWaypointRendererType<Renderer> = Renderer extends MapWaypointRenderer<infer W> ? W : never;
/**
 * A renderer that draws waypoints to a map. For the renderer to draw a waypoint, the waypoint must first be registered
 * with the renderer. Waypoints may be registered under multiple render roles. Each render role is represented as a bit
 * flag. During each render cycle, a specific role is chosen for each waypoint by a selector function. Once the role is
 * chosen, the waypoint will be rendered in that role.
 */
declare class MapWaypointRenderer<W extends MapWaypoint = MapWaypoint> {
    protected readonly textManager: MapCullableTextLabelManager;
    protected readonly selectRoleToRender: MapWaypointRenderRoleSelector<W>;
    /** A null render role definition. Icons rendered under this role are never visible. */
    protected static readonly NULL_ROLE_DEF: {
        iconFactory: null;
        labelFactory: null;
        canvasContext: null;
        visibilityHandler: () => boolean;
    };
    /**
     * Sorts waypoint entries such that those with icons of higher priority are sorted after those with icons of lower
     * priority.
     * @param a The first waypoint entry to sort.
     * @param b The second waypoint entry to sort.
     * @returns A negative number if the first entry is to be sorted before the second, a positive number if the second
     * entry is to be sorted before the first, and zero if the entries' relative sorting order does not matter.
     */
    protected static readonly ENTRY_SORT_FUNC: (a: MapWaypointRendererEntry<any>, b: MapWaypointRendererEntry<any>) => number;
    /**
     * The default render role selector. For each waypoint entry, iterates through all possible render roles in the order
     * they were originally added to the renderer and selects the first role under which the entry is registered and is
     * visible.
     * @param entry A waypoint entry.
     * @param roleDefinitions A map from all possible render roles to their definitions.
     * @returns The role under which the waypoint entry should be rendered, or 0 if the entry should not be rendered
     * under any role.
     */
    static readonly DEFAULT_RENDER_ROLE_SELECTOR: <T extends MapWaypoint>(entry: MapWaypointRendererEntry<T>, roleDefinitions: ReadonlyMap<number, Readonly<MapWaypointRenderRoleDef<T>>>) => number;
    protected readonly registered: Map<string, MapWaypointRendererEntry<W>>;
    protected readonly toCleanUp: Set<MapWaypointRendererEntry<W>>;
    /**
     * This renderer's render role definitions. Waypoints assigned to be rendered under a role or combination of roles
     * with no definition will not be rendered.
     */
    protected readonly roleDefinitions: Map<number, MapWaypointRenderRoleDef<W>>;
    /**
     * An event to subscribe to, fired when waypoints are added to the renderer.
     */
    readonly onWaypointAdded: SubEvent<any, W>;
    /**
     * An event to subscribe to, fired when waypoints are removed from the render.
     */
    readonly onWaypointRemoved: SubEvent<any, W>;
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     * @param selectRoleToRender A function which selects roles under which to render waypoints. Defaults to
     * {@link MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR}.
     */
    constructor(textManager: MapCullableTextLabelManager, selectRoleToRender?: MapWaypointRenderRoleSelector<W>);
    /**
     * Checks whether a render role has been added to this renderer.
     * @param role The render role to check.
     * @returns Whether the render role has been added to this renderer.
     */
    hasRenderRole(role: number): boolean;
    /**
     * Adds a render role to this renderer. If the role has already been added to this renderer, this method does
     * nothing.
     * @param role The render role to add.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @returns Whether the render role was successfully added.
     */
    addRenderRole(role: number, def?: MapWaypointRenderRoleDef<W>): boolean;
    /**
     * Removes a render role from this renderer.
     * @param role The render role to remove.
     * @returns Whether the render role was successfully removed.
     */
    removeRenderRole(role: number): boolean;
    /**
     * Gets the definition for a render role.
     * @param role A render role.
     * @returns The definition for the specified render role, or undefined if no such role has been added to this
     * renderer.
     */
    getRenderRoleDefinition(role: number): Readonly<MapWaypointRenderRoleDef<W>> | undefined;
    /**
     * Gets an iterable of render roles added to this renderer. The iterable will return the roles in the order in which
     * they were added.
     * @returns An iterable of render roles added to this renderer.
     */
    renderRoles(): IterableIterator<number>;
    /**
     * Removes all render roles from this renderer.
     */
    clearRenderRoles(): void;
    /**
     * Sets the factory to use to create waypoint icons for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint icon factory.
     * @returns Whether the factory was set.
     */
    setIconFactory(role: number, factory: MapWaypointRendererIconFactory<W>): boolean;
    /**
     * Sets the factory to use to create waypoint labels for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint label factory.
     * @returns Whether the factory was set.
     */
    setLabelFactory(role: number, factory: MapWaypointRendererLabelFactory<W>): boolean;
    /**
     * Sets the canvas rendering context for a render role. If the render role has not been added to this renderer, this
     * method does nothing.
     * @param role A render role.
     * @param context A canvas 2D rendering context.
     * @returns Whether the context was set.
     */
    setCanvasContext(role: number, context: CanvasRenderingContext2D): boolean;
    /**
     * Sets the handler that determines if a waypoint should visible for a render role. If the render role has not been
     * added to this renderer, this method does nothing.
     * @param role A render role.
     * @param handler A function that determines if a waypoint should be visible.
     * @returns Whether the handler was set.
     */
    setVisibilityHandler(role: number, handler: (waypoint: W) => boolean): boolean;
    /**
     * Checks if a waypoint is registered with this renderer. A role or roles can be optionally specified such that the
     * method will only return true if the waypoint is registered under those specific roles.
     * @param waypoint A waypoint.
     * @param role The specific role(s) to check.
     * @returns whether the waypoint is registered with this renderer.
     */
    isRegistered(waypoint: W, role?: number): boolean;
    /**
     * Registers a waypoint with this renderer under a specific role or roles. Registered waypoints will be drawn as
     * appropriate the next time this renderer's update() method is called. Registering a waypoint under a role under
     * which it is already registered has no effect unless the source of the registration is different.
     * @param waypoint The waypoint to register.
     * @param role The role(s) under which the waypoint should be registered.
     * @param sourceId A unique string ID for the source of the registration.
     */
    register(waypoint: W, role: number, sourceId: string): void;
    /**
     * Removes a registration for a waypoint for a specific role or roles. Once all of a waypoint's registrations for a
     * role are removed, it will no longer be rendered in that role the next this renderer's update() method is called.
     * @param waypoint The waypoint to deregister.
     * @param role The role(s) from which the waypoint should be deregistered.
     * @param sourceId The unique string ID for the source of the registration to remove.
     */
    deregister(waypoint: W, role: number, sourceId: string): void;
    /**
     * Deletes and cleans up a registered waypoint entry.
     * @param entry The entry to delete.
     */
    private deleteEntry;
    /**
     * Redraws waypoints registered with this renderer.
     * @param mapProjection The map projection to use.
     */
    update(mapProjection: MapProjection): void;
    /**
     * Gets the nearest waypoint currently registered in the renderer.
     * @param pos The position to get the closest waypoint to.
     * @param first A predicate that will search the list of closest waypoints for a match, and return the first one found.
     * @returns The nearest waypoint, or undefined if none found.
     */
    getNearestWaypoint<T extends W = W>(pos: LatLonInterface, first?: (waypoint: W) => boolean): T | undefined;
    /**
     * Orders waypoints by their distance to the plane PPOS.
     * @param a The first waypoint.
     * @param b The second waypoint.
     * @param pos The position to compare against.
     * @returns The comparison order number.
     */
    private orderByDistance;
}
/**
 * An entry for a waypoint registered with {@link MapWaypointRenderer}.
 */
declare class MapWaypointRendererEntry<W extends MapWaypoint> {
    readonly waypoint: W;
    private readonly textManager;
    private readonly roleDefinitions;
    private readonly selectRoleToRender;
    private readonly registrations;
    private _roles;
    private _icon;
    private _label;
    private _lastRenderedRole;
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this entry.
     * @param textManager The text manager to which to register this entry's labels.
     * @param roleDefinitions A map of all valid render roles to their definitions.
     * @param selectRoleToRender A function to use to select roles under which to render this entry.
     */
    constructor(waypoint: W, textManager: MapCullableTextLabelManager, roleDefinitions: ReadonlyMap<number, Readonly<MapWaypointRenderRoleDef<W>>>, selectRoleToRender: MapWaypointRenderRoleSelector<W>);
    /** The render role(s) assigned to this entry. */
    get roles(): number;
    /** The role under which this entry was last rendered, or 0 if this entry has not yet been rendered. */
    get lastRenderedRole(): number;
    /** This entry's waypoint icon. */
    get icon(): MapWaypointIcon<W> | null;
    /** This entry's waypoint label. */
    get label(): MapCullableTextLabel | null;
    /**
     * Checks whether this entry is assigned any of the specified render roles. Optionally, this method can also check
     * if this entry was last rendered in any of the specified roles instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAnyRole(roles: number, useLastRendered?: boolean): boolean;
    /**
     * Checks whether this entry is assigned only the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in only the specified role(s) instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isOnlyRole(roles: number, useLastRendered?: boolean): boolean;
    /**
     * Checks whether this entry is assigned all the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in all the specified role(s) instead.
     * @param roles - the render role(s) against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAllRoles(roles: number, useLastRendered?: boolean): boolean;
    /**
     * Assigns one or more render roles to this entry.
     * @param roles The render role(s) to assign.
     * @param sourceId The unique string ID of the source of the assignment.
     */
    addRole(roles: number, sourceId: string): void;
    /**
     * Removes one or more render roles from this entry.
     * @param roles The render role(s) to remove.
     * @param sourceId The unique string ID of the soruce of the de-assignment.
     */
    removeRole(roles: number, sourceId: string): void;
    /**
     * Prepares this entry for rendering.
     * @param showRole The role in which this entry should be rendered.
     * @param iconFactory The factory to use to get a waypoint icon.
     * @param labelFactory The factory to use to get a waypoint label.
     */
    private prepareRender;
    /**
     * Updates this entry. An appropriate render role is selected, then the icon and label are updated as appropriate
     * for the chosen role. If the waypoint's label should be visible, it is added to the appropriate text manager.
     * Of note, this method will not draw the waypoint icon to a canvas element; it will simply ensure the .showIcon
     * property contains the correct value depending on whether the icon should be visible.
     */
    update(): void;
    /**
     * Destroys this entry. Any label from this entry currently registered with the text manager will be deregistered.
     */
    destroy(): void;
}

/**
 * A stream of canvas 2D rendering context-like path commands.
 */
interface PathStream {
    /**
     * Begins a path. Erases all previous path state.
     */
    beginPath(): void;
    /**
     * Moves to a specified point.
     * @param x The x-coordinate of the point to which to move.
     * @param y The y-coordinate of the point to which to move.
     */
    moveTo(x: number, y: number): void;
    /**
     * Paths a straight line from the current point to a specified point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    lineTo(x: number, y: number): void;
    /**
     * Paths a cubic Bezier curve from the current point to a specified point.
     * @param cp1x The x-coordinate of the first control point.
     * @param cp1y The y-coordinate of the first control point.
     * @param cp2x The x-coordinate of the second control point.
     * @param cp2y The y-coordinate of the second control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /**
     * Paths a quadrative Bezier curve from the current point to a specified point.
     * @param cpx The x-coordinate of the control point.
     * @param cpy The y-coordinate of the control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /**
     * Paths an arc.
     * @param x The x-coordinate of the center of the circle containing the arc.
     * @param y The y-coordinate of the center of the circle containing the arc.
     * @param radius The radius of the arc.
     * @param startAngle The angle of the start of the arc, in radians.
     * @param endAngle The angle of the end of the arc, in radians.
     * @param counterClockwise Whether the arc should be drawn counterclockwise. False by default.
     */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /**
     * Paths a line from the current point to the first point defined by the current path.
     */
    closePath(): void;
}
/**
 * A path stream which does nothing on any input.
 */
declare class NullPathStream implements PathStream {
    /** An instance of a {@link NullPathStream}. */
    static readonly INSTANCE: NullPathStream;
    /**
     * Does nothing.
     */
    beginPath(): void;
    /**
     * Does nothing.
     */
    moveTo(): void;
    /**
     * Does nothing.
     */
    lineTo(): void;
    /**
     * Does nothing.
     */
    bezierCurveTo(): void;
    /**
     * Does nothing.
     */
    quadraticCurveTo(): void;
    /**
     * Does nothing.
     */
    arc(): void;
    /**
     * Does nothing.
     */
    closePath(): void;
}
/**
 * A path stream which sends a transformed version of its input to be consumed by another stream.
 */
interface TransformingPathStream extends PathStream {
    /**
     * Gets the path stream that is consuming this stream's transformed output.
     * @returns The path stream that is consuming this stream's transformed output.
     */
    getConsumer(): PathStream;
    /**
     * Sets the path stream that consumes this stream's transformed output.
     * @param consumer The new consuming path stream.
     */
    setConsumer(consumer: PathStream): void;
}
/**
 * An abstract implementation of a path stream which sends a transformed version of its input to be consumed by another
 * stream.
 */
declare abstract class AbstractTransformingPathStream implements TransformingPathStream {
    protected consumer: PathStream;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     */
    constructor(consumer: PathStream);
    /** @inheritdoc */
    getConsumer(): PathStream;
    /** @inheritdoc */
    setConsumer(consumer: PathStream): void;
    /** @inheritdoc */
    abstract beginPath(): void;
    /** @inheritdoc */
    abstract moveTo(x: number, y: number): void;
    /** @inheritdoc */
    abstract lineTo(x: number, y: number): void;
    /** @inheritdoc */
    abstract bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    abstract quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    abstract arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    abstract closePath(): void;
}
/**
 * A path stream which sends its inputs unchanged to be consumed by another stream.
 */
declare class PassThroughPathStream extends AbstractTransformingPathStream {
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
}

/**
 * A path stream which performs clipping to an axis-aligned rectangular bounding box before sending the clipped path
 * to another stream. Clipping is only supported for path segments added via the `lineTo()` and `arc()` methods. Path
 * segments added via `bezierCurveTo()` and `quadraticCurveTo()` will be passed to the consumer stream unclipped.
 */
declare class ClippedPathStream extends AbstractTransformingPathStream {
    private readonly bounds;
    private static readonly vec2Cache;
    private static readonly vec3Cache;
    private static readonly intersectionCache;
    private readonly boundsHandler;
    private readonly boundsLines;
    private isBoundingRectNonZero;
    private readonly firstPoint;
    private readonly prevPoint;
    private prevPointOutcode;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param bounds A subscribable which provides the clipping bounds for this stream, as `[left, top, right, bottom]`.
     * Whenever the clipping bounds change, the state of this stream will be reset, as if `beginPath()` were called.
     */
    constructor(consumer: PathStream, bounds: Subscribable<ReadonlyFloat64Array>);
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
    /**
     * Resets the state of this stream.
     */
    private reset;
    /**
     * Gets the Cohen-Sutherland outcode for a point.
     * @param x The x-coordinate of the query point.
     * @param y The y-coordinate of the query point.
     * @returns The outcode for the point.
     */
    private getOutcode;
    /**
     * Handles clipping bounds change events.
     */
    private onBoundsChanged;
    /**
     * Destroys this stream.
     */
    destroy(): void;
    /**
     * Gets the line coordinate vector for a line passing through two points.
     * @param x1 The x-coordinate of the first point on the line.
     * @param y1 The y-coordinate of the first point on the line.
     * @param x2 The x-coordinate of the second point on the line.
     * @param y2 The y-coordinate of the second point on the line.
     * @param out A Float64Array object to which to write the result.
     * @returns The line coordinate vector of the line passing through the two points.
     */
    private static getLineCoordinates;
    /**
     * Finds the intersection point between two lines in 2D Euclidean space.
     * @param line1 The line coordinate vector of the first line.
     * @param line2 The line coordinate vector of the second line.
     * @param out A Float64Array object to which to write the result.
     * @returns The intersection point of the two lines, or undefined if the two lines are parallel.
     */
    private static findLineLineIntersection;
}

/**
 * A path stream which transforms a path stream in geographic spherical coordinates to one in projected planar
 * coordinates.
 */
declare class GeoProjectionPathStream extends AbstractTransformingPathStream {
    private projection;
    private static readonly geoPointCache;
    private static readonly geoCircleCache;
    private readonly resampler;
    private readonly firstPoint;
    private readonly prevPoint;
    private readonly prevPointProjected;
    private readonly resampleHandler;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param projection The projection this stream uses.
     * @param minDistance The minimum great-circle distance this stream's resampler enforces between two adjacent
     * resampled points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance this stream's resampler uses when deciding whether to discard a
     * resampled point during the line simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this stream's resampler. The number of
     * resampled points is bounded from above by 2^[maxDepth] - 1.
     */
    constructor(consumer: PathStream, projection: GeoProjection, minDistance: number, dpTolerance: number, maxDepth: number);
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param projection The projection this stream uses.
     * @param resampler The geo circle resampler this stream uses.
     */
    constructor(consumer: PathStream, projection: GeoProjection, resampler: GeoCircleResampler);
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection(): GeoProjection;
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection: GeoProjection): void;
    /** @inheritdoc */
    beginPath(): void;
    /**
     * Moves to a specified point.
     * @param lon The longitude of the point to which to move, in degrees.
     * @param lat The latitude of the point to which to move, in degrees.
     */
    moveTo(lon: number, lat: number): void;
    /**
     * Paths a great-circle arc from the current point to a specified point.
     * @param lon The longitude of the end point, in degrees.
     * @param lat The latitude of the end point, in degrees.
     * @throws Error if the specified point is antipodal to the last pathed point.
     */
    lineTo(lon: number, lat: number): void;
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    bezierCurveTo(): void;
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    quadraticCurveTo(): void;
    /**
     * Paths a small-circle arc.
     * @param lon The longitude of the center of the circle containing the arc, in degrees.
     * @param lat The latitude of the center of the circle containing the arc, in degrees.
     * @param radius The radius of the arc, in great-arc radians.
     * @param startAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the start of the arc; otherwise the longitude, in degrees, of the start
     * of the arc.
     * @param endAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the end of the arc; otherwise the longitude, in degrees, of the end of
     * the arc.
     * @param counterClockwise Whether the arc should be drawn counterclockwise. False by default.
     */
    arc(lon: number, lat: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /**
     * Paths a great-circle arc from the current point to the first point defined by the current path.
     */
    closePath(): void;
    /**
     * Resets the state of this stream.
     */
    private reset;
    /**
     * Handles resampled points.
     * @param vector A vector which describes the projected path terminating at the resampled point.
     */
    private onResampled;
}

/**
 * A {@link TransformingPathStream} which applies an affine transformation to its input.
 *
 * The types of transformation supported by this class are:
 * * Translation.
 * * Uniform scaling.
 * * Rotation.
 */
declare class AffineTransformPathStream extends AbstractTransformingPathStream {
    private static readonly vec2Cache;
    private static readonly transformCache;
    private readonly transform;
    private readonly concatCache;
    private scale;
    private rotation;
    /**
     * Adds a translation to this stream's transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the translation before this stream's current transformation.
     * * `'after'` - Applies the translation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addTranslation(x: number, y: number, order?: 'before' | 'after'): this;
    /**
     * Adds a uniform scaling to this stream's transformation.
     * @param factor The scaling factor.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the scaling before this stream's current transformation.
     * * `'after'` - Applies the scaling after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addScale(factor: number, order?: 'before' | 'after'): this;
    /**
     * Adds a rotation to this stream's transformation.
     * @param angle The rotation angle, in radians.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the rotation before this stream's current transformation.
     * * `'after'` - Applies the rotation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addRotation(angle: number, order?: 'before' | 'after'): this;
    /**
     * Resets this stream's transformation to the identity transformation.
     * @returns This stream, after its transformation has been changed.
     */
    resetTransform(): this;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
    /**
     * Updates this stream's cached scale and rotation values from its transformation.
     */
    private updateScaleRotation;
    /**
     * Applies this stream's transformation to a point.
     * @param x The x-coordinate of the point to transform.
     * @param y The y-coordinate of the point to transform.
     * @returns The transformed point.
     */
    private applyTransform;
}

/**
 * A pattern which can be drawn along a path.
 */
interface PathPattern {
    /** The along-path length of each repeating unit of this pattern. */
    readonly length: number;
    /**
     * The anchor point of each repeating unit of this pattern along its length, as a fraction of the total length. The
     * orientation of each pattern unit is determined by the direction of the path at its anchor point.
     */
    readonly anchor: number;
    /**
     * Draws a single unit of this pattern to a path stream. The coordinate system of the path stream is set such that
     * the anchor point of the pattern unit is located at the origin (0, 0), and the positive x-axis points in the
     * direction of the path on which the pattern unit is placed.
     * @param stream The path stream to which to draw this pattern.
     */
    draw(stream: PathStream): void;
}
/**
 * A {@link TransformingPathStream} which converts an input path into path commands to draw a repeating pattern along
 * the input path.
 */
declare class PatternPathStream implements TransformingPathStream {
    private pattern;
    private static readonly vec2Cache;
    private readonly clipBounds;
    private readonly transformStream;
    private readonly clipStream;
    private readonly firstPoint;
    private readonly prevPoint;
    private distanceLeft;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param pattern The pattern drawn by this stream. If the pattern is `null`, then this stream will pass through path
     * commands to its consumer without transforming them into a pattern.
     */
    constructor(consumer: PathStream, pattern: PathPattern | null);
    /**
     * Gets the pattern drawn by this stream.
     * @returns The pattern drawn by this stream.
     */
    getPattern(): PathPattern | null;
    /**
     * Sets the pattern drawn by this stream. If the pattern is `null`, then this stream will pass through path commands
     * to its consumer without transforming them into a pattern.
     * @param pattern A pattern.
     */
    setPattern(pattern: PathPattern | null): void;
    /** @inheritdoc */
    getConsumer(): PathStream;
    /** @inheritdoc */
    setConsumer(consumer: PathStream): void;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /**
     * Not supported by this path stream. Calling this method will execute a `moveTo()` command to the specified end
     * point.
     * @param cp1x The x-coordinate of the first control point.
     * @param cp1y The y-coordinate of the first control point.
     * @param cp2x The x-coordinate of the second control point.
     * @param cp2y The y-coordinate of the second control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /**
     * Not supported by this path stream. Calling this method will execute a `moveTo()` command to the specified end
     * point.
     * @param cpx The x-coordinate of the control point.
     * @param cpy The y-coordinate of the control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
    /**
     * Resets the state of this stream.
     */
    private reset;
}

/**
 * A stack of {@link TransformingPathStream}s. Inputs are passed through the entire stack from top to bottom before the
 * final transformed output is sent to a consuming stream.
 */
declare class TransformingPathStreamStack extends AbstractTransformingPathStream {
    private readonly stack;
    /**
     * Adds a transforming path stream to the top of this stack.
     * @param stream A transforming path stream.
     */
    push(stream: TransformingPathStream): void;
    /**
     * Removes the top-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    pop(): TransformingPathStream | undefined;
    /**
     * Adds a transforming path stream to the bottom of this stack.
     * @param stream A transforming path stream.
     */
    unshift(stream: TransformingPathStream): void;
    /**
     * Removes the bottom-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shift(): TransformingPathStream | undefined;
    /** @inheritdoc */
    setConsumer(consumer: PathStream): void;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
}

/**
 * A stack of {@link TransformingPathStream}s which transforms an input in spherical geographic coordinates to planar
 * projected coordinates. The stack contains two sub-stacks: a pre-projected stack which transforms the path before
 * it is projected, and a post-projected stack which transforms the projected path before it is sent to the consumer.
 * Transforming streams can be added to the top and bottom of each sub-stack. The input will be passed through each
 * stream in the pre-projected stack from top to bottom, then projected, then passed through each stream in the post-
 * projected stack from top to bottom, and the final transformed output will be passed to the consumer.
 */
declare class GeoProjectionPathStreamStack extends AbstractTransformingPathStream {
    private readonly projectionStream;
    private readonly preStack;
    private readonly postStack;
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param projection The projection this stream uses.
     * @param minDistance The minimum great-circle distance this stream's resampler enforces between two adjacent
     * resampled points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance this stream's resampler uses when deciding whether to discard a
     * resampled point during the line simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this stream's resampler. The number of
     * resampled points is bounded from above by 2^[maxDepth] - 1.
     */
    constructor(consumer: PathStream, projection: GeoProjection, minDistance: number, dpTolerance: number, maxDepth: number);
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param projection The projection this stream uses.
     * @param resampler The geo circle resampler this stream uses.
     */
    constructor(consumer: PathStream, projection: GeoProjection, resampler: GeoCircleResampler);
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection(): GeoProjection;
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection: GeoProjection): void;
    /**
     * Adds a transforming path stream to the top of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    pushPreProjected(stream: TransformingPathStream): void;
    /**
     * Removes the top-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPreProjected(): TransformingPathStream | undefined;
    /**
     * Adds a transforming path stream to the bottom of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPreProjected(stream: TransformingPathStream): void;
    /**
     * Removes the bottom-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPreProjected(): TransformingPathStream | undefined;
    /**
     * Adds a transforming path stream to the top of the post-projected stack.
     * @param stream A transforming path stream.
     */
    pushPostProjected(stream: TransformingPathStream): void;
    /**
     * Removes the top-most path stream from the post-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPostProjected(): TransformingPathStream | undefined;
    /**
     * Adds a transforming path stream to the bottom of the post-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPostProjected(stream: TransformingPathStream): void;
    /**
     * Removes the bottom-most path stream from the post-projected stack. The removed stream will have its consumer set
     * to {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPostProjected(): TransformingPathStream | undefined;
    /** @inheritdoc */
    setConsumer(consumer: PathStream): void;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
}

/**
 * Renders arcs along geo circles to a path stream stack.
 */
declare class GeoCirclePathRenderer {
    private static readonly NORTH_POLE_VEC;
    private static readonly geoPointCache;
    private static readonly vec3Cache;
    /**
     * Renders an arc along a geo circle to a path stream stack.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param streamStack The path stream stack to which to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the arc is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected arc starts. Defaults to false.
     */
    render(circle: GeoCircle, startLat: number, startLon: number, endLat: number, endLon: number, streamStack: GeoProjectionPathStreamStack, continuePath?: boolean): void;
}

/**
 * Renders arcs along geo circles as curved lines.
 */
declare class GeoCircleLineRenderer {
    private static readonly EMPTY_DASH;
    private readonly pathRenderer;
    /**
     * Renders an arc along a geo circle to a canvas.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     * @param outlineWidth The width of the outline, in pixels. Defaults to 0 pixels.
     * @param outlineStyle The style of the outline. Defaults to `'black'`.
     */
    render(circle: GeoCircle, startLat: number, startLon: number, endLat: number, endLon: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, width: number, style: string, dash?: readonly number[], outlineWidth?: number, outlineStyle?: string): void;
}

/**
 * Renders arcs along geo circles as repeating patterns.
 */
declare class GeoCirclePatternRenderer {
    private readonly pathRenderer;
    private readonly patternStream;
    /**
     * Renders an arc along a geo circle to a canvas.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param pattern The pattern to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the arc is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected arc starts. Defaults to false.
     */
    render(circle: GeoCircle, startLat: number, startLon: number, endLat: number, endLon: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, pattern: PathPattern, continuePath?: boolean): void;
}

/**
 * Rendering order of flight plan legs.
 */
declare type FlightPathPlanRenderOrder = 'forward' | 'reverse';
/**
 * Renders flight plan paths one leg at a time in either forward or reverse order. Optionally forces the rendering of
 * the active flight plan leg to be last.
 */
declare abstract class AbstractFlightPathPlanRenderer<Args extends any[] = []> {
    protected readonly renderOrder: FlightPathPlanRenderOrder;
    protected readonly renderActiveLegLast: boolean;
    /**
     * Constructor.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in
     * a first-to-last fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(renderOrder?: FlightPathPlanRenderOrder, renderActiveLegLast?: boolean);
    /**
     * Renders a flight plan path to a canvas.
     * @param plan The flight plan to render.
     * @param startIndex The global index of the first flight plan leg to render, inclusive. Defaults to `0`.
     * @param endIndex The global index of the last flight plan leg to render, inclusive. Defaults to `plan.length - 1`.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param args Additional arguments.
     */
    render(plan: FlightPlan, startIndex: number | undefined, endIndex: number | undefined, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
    /**
     * Renders a flight plan leg.
     * @param leg The flight plan leg to render.
     * @param plan The flight plan containing the leg to render.
     * @param activeLeg The active leg in the flight plan.
     * @param legIndex The global index of the leg in its flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param projection The map projection to use when rendering.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     */
    protected abstract renderLeg(leg: LegDefinition, plan: FlightPlan, activeLeg: LegDefinition | undefined, legIndex: number, activeLegIndex: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
}

/**
 * Parts of a flight plan leg path to render.
 */
declare enum FlightPathLegRenderPart {
    /** None. */
    None = 0,
    /** The ingress transition. */
    Ingress = 1,
    /** The base path. */
    Base = 2,
    /** The egress transition. */
    Egress = 4,
    /** The entire leg path. */
    All = 7
}
/**
 * Renders flight plan leg paths one vector at a time, optionally excluding the ingress and/or egress transition
 * vectors.
 */
declare abstract class AbstractFlightPathLegRenderer<Args extends any[] = []> {
    protected static readonly geoPointCache: GeoPoint[];
    protected static readonly geoCircleCache: GeoCircle[];
    protected readonly tempVector: CircleVector;
    /**
     * Renders a flight plan leg path to a canvas.
     * @param leg The flight plan leg to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param partsToRender The parts of the leg to render, as a combination of {@link FlightPathLegRenderPart}
     * values.
     * @param args Additional arguments.
     */
    render(leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, partsToRender: number, ...args: Args): void;
    /**
     * Renders a flight path vector.
     * @param vector The flight path vector to render.
     * @param isIngress Whether the vector is part of the ingress transition.
     * @param isEgress Whether the vector is part of the egress transition.
     * @param leg The flight plan leg containing the vector to render.
     * @param projection The map projection to use when rendering.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     */
    protected abstract renderVector(vector: FlightPathVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
}

/**
 * Renders flight plan leg paths one vector at a time, optionally excluding the ingress and/or egress transition
 * vectors. The rendering behavior for each vector is controlled by a function passed to the class constructor.
 */
declare class CustomFlightPathLegRenderer<Args extends any[]> extends AbstractFlightPathLegRenderer<Args> {
    protected readonly renderVector: (vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args) => void;
    /**
     * Constructor.
     * @param renderVector A function which renders individual flight path vectors.
     */
    constructor(renderVector: (vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args) => void);
}

/**
 * A style definition for a line rendered by {@link FlightPathLegLineRenderer}.
 */
declare type FlightPathLegLineStyle = {
    /** The width of the line stroke, in pixels. A width of zero or less will cause the stroke to not be rendered. */
    strokeWidth: number;
    /** The style of the line stroke. */
    strokeStyle: string | CanvasPattern | CanvasGradient;
    /** The dash array of the line stroke, or `null` if the stroke is solid. */
    strokeDash: readonly number[] | null;
    /** The width of the line outline, in pixels. A width of zero or less will cause the outline to not be rendered. */
    outlineWidth: number;
    /** The style of the line outline. */
    outlineStyle: string | CanvasPattern | CanvasGradient;
    /** The dash array of the line outline, or `null` if the outline is solid. */
    outlineDash: readonly number[] | null;
    /** Whether the line is continuous with the last vector. */
    isContinuous: boolean;
};
/**
 * A function which selects a line style for a rendered vector.
 * @param vector The vector for which to select a style.
 * @param isIngress Whether the vector is part of the ingress transition.
 * @param isEgress Whether the vector is part of the egress transition.
 * @param leg The flight plan leg containing the vector to render.
 * @param projection The map projection to use when rendering.
 * @param out The line style object to which to write the selected style.
 * @param args Additional arguments.
 * @returns The selected line style for the vector.
 */
declare type FlightPathLegLineStyleSelector<Args extends any[]> = (vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, projection: GeoProjection, out: FlightPathLegLineStyle, ...args: Args) => FlightPathLegLineStyle;
/**
 * Renders flight plan leg paths as lines, with support for different styles for each flight path vector in the leg.
 */
declare class FlightPathLegLineRenderer<Args extends any[] = any[]> extends AbstractFlightPathLegRenderer<Args> {
    private readonly styleSelector;
    private static readonly EMPTY_DASH;
    protected static readonly geoCircleCache: GeoCircle[];
    private readonly pathRenderer;
    private readonly styleBuffer;
    private activeStyleIndex;
    private isAtLegStart;
    private needStrokeLineAtLegEnd;
    /**
     * Constructor.
     * @param styleSelector A function which selects a style for each rendered vector.
     */
    constructor(styleSelector: FlightPathLegLineStyleSelector<Args>);
    /** @inheritdoc */
    render(leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, partsToRender: number, ...args: Args): void;
    /** @inheritdoc */
    protected renderVector(vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
    /**
     * Applies a stroke to a canvas context.
     * @param context A canvas 2D rendering context.
     * @param style The style of the line to stroke.
     */
    private strokeLine;
    /**
     * Checks if two line styles are equal. Styles are considered equal if and only if their stroke and outline widths
     * are zero, or their stroke and outline widths, styles, and dash arrays are the same.
     * @param style1 The first style.
     * @param style2 The second style.
     * @returns Whether the two line styles are equal.
     */
    private static areStylesEqual;
}

/**
 * A style definition for a pattern rendered by {@link FlightPathLegPatternRenderer}.
 */
declare type FlightPathLegPatternStyle = {
    /** The pattern to render. */
    pattern: PathPattern | null;
    /** Whether the pattern is continuous with the previous vector. */
    isContinuous: boolean;
};
/**
 * A function which selects a pattern style for a rendered vector.
 * @param vector The vector for which to select a style.
 * @param isIngress Whether the vector is part of the ingress transition.
 * @param isEgress Whether the vector is part of the egress transition.
 * @param leg The flight plan leg containing the vector to render.
 * @param projection The map projection to use when rendering.
 * @param out The pattern style object to which to write the selected style.
 * @param args Additional arguments.
 * @returns The selected pattern style for the vector.
 */
declare type FlightPathLegPatternStyleSelector<Args extends any[]> = (vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, projection: GeoProjection, out: FlightPathLegPatternStyle, ...args: Args) => FlightPathLegPatternStyle;
/**
 * Renders flight plan leg paths as repeating patterns, with support for different patterns for each flight path vector
 * in the leg.
 */
declare class FlightPathLegPatternRenderer<Args extends any[] = any[]> extends AbstractFlightPathLegRenderer<Args> {
    private readonly styleSelector;
    private readonly pathRenderer;
    private readonly style;
    private isAtDiscontinuity;
    /**
     * Constructor.
     * @param styleSelector A function which selects a style for each rendered vector.
     */
    constructor(styleSelector: FlightPathLegPatternStyleSelector<Args>);
    /** @inheritdoc */
    render(leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, partsToRender: number, ...args: Args): void;
    /** @inheritdoc */
    protected renderVector(vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, ...args: Args): void;
}

/**
 * Renders flight path vectors as a curved line.
 */
declare class FlightPathVectorLineRenderer {
    private static readonly geoCircleCache;
    private readonly renderer;
    /**
     * Renders a flight path vector to a canvas.
     * @param vector The flight path vector to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     * @param outlineWidth The width of the outline, in pixels. Defaults to 0 pixels.
     * @param outlineStyle The style of the outline. Defaults to `'black'`.
     */
    render(vector: CircleVector, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, width: number, style: string, dash?: readonly number[], outlineWidth?: number, outlineStyle?: string): void;
}

/**
 * Renders flight path vectors as repeating patterns.
 */
declare class FlightPathVectorPatternRenderer {
    private static readonly geoCircleCache;
    private readonly renderer;
    /**
     * Renders a flight path vector to a canvas.
     * @param vector The flight path vector to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream to which to render.
     * @param pattern The pattern to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the vector is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected vector starts. Defaults to false.
     */
    render(vector: CircleVector, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack, pattern: PathPattern, continuePath?: boolean): void;
}

/**
 * Renders an airspace to canvas.
 */
interface MapAirspaceRenderer {
    /**
     * Renders an airspace to canvas.
     * @param airspace The airspace to render.
     * @param projection The projection to use when rendering.
     * @param context The canvas rendering context to which to render.
     * @param lod The LOD to render. Defaults to 0.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     */
    render(airspace: LodBoundary, projection: GeoProjection, context: CanvasRenderingContext2D, lod?: number, stream?: PathStream): void;
}
/**
 * An airspace renderer which does not draw any graphics.
 */
declare class NullAirspaceRenderer implements MapAirspaceRenderer {
    /** @inheritdoc */
    render(airspace: LodBoundary, projection: GeoProjection, context: CanvasRenderingContext2D, lod?: number, stream?: PathStream): void;
}
/**
 * An abstract implementation of MapAirspaceRenderer.
 */
declare abstract class MapAbstractAirspaceRenderer implements MapAirspaceRenderer {
    /** @inheritdoc */
    render(airspace: LodBoundary, projection: GeoProjection, context: CanvasRenderingContext2D, lod?: number, stream?: PathStream): void;
    /**
     * Renders a single contiguous shape within an airspace.
     * @param shape The shape to render.
     * @param projection The projection to use when rendering.
     * @param context The canvas rendering context to which to render.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     */
    protected abstract renderShape(shape: Readonly<LodBoundaryShape>, projection: GeoProjection, context: CanvasRenderingContext2D, stream?: PathStream): void;
}

/**
 * An airspace renderer which renders airspace borders as a single line.
 */
declare class MapSingleLineAirspaceRenderer extends MapAbstractAirspaceRenderer {
    readonly lineWidth: number;
    readonly strokeStyle: string | CanvasGradient | CanvasPattern;
    readonly dash: readonly number[];
    private static readonly geoPointCache;
    private static readonly vec2Cache;
    private static readonly vec3Cache;
    /**
     * Constructor.
     * @param lineWidth The stroke width of the rendered airspace line.
     * @param strokeStyle The stroke style of the rendered airspace line.
     * @param dash The dash of the rendered airspace line.
     */
    constructor(lineWidth: number, strokeStyle: string | CanvasGradient | CanvasPattern, dash: readonly number[]);
    /** @inheritdoc */
    protected renderShape(shape: Readonly<LodBoundaryShape>, projection: GeoProjection, context: CanvasRenderingContext2D, stream?: PathStream): void;
    /**
     * Loads a projection of a great-circle path into a canvas rendering context.
     * @param circle The great circle defining the path.
     * @param start The start point of the path.
     * @param end The end point of the path.
     * @param projection The projection to use.
     * @param stream The path stream to which to load the projected path.
     */
    private pathGreatCircle;
    /**
     * Loads a projection of a small-circle path into a canvas rendering context.
     * @param circle The small circle defining the path.
     * @param start The start point of the path.
     * @param end The end point of the path.
     * @param projection The projection to use.
     * @param stream The path stream to which to load the projected path.
     */
    private pathSmallCircle;
}

/**
 * A projected airspace shape which can render its border as optionally offset lines.
 */
interface MapMultiLineAirspaceShape {
    /**
     * Renders this shape's border with a line.
     * @param context The canvas rendering context to which to render.
     * @param offset The offset, in pixels, of the rendered line with respect to this shape's border. A positive offset
     * will shift the line outside of the border.
     * @param lineWidth The stroke width of the line to render.
     * @param strokeStyle The stroke style of the line to render.
     * @param dash The dash of the line to render.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     */
    renderLine(context: CanvasRenderingContext2D, offset: number, lineWidth: number, strokeStyle: string | CanvasGradient | CanvasPattern, dash: number[], stream?: PathStream): void;
}
/**
 * An airspace renderer which supports rendering airspace borders as multiple, optionally offset lines.
 */
declare abstract class MapMultiLineAirspaceRenderer extends MapAbstractAirspaceRenderer {
    private static tempShape?;
    /** @inheritdoc */
    protected renderShape(shape: Readonly<LodBoundaryShape>, projection: GeoProjection, context: CanvasRenderingContext2D, stream?: PathStream): void;
    /**
     * Renders a projected airspace shape with one or more lines.
     * @param shape The shape to render.
     * @param context The canvas rendering context to which to render.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     */
    protected abstract renderLines(shape: MapMultiLineAirspaceShape, context: CanvasRenderingContext2D, stream?: PathStream): void;
}

/** A task. */
declare type Task = () => void;
/**
 * A task queue.
 */
interface TaskQueue {
    /**
     * Checks whether this queue has more tasks.
     * @returns whether this queue has more tasks.
     */
    hasNext(): boolean;
    /**
     * Gets the next task in this queue.
     * @returns the next task in this queue.
     * @throws when the queue is empty.
     */
    next(): Task;
}
/**
 * A task queue backed by an array.
 */
declare class ArrayTaskQueue {
    private readonly tasks;
    private head;
    /**
     * Constructor.
     * @param tasks The array of tasks in this queue.
     */
    constructor(tasks: Task[]);
    hasNext(): boolean;
    next(): Task;
}

/**
 * A handler which defines the behavior of a ThrottledTaskQueueProcess.
 */
interface ThrottledTaskQueueHandler {
    /**
     * This method is called when queue processing is started.
     */
    onStarted(): void;
    /**
     * Checks if queue processing can continue in the current frame. If this method returns false, queue processing will
     * pause in the current frame and resume in the next frame via requestAnimationFrame().
     * @param elapsedFrameCount The number of frames elapsed since queue processing started. Equal to 0 on the first
     * frame, 1 on the second, etc.
     * @param dispatchedTaskCount The number of tasks already dispatched in the current frame.
     * @param timeElapsed The time elapsed so far in the current frame, in milliseconds.
     * @returns whether queue processing can continue in the current frame.
     */
    canContinue(elapsedFrameCount: number, dispatchedTaskCount: number, timeElapsed: number): boolean;
    /**
     * This method is called when queue processing is paused.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started. Equal to 0 on the first
     * frame, 1 on the second, etc.
     */
    onPaused(elapsedFrameCount: number): void;
    /**
     * This method is called when queue processing is finished.
     * @param elapsedFrameCount The number of frames elpased since queue processing started. Equal to 0 on the first
     * frame, 1 on the second, etc.
     */
    onFinished(elapsedFrameCount: number): void;
    /**
     * This method is called when queue processing is aborted.
     */
    onAborted(): void;
}
/**
 * A process which dispatches tasks in a task queue potentially over multiple frames.
 */
declare class ThrottledTaskQueueProcess {
    private readonly queue;
    private readonly handler;
    private _hasStarted;
    private _hasEnded;
    private _shouldAbort;
    /**
     * Constructor.
     * @param queue The queue to process.
     * @param handler A handler which defines the behavior of this process.
     */
    constructor(queue: TaskQueue, handler: ThrottledTaskQueueHandler);
    /**
     * Checks whether this process has been started.
     * @returns whether this process has been started.
     */
    hasStarted(): boolean;
    /**
     * Checks whether this process has ended.
     * @returns whether this process has ended.
     */
    hasEnded(): boolean;
    /**
     * Starts this process.
     */
    start(): void;
    /**
     * Processes the queue.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started.
     */
    private processQueue;
    /**
     * Aborts this process. Has no effect if the process has not been started or if it has already ended.
     */
    abort(): void;
}

/**
 * A manager which facilitates the rendering of multiple airspaces.
 */
interface MapAirspaceRenderManager {
    /**
     * Gets all airspaces registered to this render manager.
     * @returns All airspaces registered to this render manager.
     */
    getRegisteredAirspaces(): readonly LodBoundary[];
    /**
     * Registers an airspace with this render manager. An airspace may only be registered once.
     * @param airspace The airspace to register.
     * @returns Whether the airspace was successfully registered.
     */
    registerAirspace(airspace: LodBoundary): boolean;
    /**
     * Deregisters an airspace with this render manager.
     * @param airspace The airspace to deregister.
     * @returns Whether the airspace was successfully deregistered.
     */
    deregisterAirspace(airspace: LodBoundary): boolean;
    /**
     * Replace all airspaces currently registered with this render manager with a new list of airspaces.
     * @param airspaces The new list of airspaces.
     * @returns Whether the replace operation changed the set of registered airspaces.
     */
    replaceRegisteredAirspaces(airspaces: LodBoundary[]): boolean;
    /**
     * Deregisters all airspaces currently registered with this render manager.
     * @returns Whether any airspaces were deregistered.
     */
    clearRegisteredAirspaces(): boolean;
    /**
     * Generates a throttled task queue process, which when started will render all the airspaces registered with this
     * manager.
     * @param projection The projection to use when rendering.
     * @param context The canvas rendering context to which to render.
     * @param taskQueueHandler The handler to assign to the task queue process.
     * @param lod The LOD to render. Defaults to 0.
     * @param stream The path stream to which to render. If undefined, the path will be rendered directly to the canvas
     * rendering context.
     * @returns A throttled task queue process.
     */
    prepareRenderProcess(projection: GeoProjection, context: CanvasRenderingContext2D, taskQueueHandler: ThrottledTaskQueueHandler, lod?: number, stream?: PathStream): ThrottledTaskQueueProcess;
}

/**
 * A map range and target solution describing a field of view.
 */
declare type MapFieldOfView = {
    /** The range of the field of view, in great-arc radians. */
    range: number;
    /** The target location of the field of view. */
    target: GeoPoint;
};
/**
 * Calculates map projection parameters for fields of view which encompass sets of geographic points.
 */
declare class MapFieldOfViewCalculator {
    private readonly maxIter;
    private readonly rangeTolerance;
    private static readonly DEFAULT_MAX_ITER;
    private static readonly DEFAULT_RANGE_TOLERANCE;
    private static readonly geoPointCache;
    private static readonly vec2Cache;
    private static readonly vec3Cache;
    private readonly tempProjection;
    /**
     * Constructor.
     * @param maxIter The maximum number of iterations to perform when calculating fields of view. Defaults to
     * {@link MapFieldOfViewCalculator.DEFAULT_MAX_ITER}.
     * @param rangeTolerance The error tolerance of calculated field of view ranges, as a fraction of the ideal range for
     * each field of view. Defaults to {@link MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE}.
     */
    constructor(maxIter?: number, rangeTolerance?: number);
    /**
     * Calculates a map field of view, consisting of a range and target location, which encompasses a given set of
     * geographic points (the focus) with the smallest possible range. If there is only one point in the specified focus,
     * then the calculated range will be equal to 0. If the specified focus contains zero points or a field of view could
     * not be calculated, `NaN` will be written to the results.
     * @param mapProjection The projection of the map for which to calculate the field of view.
     * @param focus An array of points comprising the focus of the field of view.
     * @param margins The margins around the projected map boundaries to respect, as `[left, top, right, bottom]` in
     * pixels. The field of view will be calculated in order to avoid placing any points in the focus outside of the
     * margins.
     * @param out The object to which to write the results.
     * @returns The calculated field of view for the specified focus.
     */
    calculateFov(mapProjection: MapProjection, focus: readonly LatLonInterface[], margins: ReadonlyFloat64Array, out: MapFieldOfView): MapFieldOfView;
}

/**
 * Map own airplane icon orientations.
 */
declare enum MapOwnAirplaneIconOrientation {
    HeadingUp = "HeadingUp",
    TrackUp = "TrackUp",
    MapUp = "MapUp"
}
/**
 * A module describing properties of the own airplane icon.
 */
declare class MapOwnAirplaneIconModule {
    /** Whether to show the airplane icon. */
    readonly show: Subject<boolean>;
    /** The orientation of the airplane icon. */
    readonly orientation: Subject<MapOwnAirplaneIconOrientation>;
}

/**
 * A module describing the state of the own airplane.
 */
declare class MapOwnAirplanePropsModule {
    /** The airplane's position. */
    readonly position: GeoPointSubject;
    /** The airplane's true heading, in degrees. */
    readonly hdgTrue: Subject<number>;
    /** The airplane's turn rate, in degrees per second. */
    readonly turnRate: Subject<number>;
    /** The airplane's indicated altitude. */
    readonly altitude: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The airplane's vertical speed. */
    readonly verticalSpeed: NumberUnitSubject<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    /** The airplane's true ground track, in degrees. */
    readonly trackTrue: Subject<number>;
    /** The airplane's ground speed. */
    readonly groundSpeed: NumberUnitSubject<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    /** Whether the airplane is on the ground. */
    readonly isOnGround: Subject<boolean>;
    /** The magnetic variation at the airplane's position. */
    readonly magVar: Subject<number>;
}

/**
 * A module describing the state of the autopilot.
 */
declare class MapAutopilotPropsModule {
    /** The altitude preselector setting. */
    readonly selectedAltitude: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    private readonly apSelectedAltitudeHandler;
}

/**
 * A module describing the nominal range of a map.
 */
declare class MapRangeModule {
    /** The range of the map as a number unit. */
    readonly nominalRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
}

/**
 * A module describing the nominal range of a map.
 */
declare class MapIndexedRangeModule {
    /** The index of the nominal range. */
    readonly nominalRangeIndex: Subscribable<number>;
    /** The array of possible map nominal ranges. */
    readonly nominalRanges: Subject<readonly NumberUnitInterface<UnitFamily.Distance>[]>;
    /** The nominal range. */
    readonly nominalRange: Subscribable<NumberUnitInterface<UnitFamily.Distance, Unit<UnitFamily.Distance>>>;
    /** @inheritdoc */
    constructor();
    /**
     * A callback which is called when the nominal range array changes.
     * @param array The new array.
     */
    private onNominalRangesChanged;
    /**
     * Sets the nominal range by index.
     * @param index The index of the new nominal range.
     * @returns The value of the new nominal range.
     * @throws Error if index of out of bounds.
     */
    setNominalRangeIndex(index: number): NumberUnitInterface<UnitFamily.Distance>;
}

/**
 * A map of airspace show types to their associated nearest boundary search filter bitflags.
 */
declare type MapAirspaceShowTypes = Record<any, number>;
/**
 * A module describing the display of airspaces.
 */
declare class MapAirspaceModule<T extends MapAirspaceShowTypes> {
    readonly showTypes: T;
    /** Whether to show each type of airspace. */
    readonly show: Record<keyof T, Subject<boolean>>;
    /**
     * Constructor.
     * @param showTypes A map of this module's airspace show types to their associated nearest boundary search filter
     * bitflags.
     */
    constructor(showTypes: T);
}

/**
 * A map module describing whether or not various signals are valid.
 */
declare class MapDataIntegrityModule {
    /** Whether GPS position data is valid. */
    readonly gpsSignalValid: Subject<boolean>;
    /** Whether heading data is valid. */
    readonly headingSignalValid: Subject<boolean>;
    /** Whether attitude data is valid. */
    readonly attitudeSignalValid: Subject<boolean>;
    /** Whether ADC data is valid. */
    readonly adcSignalValid: Subject<boolean>;
}

/**
 * A collection of common keys used by the MapSystem API.
 */
declare class MapSystemKeys {
    static readonly TargetControl: "targetControlModerator";
    static readonly RotationControl: "rotationControlModerator";
    static readonly RangeControl: "rangeControlModerator";
    static readonly ClockUpdate: "clockUpdate";
    static readonly OwnAirplaneProps: "ownAirplaneProps";
    static readonly AutopilotProps: "autopilotProps";
    static readonly AltitudeArc: "altitudeArc";
    static readonly TerrainColors: "terrainColors";
    static readonly Weather: "weather";
    static readonly FollowAirplane: "followAirplane";
    static readonly Rotation: "rotation";
    static readonly OwnAirplaneIcon: "ownAirplaneIcon";
    static readonly OwnAirplaneIconOrientation: "ownAirplaneIconOrientation";
    static readonly TextLayer: "text";
    static readonly TextManager: "textManager";
    static readonly Bing: "bing";
    static readonly WaypointRenderer: "waypointRenderer";
    static readonly IconFactory: "iconFactory";
    static readonly LabelFactory: "labelFactory";
    static readonly NearestWaypoints: "nearestWaypoints";
    static readonly FlightPlan: "flightPlan";
    static readonly FlightPlanner: "flightPlanner";
    static readonly FlightPathRenderer: "flightPathRenderer";
    static readonly Airspace: "airspace";
    static readonly AirspaceManager: "airspaceRenderManager";
    static readonly Traffic: "traffic";
    static readonly DataIntegrity: "dataIntegrity";
}

/**
 * A module describing the display of the altitude intercept arc.
 */
declare class MapAltitudeArcModule {
    /** Whether to show the altitude intercept arc. */
    readonly show: Subject<boolean>;
}

/**
 * Modules required for MapAltitudeArcLayer.
 */
interface MapAltitudeArcLayerModules {
    /** Own airplane properties module. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
    /** Autopilot module. */
    [MapSystemKeys.AutopilotProps]: MapAutopilotPropsModule;
    /** Altitude intercept arc module. */
    [MapSystemKeys.AltitudeArc]: MapAltitudeArcModule;
    /** Data integrity module. */
    [MapSystemKeys.DataIntegrity]?: MapDataIntegrityModule;
}
/**
 * Component props for MapAltitudeArcLayer.
 */
interface MapAltitudeArcLayerProps extends MapLayerProps<MapAltitudeArcLayerModules> {
    /**
     * The method with which to render the arc: canvas or SVG. The SVG rendering method can use significantly less
     * texture memory than canvas depending on the size of the arc relative to the parent map. However, arcs rendered
     * using SVG may not be properly occluded by `clip-path` or `border-radius` styles set on the parent map.
     */
    renderMethod: 'canvas' | 'svg';
    /** The precision to apply to the airplane's vertical speed when calculating the position of the arc. */
    verticalSpeedPrecision: NumberUnitInterface<UnitFamily.Speed> | Subscribable<NumberUnitInterface<UnitFamily.Speed>>;
    /** The minimum magnitude of the airplane's vertical speed required to display the arc. */
    verticalSpeedThreshold: NumberUnitInterface<UnitFamily.Speed> | Subscribable<NumberUnitInterface<UnitFamily.Speed>>;
    /** The minimum magnitude of the airplane's vertical deviation from the selected altitude required to display the arc. */
    altitudeDeviationThreshold: NumberUnitInterface<UnitFamily.Distance> | Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** The angular width of the arc, in degrees. Defaults to 60 degrees. */
    arcAngularWidth?: number;
    /** The radius of the arc, in pixels. Defaults to 64 pixels. */
    arcRadius?: number;
    /** The width of the arc stroke, in pixels. Defaults to 2 pixels. */
    strokeWidth?: number;
    /** The style of the arc stroke. Defaults to `'cyan'`. */
    strokeStyle?: string;
    /** The line cap of the arc stroke. Defaults to 'butt'. */
    strokeLineCap?: 'butt' | 'round' | 'square';
    /** The width of the arc outline, in pixels. Defaults to 1 pixel. */
    outlineWidth?: number;
    /** The style of the arc outline. Defaults to `'#505050'`. */
    outlineStyle?: string;
    /** The line cap of the arc outline. Defaults to 'butt'. */
    outlineLineCap?: 'butt' | 'round' | 'square';
}
/**
 * A map layer which displays an altitude intercept arc.
 */
declare class MapAltitudeArcLayer extends MapLayer<MapAltitudeArcLayerProps> {
    private static readonly DEFAULT_ARC_ANGULAR_WIDTH;
    private static readonly DEFAULT_ARC_RADIUS;
    private static readonly DEFAULT_STROKE_WIDTH;
    private static readonly DEFAULT_STROKE_STYLE;
    private static readonly DEFAULT_STROKE_LINECAP;
    private static readonly DEFAULT_OUTLINE_WIDTH;
    private static readonly DEFAULT_OUTLINE_STYLE;
    private static readonly DEFAULT_OUTLINE_LINECAP;
    private static readonly vec2Cache;
    private readonly layerRef;
    private readonly arcAngularWidth;
    private readonly arcRadius;
    private readonly strokeWidth;
    private readonly strokeStyle;
    private readonly strokeLineCap;
    private readonly outlineWidth;
    private readonly outlineStyle;
    private readonly outlineLineCap;
    private readonly ownAirplanePropsModule;
    private readonly autopilotModule;
    private vsPrecisionMap?;
    private vsThresholdMap?;
    private altDevThresholdMap?;
    private readonly vsPrecisionFpm;
    private readonly vsThresholdFpm;
    private readonly altDevThresholdFeet;
    private readonly vsFpm;
    private readonly vsFpmQuantized;
    private readonly projectedPlanePosition;
    private readonly projectPlanePositionHandler;
    private isArcVisibleStatic?;
    private readonly isArcVisibleDynamic;
    private readonly projectedArcPosition;
    private readonly projectedArcAngle;
    private needUpdate;
    private readonly subscriptions;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for the MapComponent.
 */
interface MapBingLayerProps<M> extends MapLayerProps<M> {
    /** The unique ID to assign to this Bing map. */
    bingId: string;
    /**
     * The earth colors for the layer's Bing component. Index 0 defines the water color, and indexes 1 to the end of the
     * array define the terrain colors. Each color should be expressed as `R + G * 256 + B * 256^2`. If not defined, all
     * colors default to black.
     */
    earthColors: SubscribableArray<number>;
    /**
     * The elevation range over which to assign the earth terrain colors, as `[minimum, maximum]` in feet. The terrain
     * colors are assigned at regular intervals over the entire elevation range, starting with the first terrain color at
     * the minimum elevation and ending with the last terrain color at the maximum elevation. Terrain below and above the
     * minimum and maximum elevation are assigned the first and last terrain colors, respectively. Defaults to
     * `[0, 30000]`.
     */
    earthColorsElevationRange?: Subscribable<ReadonlyFloat64Array>;
    /**
     * A subscribable which provides the reference mode for the layer's Bing component.
     */
    reference: Subscribable<EBingReference>;
    /**
     * A subscribable which provides the weather radar mode for the layer's Bing component.
     */
    wxrMode?: Subscribable<WxrMode>;
    /**
     * The weather radar colors for the layer's Bing component. Each entry `E_i` of the array is a tuple `[color, rate]`
     * that defines a color stop, where `color` is an RGBA color expressed as `R + G * 256 + B * 256^2 + A * 256^3` and
     * `rate` is a precipitation rate in millimeters per hour.
     *
     * In general, the color defined by `E_i` is applied to precipitation rates ranging from the rate defined by `E_i-1`
     * to the rate defined by `E_i`. There are two special cases. The color defined by `E_0` is applied to the
     * precipitation rates from zero to the rate defined by `E_0`. The color defined by `E_n-1`, where `n` is the length
     * of the array, is applied to the precipitation rates from the rate defined by `E_n-2` to positive infinity.
     *
     * If not defined, the colors default to {@link BingComponent.DEFAULT_WEATHER_COLORS}.
     */
    wxrColors?: SubscribableArray<readonly [number, number]>;
    /**
     * A subscribable which provides whether or not the map isolines are visible.
     */
    isoLines?: Subscribable<boolean>;
    /**
     * How long to delay binding the map in milliseconds. Defaults to zero milliseconds.
     */
    delay?: number;
    /** The mode to put the map in. Defaults to {@link EBingMode.PLANE}. */
    mode?: EBingMode;
}
/**
 * A FSComponent that display the MSFS Bing Map, weather radar, and 3D terrain.
 */
declare class MapBingLayer<M = any> extends MapLayer<MapBingLayerProps<M>> {
    private readonly bingRef;
    private readonly wrapperStyle;
    private readonly resolution;
    private readonly rotationTransform;
    /** The length of this layer's diagonal, in pixels. */
    private size;
    private needUpdate;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onWake(): void;
    /** @inheritdoc */
    onSleep(): void;
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    private updateFromProjectedSize;
    /**
     * Gets an appropriate size, in pixels, for this Bing layer given specific map projection window dimensions.
     * We get the length of the hypotenuse so that the map edges won't show when rotating.
     * @param projectedSize - the size of the projected map window.
     * @returns an appropriate size for this Bing layer.
     */
    private getSize;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * A callback which is called when the Bing component is bound.
     */
    private onBingBound;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Resets the underlying Bing component's img src attribute.
     */
    resetImgSrc(): void;
    /**
     * Updates the Bing map center position and radius.
     */
    protected updatePositionRadius(): void;
    /**
     * Gets the desired Bing map radius in meters given a map projection model.
     * @param mapProjection - a map projection model.
     * @returns the desired Bing map radius.
     */
    private calculateDesiredRadius;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Properties for a MapCanvasLayer.
 */
interface MapCanvasLayerProps<M> extends MapLayerProps<M> {
    /** Whether to include an offscreen buffer. False by default. */
    useBuffer?: boolean;
}
/**
 * An instance of a canvas within a MapCanvasLayer.
 */
interface MapCanvasLayerCanvasInstance {
    /** This instance's canvas element. */
    readonly canvas: HTMLCanvasElement;
    /** This instance's canvas 2D rendering context. */
    readonly context: CanvasRenderingContext2D;
    /** Whether this instance's canvas is displayed. */
    readonly isDisplayed: boolean;
    /** Clears this canvas. */
    clear(): void;
    /**
     * Resets this instance's canvas. This will erase the canvas of all drawn pixels, reset its state (including all
     * styles, transformations, and cached paths), and clear the Coherent GT command buffer associated with it.
     */
    reset(): void;
}
/**
 * An implementation of MapCanvasLayerCanvasInstance.
 */
declare class MapCanvasLayerCanvasInstanceClass implements MapCanvasLayerCanvasInstance {
    readonly canvas: HTMLCanvasElement;
    readonly context: CanvasRenderingContext2D;
    readonly isDisplayed: boolean;
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean);
    clear(): void;
    reset(): void;
}
/**
 * A layer which uses a canvas to draw graphics.
 */
declare abstract class MapCanvasLayer<P extends MapCanvasLayerProps<any> = MapCanvasLayerProps<any>, C extends MapCanvasLayerCanvasInstance = MapCanvasLayerCanvasInstance> extends MapLayer<P> {
    private readonly displayCanvasRef;
    private width;
    private height;
    private displayCanvasContext;
    private _display?;
    private _buffer?;
    protected isInit: boolean;
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display(): C;
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer(): C;
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay(): C | undefined;
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer(): C | undefined;
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth(): number;
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight(): number;
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width: number): void;
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height: number): void;
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay(): void;
    /**
     * A callback called after the component renders.
     */
    onAfterRender(): void;
    onVisibilityChanged(isVisible: boolean): void;
    /**
     * Updates this layer according to its current visibility.
     */
    protected updateFromVisibility(): void;
    onAttached(): void;
    /**
     * Initializes this layer's canvas instances.
     */
    private initCanvasInstances;
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    protected createCanvasInstance(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean): C;
    /**
     * Updates the canvas element's size.
     */
    protected updateCanvasSize(): void;
    /**
     * Updates the visibility of the display canvas.
     */
    private updateCanvasVisibility;
    /** @inheritdoc */
    render(): VNode | null;
}

/**
 * A canvas map layer whose size and position is synced with the map projection window.
 */
declare class MapSyncedCanvasLayer<P extends MapCanvasLayerProps<any> = MapCanvasLayerProps<any>> extends MapCanvasLayer<P> {
    onAttached(): void;
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    protected updateFromProjectedSize(projectedSize: ReadonlyFloat64Array): void;
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
}

/**
 * Properties for a MapCachedCanvasLayer.
 */
interface MapCachedCanvasLayerProps<M> extends MapLayerProps<M> {
    /** The factor by which the canvas should be overdrawn. Values less than 1 will be clamped to 1. */
    overdrawFactor: number;
}
/**
 * A description of the reference projection of a MapCachedCanvasLayer.
 */
interface MapCachedCanvasLayerReference {
    /** The map center of this reference. */
    readonly center: GeoPointReadOnly;
    /** The projection scale factor of this reference. */
    readonly scaleFactor: number;
    /** The rotation angle, in radians, of this reference. */
    readonly rotation: number;
}
/**
 * A description of the transformation of a MapCachedCanvasLayer's canvas element.
 */
interface MapCachedCanvasLayerTransform {
    /** The scaling factor of this transform. */
    readonly scale: number;
    /** The rotation angle, in radians, of this transform. */
    readonly rotation: number;
    /** The translation, in pixels, of this transform. */
    readonly translation: Float64Array;
    /**
     * The total margin, in pixels, available for translation without invalidating the canvas with this transform's
     * scale factor taken into account.
     */
    readonly margin: number;
    /**
     * The remaining margin, in pixels, available for translation without invalidating the canvas given this transform's
     * current translation and scale factor.
     */
    readonly marginRemaining: number;
}
/**
 * An instance of a canvas within a MapCachedCanvasLayer.
 */
interface MapCachedCanvasLayerCanvasInstance extends MapCanvasLayerCanvasInstance {
    /**
     * This instance's map projection reference. The rendering of items to this instance's canvas is based on this
     * reference.
     */
    readonly reference: MapCachedCanvasLayerReference;
    /** This instance's transform. */
    readonly transform: MapCachedCanvasLayerTransform;
    /** Whether this instance's transform is invalid. */
    readonly isInvalid: boolean;
    /** The projection used to draw this instance's canvas image. */
    readonly geoProjection: GeoProjection;
    /**
     * Syncs this canvas instance with the current map projection.
     * @param mapProjection The current map projection.
     */
    syncWithMapProjection(mapProjection: MapProjection): void;
    /**
     * Syncs this canvas instance with another canvas instance.
     * @param other - the canvas instance with which to sync.
     */
    syncWithCanvasInstance(other: MapCachedCanvasLayerCanvasInstance): void;
    /**
     * Invalidates this canvas instance. This also clears the canvas.
     */
    invalidate(): void;
}
/**
 * An implementation of MapCachedCanvasLayerCanvasInstance.
 */
declare class MapCachedCanvasLayerCanvasInstanceClass extends MapCanvasLayerCanvasInstanceClass implements MapCachedCanvasLayerCanvasInstance {
    private readonly getReferenceMargin;
    private static readonly SCALE_INVALIDATION_THRESHOLD;
    private static readonly tempVec2_1;
    private readonly _reference;
    private readonly _transform;
    private _isInvalid;
    private readonly _geoProjection;
    private readonly canvasTransform;
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @param getReferenceMargin A function which gets this canvas instance's reference margin, in pixels. The reference
     * margin is the maximum amount of translation allowed without invalidation at a scale factor of 1.
     */
    constructor(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean, getReferenceMargin: () => number);
    /** @inheritdoc */
    get reference(): MapCachedCanvasLayerReference;
    /** @inheritdoc */
    get transform(): MapCachedCanvasLayerTransform;
    /** @inheritdoc */
    get isInvalid(): boolean;
    /** @inheritdoc */
    get geoProjection(): GeoProjection;
    /** @inheritdoc */
    syncWithMapProjection(mapProjection: MapProjection): void;
    /** @inheritdoc */
    syncWithCanvasInstance(other: MapCachedCanvasLayerCanvasInstance): void;
    /**
     * Updates this canvas instance's transform given the current map projection.
     * @param mapProjection The current map projection.
     */
    updateTransform(mapProjection: MapProjection): void;
    /**
     * Transforms this instance's canvas element.
     */
    protected transformCanvasElement(): void;
    /** @inheritdoc */
    invalidate(): void;
}
/**
 * A canvas map layer whose image can be cached and transformed as the map projection changes.
 */
declare class MapCachedCanvasLayer<P extends MapCachedCanvasLayerProps<any> = MapCachedCanvasLayerProps<any>> extends MapCanvasLayer<P, MapCachedCanvasLayerCanvasInstance> {
    private size;
    private referenceMargin;
    private needUpdateTransforms;
    /** @inheritdoc */
    constructor(props: P);
    /**
     * Gets the size, in pixels, of this layer's canvas.
     * @returns the size of this layer's canvas.
     */
    getSize(): number;
    /**
     * Gets the reference translation margin, in pixels, of this layer's display canvas. This value is the maximum amount
     * the display canvas can be translated in the x or y direction at a scale factor of 1 without invalidation.
     * @returns the reference translation margin of this layer's display canvas.
     */
    getReferenceMargin(): number;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    protected createCanvasInstance(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, isDisplayed: boolean): MapCachedCanvasLayerCanvasInstanceClass;
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    protected updateFromProjectedSize(projectedSize: ReadonlyFloat64Array): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this layer's canvas instances' transforms.
     */
    protected updateTransforms(): void;
}

/**
 * A ring label.
 */
interface MapLabeledRingLabel<T> {
    /** The content of this label. */
    readonly content: T;
    /**
     * Gets this label's anchor point. The anchor point is expressed relative to the label's width and height, such that
     * (0, 0) is located at the top-left corner and (1, 1) is located at the bottom-right corner.
     * @returns this label's anchor point.
     */
    getAnchor(): ReadonlyFloat64Array;
    /**
     * Gets the angle of the radial on which this label is positioned, in radians. Radial 0 is in the positive x
     * direction.
     * @returns the angle of the radial on which this label is positioned.
     */
    getRadialAngle(): number;
    /**
     * Gets the radial offset of this label from its parent ring, in pixels. Positive values denote displacement away
     * from the center of the ring.
     * @returns the radial offset of this label from its parent ring, in pixels.
     */
    getRadialOffset(): number;
    /**
     * Sets this label's anchor point. The anchor point is expressed relative to the label's width and height, such that
     * (0, 0) is located at the top-left corner and (1, 1) is located at the bottom-right corner.
     * @param anchor The new anchor point.
     */
    setAnchor(anchor: ReadonlyFloat64Array): void;
    /**
     * Sets the angle of the radial on which this label is positioned, in radians. Radial 0 is in the positive x
     * direction.
     * @param angle The new radial angle.
     */
    setRadialAngle(angle: number): void;
    /**
     * Sets the radial offset of this label from its parent ring, in pixels. Positive values denote displacement away
     * from the center of the ring.
     * @param offset The new radial offset.
     */
    setRadialOffset(offset: number): void;
}
/**
 * A map layer which displays a ring (circle) with one or more labels.
 */
declare class MapLabeledRingLayer<T extends MapLayerProps<any>> extends MapLayer<T> {
    protected readonly labelContainerRef: NodeReference<HTMLDivElement>;
    protected readonly canvasLayerRef: NodeReference<MapSyncedCanvasLayer<MapLayerProps<any>>>;
    private readonly center;
    private radius;
    private strokeWidth;
    private strokeStyle;
    private strokeDash;
    private outlineWidth;
    private outlineStyle;
    private outlineDash;
    private needUpdateRingPosition;
    protected isInit: boolean;
    private readonly labels;
    /**
     * Gets the center position of this layer's ring, in pixels.
     * @returns the center position of this layer's ring.
     */
    getRingCenter(): ReadonlyFloat64Array;
    /**
     * Gets the radius of this layer's ring, in pixels.
     * @returns the radius of this layer's ring.
     */
    getRingRadius(): number;
    /**
     * Sets the center and radius of this layer's ring.
     * @param center The new center, in pixels.
     * @param radius The new radius, in pixels.
     */
    setRingPosition(center: ReadonlyFloat64Array, radius: number): void;
    /**
     * Sets the styling for this layer's ring stroke. Any style that is not explicitly defined will be left unchanged.
     * @param width The new stroke width.
     * @param style The new stroke style.
     * @param dash The new stroke dash.
     */
    setRingStrokeStyles(width?: number, style?: string | CanvasGradient | CanvasPattern, dash?: readonly number[]): void;
    /**
     * Sets the styling for this layer's ring outline. Any style that is not explicitly defined will be left unchanged.
     * @param width The new outline width.
     * @param style The new outline style.
     * @param dash The new outline dash.
     */
    setRingOutlineStyles(width?: number, style?: string | CanvasGradient | CanvasPattern, dash?: readonly number[]): void;
    /**
     * Creates a ring label. Labels can only be created after this layer has been rendered.
     * @param content The content of the new label.
     * @returns the newly created ring label, or null if a label could not be created.
     */
    createLabel<L extends string | number | HTMLElement | DisplayComponent<any> | SVGElement>(content: VNode): MapLabeledRingLabel<L> | null;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this layer according to its current visibility.
     */
    protected updateFromVisibility(): void;
    /**
     * Updates the position of this layer's ring.
     */
    protected updateRingPosition(): void;
    /**
     * Draws this layer's ring to canvas.
     */
    private drawRing;
    /**
     * Checks whether this layer's ring is in view.
     * @returns whether this layer's ring is in view.
     */
    protected isRingInView(): boolean;
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context The canvas to which to apply a stroke.
     * @param lineWidth The stroke width.
     * @param strokeStyle The stroke style.
     * @param dash The stroke dash.
     */
    protected applyStrokeToContext(context: CanvasRenderingContext2D, lineWidth: number, strokeStyle: string | CanvasGradient | CanvasPattern, dash: readonly number[]): void;
    /**
     * Updates the position of this layer's labels based on the position of the ring.
     */
    private updateLabelPositions;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * A CSS transform.
 */
interface CssTransform {
    /**
     * Resolves this transform to a CSS transform string.
     * @returns A CSS transform string representative of this transform.
     */
    resolve(): string;
}
/**
 * An abstract implementation of {@link CssTransform}
 */
declare abstract class AbstractCssTransform implements CssTransform {
    protected readonly params: Float64Array;
    protected readonly cachedParams: Float64Array;
    protected stringValue?: string;
    /**
     * Constructor.
     * @param initialParams The transform's initial parameters.
     */
    constructor(initialParams: readonly number[]);
    /** @inheritdoc */
    resolve(): string;
    /**
     * Builds a CSS transform string representative of this transform.
     * @param params The parameters of this transform.
     * @returns A CSS transform string representative of this transform.
     */
    protected abstract buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `matrix` transform.
 */
declare class CssMatrixTransform extends AbstractCssTransform {
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    constructor();
    /**
     * Sets the parameters of this transform.
     * @param scaleX The x scaling value to set.
     * @param skewY The y skew value to set.
     * @param skewX The x skew value to set.
     * @param scaleY The y scaling value to set.
     * @param translateX The x translation value to set.
     * @param translateY The y translation value to set.
     */
    set(scaleX: number, skewY: number, skewX: number, scaleY: number, translateX: number, translateY: number): void;
    /**
     * Sets the parameters of this transform.
     * @param transform A transform object containing the parameters to set.
     */
    set(transform: Transform2D): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `rotate` transform.
 */
declare class CssRotateTransform extends AbstractCssTransform {
    private readonly unit;
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit: 'rad' | 'deg');
    /**
     * Sets this transform's rotation angle.
     * @param angle The angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(angle: number, precision?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `rotate3d` transform.
 */
declare class CssRotate3dTransform extends AbstractCssTransform {
    private readonly unit;
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit: 'rad' | 'deg');
    /**
     * Sets this transform's rotation.
     * @param x The x component of the rotation axis vector.
     * @param y The y component of the rotation axis vector.
     * @param z The z component of the rotation axis vector.
     * @param angle The rotation angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x: number, y: number, z: number, angle: number, precision?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `translateX` transform.
 */
declare class CssTranslateXTransform extends AbstractCssTransform {
    private readonly unit;
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit: string);
    /**
     * Sets this transform's translation.
     * @param x The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(x: number, precision?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `translateY` transform.
 */
declare class CssTranslateYTransform extends AbstractCssTransform {
    private readonly unit;
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit: string);
    /**
     * Sets this transform's translation.
     * @param y The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(y: number, precision?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `translateZ` transform.
 */
declare class CssTranslateZTransform extends AbstractCssTransform {
    private readonly unit;
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit: string);
    /**
     * Sets this transform's translation.
     * @param z The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(z: number, precision?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `translate` transform.
 */
declare class CssTranslateTransform extends AbstractCssTransform {
    private readonly unitX;
    private readonly unitY;
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX: string, unitY?: string);
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x: number, y: number, precisionX?: number, precisionY?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `translate3d` transform.
 */
declare class CssTranslate3dTransform extends AbstractCssTransform {
    private readonly unitX;
    private readonly unitY;
    private readonly unitZ;
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     * @param unitZ The unit to use for this transform's z translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX: string, unitY?: string, unitZ?: string);
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param z The z translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     * @param precisionZ The precision with which to set the z translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x: number, y: number, z: number, precisionX?: number, precisionY?: number, precisionZ?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `scaleX` transform.
 */
declare class CssScaleXTransform extends AbstractCssTransform {
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    constructor();
    /**
     * Sets this transform's scaling.
     * @param x The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x: number, precision?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `scaleY` transform.
 */
declare class CssScaleYTransform extends AbstractCssTransform {
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    constructor();
    /**
     * Sets this transform's scaling.
     * @param y The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(y: number, precision?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `scaleZ` transform.
 */
declare class CssScaleZTransform extends AbstractCssTransform {
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    constructor();
    /**
     * Sets this transform's scaling.
     * @param z The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(z: number, precision?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `scale` transform.
 */
declare class CssScaleTransform extends AbstractCssTransform {
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    constructor();
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x: number, y: number, precisionX?: number, precisionY?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A CSS `scale3d` transform.
 */
declare class CssScale3dTransform extends AbstractCssTransform {
    private static readonly DEFAULT_PARAMS;
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    constructor();
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param z The z scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     * @param precisionZ The precision with which to set the z scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x: number, y: number, z: number, precisionX?: number, precisionY?: number, precisionZ?: number): void;
    /** @inheritdoc */
    protected buildString(params: ReadonlyFloat64Array): string;
}
/**
 * A concatenated chain of CSS transforms.
 */
declare class CssTransformChain<T extends CssTransform[]> implements CssTransform {
    private readonly transforms;
    private readonly stringValues;
    private chainedStringValue?;
    /**
     * Creates a new chain of CSS transforms.
     * @param transforms The individual child transforms that will constitute the new transform chain. The order of
     * the children passed to the constructor determines the order of concatenation. Concatenation follows the standard
     * CSS transform convention: for a concatenation of transforms `[A, B, C]`, the resulting transformation is
     * equivalent to the one produced by multiplying the transformation matrices in the order `(A * B) * C`.
     */
    constructor(...transforms: T);
    /**
     * Gets one of this chain's child transforms.
     * @param index The index of the child to get.
     * @returns The child transform at the specified index in this chain.
     * @throws RangeError if `index` is out of bounds.
     */
    getChild<Index extends number>(index: Index): Omit<NonNullable<T[Index]>, 'resolve'>;
    /** @inheritdoc */
    resolve(): string;
}
/**
 * A subscribable subject whose value is a CSS transform string resolved from a {@link CssTransform}.
 */
declare class CssTransformSubject<T extends CssTransform> extends AbstractSubscribable<string> {
    private readonly _transform;
    private stringValue;
    /** This subject's associated CSS transform. */
    readonly transform: Omit<T, 'resolve'>;
    /**
     * Constructor.
     * @param transform The new subject's CSS transform.
     */
    private constructor();
    /** @inheritdoc */
    get(): string;
    /**
     * Resolves this subject's CSS transform to a CSS transform string, and sets this subject's value to the resolved
     * string. If this changes this subject's value, subscribers will be notified.
     */
    resolve(): void;
    /**
     * Creates a new instance of {@link CssTransformSubject} whose value is resolved from a CSS transform.
     * @param transform A CSS transform.
     * @returns A new instance of {@link CssTransformSubject} whose value is resolved from the specified CSS transform.
     */
    static create<T extends CssTransform>(transform: T): CssTransformSubject<T>;
}
/**
 * A utility class for building CSS transforms.
 */
declare class CssTransformBuilder {
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     * @returns A new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    static matrix(): CssMatrixTransform;
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate` transform, initialized to zero rotation.
     */
    static rotate(unit: 'rad' | 'deg'): CssRotateTransform;
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     */
    static rotate3d(unit: 'rad' | 'deg'): CssRotate3dTransform;
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateX` transform, initialized to zero translation.
     */
    static translateX(unit: string): CssTranslateXTransform;
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateY` transform, initialized to zero translation.
     */
    static translateY(unit: string): CssTranslateYTransform;
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateZ` transform, initialized to zero translation.
     */
    static translateZ(unit: string): CssTranslateZTransform;
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @returns A new instance of a CSS `translate` transform, initialized to zero translation.
     */
    static translate(unitX: string, unitY?: string): CssTranslateTransform;
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @param unitZ The unit to use for the new transform's z translation.
     * @returns A new instance of a CSS `translate3d` transform, initialized to zero translation.
     */
    static translate3d(unitX: string, unitY?: string, unitZ?: string): CssTranslate3dTransform;
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    static scaleX(): CssScaleXTransform;
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    static scaleY(): CssScaleYTransform;
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    static scaleZ(): CssScaleZTransform;
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    static scale(): CssScaleTransform;
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    static scale3d(): CssScale3dTransform;
    /**
     * Concatenates zero or more CSS transformations.
     * @param transforms The individual transforms to concatentate. The order of the transforms passed to the function
     * determines the order of concatenation. Concatenation follows the standard CSS transform convention: for a
     * concatenation of transforms `[A, B, C]`, the resulting transformation is equivalent to the one produced by
     * multiplying the transformation matrices in the order `(A * B) * C`.
     * @returns A new {@link CssTransformChain} object representing the concatenation of the specified transforms.
     */
    static concat<T extends CssTransform[]>(...transforms: T): CssTransformChain<T>;
}

/**
 * Modules required by MapOwnAirplaneLayer.
 */
interface MapOwnAirplaneLayerModules {
    /** Own airplane properties module. */
    ownAirplaneProps: MapOwnAirplanePropsModule;
    /** Own airplane icon module. */
    ownAirplaneIcon: MapOwnAirplaneIconModule;
}
/**
 * Component props for MapOwnAirplaneLayer.
 */
interface MapOwnAirplaneLayerProps<M extends MapOwnAirplaneLayerModules> extends MapLayerProps<M> {
    /** The path to the icon's image file. */
    imageFilePath: string | Subscribable<string>;
    /** The size of the airplane icon, in pixels. */
    iconSize: number | Subscribable<number>;
    /**
     * The point on the icon which is anchored to the airplane's position, expressed relative to the icon's width and
     * height, with [0, 0] at the top left and [1, 1] at the bottom right.
     */
    iconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
}
/**
 * A layer which draws an own airplane icon. The icon is positioned at the projected location of the airplane and is
 * rotated to match the airplane's heading.
 */
declare class MapOwnAirplaneLayer<M extends MapOwnAirplaneLayerModules = MapOwnAirplaneLayerModules> extends MapLayer<MapOwnAirplaneLayerProps<M>> {
    protected static readonly vec2Cache: Float64Array[];
    protected readonly imageFilePath: string | MappedSubscribable<string>;
    protected readonly style: ObjectSubject<{
        display: string;
        position: string;
        left: string;
        top: string;
        width: string;
        height: string;
        transform: string;
        'transform-origin': string;
    }>;
    protected readonly ownAirplanePropsModule: M["ownAirplaneProps"];
    protected readonly ownAirplaneIconModule: M["ownAirplaneIcon"];
    protected readonly iconSize: Subscribable<number>;
    protected readonly iconAnchor: Subscribable<Readonly<Omit<Float64Array, "set" | "copyWithin" | "sort">>>;
    protected readonly iconOffset: Float64Array;
    protected readonly visibilityBounds: Float64Array;
    protected readonly iconTransform: CssTransformChain<[CssTranslate3dTransform, CssRotateTransform]>;
    protected readonly isGsAboveTrackThreshold: MappedSubscribable<boolean>;
    protected showIcon: boolean;
    protected isInsideVisibilityBounds: boolean;
    protected planeRotation: number;
    protected needUpdateVisibility: boolean;
    protected needUpdatePositionRotation: boolean;
    protected showSub?: Subscription;
    protected positionSub?: Subscription;
    protected headingSub?: Subscription;
    protected trackSub?: Subscription;
    protected trackThresholdSub?: Subscription;
    protected iconSizeSub?: Subscription;
    protected iconAnchorSub?: Subscription;
    protected orientationSub?: Subscription;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Updates the icon's offset from the projected position of the airplane.
     */
    protected updateOffset(): void;
    /**
     * Updates the boundaries within the map's projected window that define a region such that if the airplane's
     * projected position falls outside of it, the icon is not visible and therefore does not need to be updated.
     */
    protected updateVisibilityBounds(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates the airplane icon's visibility.
     */
    protected updateIconVisibility(): void;
    /**
     * Updates the airplane icon's projected position and rotation.
     */
    protected updateIconPositionRotation(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Component props for MapTextLayer.
 */
interface MapTextLayerProps extends MapLayerProps<any> {
    /** The text manager to use. */
    manager: MapCullableTextLabelManager;
}
/**
 * A layer which displays text which can be culled to avoid overlap.
 */
declare class MapCullableTextLayer extends MapSyncedCanvasLayer<MapTextLayerProps> {
    onUpdated(time: number, elapsed: number): void;
    /**
     * Clears this layer's canvas and redraws the currently visible labels registered to this layer's text manager.
     */
    private redrawLabels;
}

/**
 * Modules required by MapAirspaceLayer.
 */
interface MapAirspaceLayerModules {
    /** Airspace module. */
    airspace: MapAirspaceModule<MapAirspaceShowTypes>;
}
/**
 * Component props for MapAirspaceLayer.
 */
interface MapAirspaceLayerProps extends MapLayerProps<MapAirspaceLayerModules> {
    /** The event bus. */
    bus: EventBus;
    /** A cache of LodBoundary objects to use to cache airspace search results. */
    lodBoundaryCache: LodBoundaryCache;
    /** The airspace render manager to use to render airspaces. */
    airspaceRenderManager: MapAirspaceRenderManager;
    /** A subscribable which provides the maximum airspace search radius. */
    maxSearchRadius: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** A subscribable which provides the maximum number of items to return per airspace search. */
    maxSearchItemCount: Subscribable<number>;
    /** The debounce delay, in milliseconds, for airspace searches. Defaults to 500. */
    searchDebounceDelay?: number;
    /** The maximum amount of time, in milliseconds, allotted per frame for rendering airspaces. Defaults to 0.2. */
    renderTimeBudget?: number;
}
/**
 * A layer which draws airspaces.
 */
declare class MapAirspaceLayer extends MapLayer<MapAirspaceLayerProps> {
    private static readonly DEFAULT_SEARCH_DEBOUNCE_DELAY;
    private static readonly DEFAULT_RENDER_TIME_BUDGET;
    private static readonly BACKGROUND_RENDER_MARGIN_THRESHOLD;
    private static readonly CLIP_BOUNDS_BUFFER;
    private static readonly geoPointCache;
    private static readonly vec2Cache;
    private readonly canvasLayerRef;
    private clippedPathStream?;
    private readonly clipBoundsSub;
    private readonly facLoader;
    private searchSession?;
    private readonly searchedAirspaces;
    private readonly searchDebounceDelay;
    private readonly renderTimeBudget;
    private activeRenderProcess;
    private readonly renderTaskQueueHandler;
    private searchDebounceTimer;
    private isSearchScheduled;
    private needRefilter;
    private isSearchBusy;
    private lastDesiredSearchRadius;
    private lastSearchRadius;
    private isRenderScheduled;
    private isBackgroundRenderScheduled;
    private isDisplayInvalidated;
    private isAttached;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes this layer's airspace module property listeners.
     */
    private initModuleListeners;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Updates this layer's canvas clipping bounds.
     */
    private updateClipBounds;
    /**
     * Schedules a search. If a search was previously scheduled but not yet executed, this new scheduled search will
     * replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     * @param refilter Whether to update the search's boundary class filter.
     */
    private scheduleSearch;
    /**
     * Schedules a render to be executed during the next update cycle.
     */
    private scheduleRender;
    /**
     * Searches for airspaces around the map center. After the search is complete, the list of search results is filtered
     * and, if necessary, rendered.
     * @param refilter Whether to update the search's boundary class filter.
     */
    private searchAirspaces;
    /**
     * Gets the boundary class filter based on the current airspace type visibility settings.
     * @returns The boundary class filter based on the current airspace type visibility settings.
     */
    private getBoundaryFilter;
    onUpdated(time: number, elapsed: number): void;
    /**
     * Checks if the display and buffer canvases have been invalidated, and if so, clears them and schedules a render.
     */
    private updateFromInvalidation;
    /**
     * If a search is scheduled, decrements the delay timer and if necessary, executes the search.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    private updateScheduledSearch;
    /**
     * Executes a render if one is scheduled.
     */
    private updateScheduledRender;
    /**
     * Syncs this layer's display canvas instance with the current map projection and renders this layer's airspaces to
     * the display.
     */
    protected startRenderProcess(): void;
    /**
     * Checks whether an airspace is within the projected bounds of a cached canvas instance.
     * @param airspace An airspace.
     * @param canvas A cached canvas instance.
     * @returns Whether the airspace is within the projected bounds of the cached canvas instance.
     */
    private isAirspaceInBounds;
    /**
     * Selects an LOD level based on projected map resolution.
     * @param resolution A projected map resolution, in great-arc radians per pixel.
     * @returns An LOD level based on the projected map resolution.
     */
    private selectLod;
    /**
     * Cleans up the active render process.
     */
    private cleanUpRender;
    /**
     * Renders airspaces from the buffer to the display.
     */
    private renderAirspacesToDisplay;
    /**
     * This method is called when the airspace render process pauses.
     */
    private onRenderPaused;
    /**
     * This method is called when the airspace render process finishes.
     */
    private onRenderFinished;
    /**
     * This method is called when the airspace render process is aborted.
     */
    private onRenderAborted;
    /**
     * This method is called when an airspace show property changes.
     */
    private onAirspaceTypeShowChanged;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Facility search types supported by MapAbstractNearestWaypointsLayer.
 */
declare type MapNearestWaypointsLayerSearchTypes = FacilitySearchType.Airport | FacilitySearchType.Vor | FacilitySearchType.Ndb | FacilitySearchType.Intersection | FacilitySearchType.User;
/**
 * Component props for MapAbstractNearestWaypointsLayer.
 */
interface MapAbstractNearestWaypointsLayerProps<R extends MapWaypointRenderer<any> = MapWaypointRenderer> extends MapLayerProps<any> {
    /** The event bus. */
    bus: EventBus;
    /** The waypoint renderer to use. */
    waypointRenderer: R;
    /** A function which retrieves a waypoint for a facility. */
    waypointForFacility: (facility: Facility) => MapWaypointRendererType<R>;
    /** A function which registers a waypoint with this layer's waypoint renderer. */
    registerWaypoint: (waypoint: MapWaypointRendererType<R>, renderer: R) => void;
    /** A function which deregisters a waypoint with this layer's waypoint renderer. */
    deregisterWaypoint: (waypoint: MapWaypointRendererType<R>, renderer: R) => void;
    /** A function which initializes this layer's waypoint renderer. */
    initRenderer?: (waypointRenderer: R, canvasLayer: MapSyncedCanvasLayer) => void;
    /** A function which gets the search center. If not defined, the search center defaults to the center of the map. */
    getSearchCenter?: (mapProjection: MapProjection) => LatLonInterface;
    /** A function which checks if a search should be refreshed. Defaults to `true` if not defined. */
    shouldRefreshSearch?: (searchType: MapNearestWaypointsLayerSearchTypes, center: LatLonInterface, radius: number) => boolean;
    /** A function which gets the item limit for facility searches. */
    searchItemLimit?: (searchType: MapNearestWaypointsLayerSearchTypes, center: LatLonInterface, radius: number) => number;
    /** A function which gets the radius limit for facility searches, in great-arc radians. */
    searchRadiusLimit?: (searchType: MapNearestWaypointsLayerSearchTypes, center: LatLonInterface, radius: number) => number;
    /** The debounce delay for facility searches, in milliseconds. Defaults to 500 milliseconds. */
    searchDebounceDelay?: number;
    /** A callback called when the search sessions are started. */
    onSessionsStarted?: (airportSession: NearestAirportSearchSession, vorSession: NearestVorSearchSession, ndbSession: NearestSearchSession<string, string>, intSession: NearestIntersectionSearchSession, userSession: NearestRepoFacilitySearchSession<UserFacility>) => void;
}
/**
 * An abstract implementation of a map layer which displays waypoints (airports, navaids, and intersections) within a
 * search radius.
 */
declare class MapNearestWaypointsLayer<R extends MapWaypointRenderer<any> = MapWaypointRenderer, P extends MapAbstractNearestWaypointsLayerProps<R> = MapAbstractNearestWaypointsLayerProps<R>> extends MapLayer<P> {
    private static readonly SEARCH_RADIUS_OVERDRAW_FACTOR;
    private readonly canvasLayerRef;
    private readonly searchDebounceDelay;
    private readonly facLoader;
    private facilitySearches?;
    private searchRadius;
    private searchMargin;
    private userFacilityHasChanged;
    /** A set of the ICAOs of all waypoints that should be rendered. */
    private readonly icaosToRender;
    /** A map of rendered waypoints from their ICAOs. */
    private readonly cachedRenderedWaypoints;
    private isInit;
    private readonly facilityRepoSubs;
    /**
     * A callback called when the facility loaded finishes initialization.
     */
    private onFacilityLoaderInitialized;
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     * @param userSession The user facility search session.
     */
    protected onSessionsStarted(airportSession: NearestAirportSearchSession, vorSession: NearestVorSearchSession, ndbSession: NearestSearchSession<string, string>, intSession: NearestIntersectionSearchSession, userSession: NearestRepoFacilitySearchSession<UserFacility>): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes this layer.
     */
    private doInit;
    /**
     * Gets the search center for the waypoint searches on this layer.
     * @returns The waypoint search center geo point.
     */
    private getSearchCenter;
    /**
     * Initializes this layer's waypoint renderer.
     */
    private initWaypointRenderer;
    /** Forces a refresh of all the waypoints. */
    refreshWaypoints(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Updates the desired nearest facility search radius based on the current map projection.
     */
    private updateSearchRadius;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Updates this layer's facility searches.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    private updateSearches;
    /**
     * Attempts to refresh all of the nearest facility searches. Searches will only be refreshed if the desired search
     * radius is different from the last refreshed search radius or the desired search center is outside of the margin
     * of the last refreshed search center.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    tryRefreshAllSearches(center?: LatLonInterface, radius?: number, force?: boolean): void;
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if the desired search radius is different
     * from the last refreshed search radius or the desired search center is outside of the margin of the last refreshed
     * search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    tryRefreshSearch(type: MapNearestWaypointsLayerSearchTypes, center?: LatLonInterface, radius?: number, force?: boolean): void;
    /**
     * Attempts to refresh all of the nearest facility searches.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    private _tryRefreshAllSearches;
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if `this.shouldRefreshSearch()` returns
     * true and and the desired search radius is different from the last refreshed search radius or the desired search
     * center is outside of the margin of the last refreshed search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    private _tryRefreshSearch;
    /**
     * Checks whether one of this layer's searches should be refreshed.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @returns Whether the search should be refreshed.
     */
    private shouldRefreshSearch;
    /**
     * Schedules a refresh of this one of this layer's searches.
     * @param type The type of nearest search to refresh.
     * @param search The search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    private scheduleSearchRefresh;
    /**
     * Processes nearest facility search results. New facilities are registered, while removed facilities are
     * deregistered.
     * @param results Nearest facility search results.
     */
    private processSearchResults;
    /**
     * Registers an ICAO string with this layer. Once an ICAO is registered, its corresponding facility is drawn to this
     * layer using a waypoint renderer.
     * @param icao The ICAO string to register.
     */
    private registerIcao;
    /**
     * Registers a facility with this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to register.
     */
    private registerWaypointWithRenderer;
    /**
     * Deregisters an ICAO string from this layer.
     * @param icao The ICAO string to deregister.
     */
    private deregisterIcao;
    /**
     * Deregisters a facility from this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to deregister.
     */
    private deregisterWaypointWithRenderer;
    /** @inheritdoc */
    setVisible(val: boolean): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}
/**
 * A nearest facility search for MapAbstractNearestWaypointsLayer.
 */
declare class MapNearestWaypointsLayerSearch<S extends NearestSearchSession<string, string> = NearestSearchSession<string, string>> {
    private readonly session;
    private readonly refreshCallback;
    private readonly _lastCenter;
    private _lastRadius;
    private maxItemCount;
    private refreshDebounceTimer;
    private isRefreshScheduled;
    /**
     * The center of this search's last refresh.
     */
    get lastCenter(): GeoPointReadOnly;
    /**
     * The radius of this search's last refresh, in great-arc radians.
     */
    get lastRadius(): number;
    /**
     * Constructor.
     * @param session The session used by this search.
     * @param refreshCallback A callback which is called every time the search refreshes.
     */
    constructor(session: S, refreshCallback: (results: NearestSearchResults<string, string>) => void);
    /**
     * Schedules a refresh of this search.  If a refresh was previously scheduled but not yet executed, this new
     * scheduled refresh will replace the old one.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param maxItemCount The maximum number of results returned by the refresh.
     * @param delay The delay, in milliseconds, before the refresh is executed.
     */
    scheduleRefresh(center: LatLonInterface, radius: number, maxItemCount: number, delay: number): void;
    /**
     * Updates this search. Executes any pending refreshes if their delay timers have expired.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    update(elapsed: number): void;
    /**
     * Refreshes this search.
     * @returns a Promise which is fulfilled when the refresh completes.
     */
    private refresh;
}

/**
 * Component props for MapLineLayer.
 */
interface MapLineLayerProps extends MapLayerProps<any> {
    /**
     * A subscribable which provides the start point of the line, as a set of lat/lon coordinates or a 2D vector in
     * projected coordinates. If the start point is `null`, a line will not be drawn.
     */
    start: Subscribable<LatLonInterface | ReadonlyFloat64Array | null>;
    /**
     * A subscribable which provides the end point of the line, as a set of lat/lon coordinates or a 2D vector in
     * projected coordinates. If the end point is `null`, a line will not be drawn.
     */
    end: Subscribable<LatLonInterface | ReadonlyFloat64Array | null>;
    /** The width of the line stroke, in pixels. Defaults to 2 pixels. */
    strokeWidth?: number;
    /** The style of the line stroke. Defaults to `'white'`. */
    strokeStyle?: string | CanvasGradient | CanvasPattern;
    /** The dash array of the line stroke. Defaults to `[]`. */
    strokeDash?: readonly number[];
    /** The width of the line outline, in pixels. Defaults to 0 pixels. */
    outlineWidth?: number;
    /** The style of the line outline. Defaults to `'black'`. */
    outlineStyle?: string | CanvasGradient | CanvasPattern;
    /** The dash array of the line outline. Defaults to `[]`. */
    outlineDash?: readonly number[];
}
/**
 * A map layer that draws a line between two points. The line is drawn in projected coordinate space, so it will always
 * be straight on the projected map.
 */
declare class MapLineLayer extends MapSyncedCanvasLayer<MapLineLayerProps> {
    private static readonly DEFAULT_STROKE_WIDTH;
    private static readonly DEFAULT_STROKE_STYLE;
    private static readonly DEFAULT_STROKE_DASH;
    private static readonly DEFAULT_OUTLINE_WIDTH;
    private static readonly DEFAULT_OUTLINE_STYLE;
    private static readonly DEFAULT_OUTLINE_DASH;
    private readonly strokeWidth;
    private readonly strokeStyle;
    private readonly strokeDash;
    private readonly outlineWidth;
    private readonly outlineStyle;
    private readonly outlineDash;
    private vec;
    private isUpdateScheduled;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Schedules the layer for a draw update.
     */
    private scheduleUpdate;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Draws this layer's line.
     * @param x1 The x coordinate of the start of the line.
     * @param y1 The y coordinate of the start of the line.
     * @param x2 The x coordinate of the end of the line.
     * @param y2 The y coordinate of the end of the line.
     */
    private drawLine;
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context A canvas rendering context.
     * @param width The width of the stroke, in pixels.
     * @param style The style of the stroke.
     * @param dash The dash array of the stroke.
     */
    private stroke;
}

/**
 * Component props for MapGenericLayer.
 */
interface MapGenericLayerProps<M> extends MapLayerProps<M> {
    /** A function to be called when the layer's visibility changes. */
    onVisibilityChanged?: (layer: MapGenericLayer<M>, isVisible: boolean) => void;
    /** A function to be called when the layer is attached to a map. */
    onAttached?: (layer: MapGenericLayer<M>) => void;
    /** A function to be called when the layer is awakened. */
    onWake?: (layer: MapGenericLayer<M>) => void;
    /** A function to be called when the layer is put to sleep. */
    onSleep?: (layer: MapGenericLayer<M>) => void;
    /** A function to be called when the projection of the layer's parent map changes. */
    onMapProjectionChanged?: (layer: MapGenericLayer<M>, mapProjection: MapProjection, changeFlags: number) => void;
    /** A function to be called when the layer updates. */
    onUpdated?: (layer: MapGenericLayer<M>, time: number, elapsed: number) => void;
    /** A function to be called when the layer is detached from a map. */
    onDetached?: (layer: MapGenericLayer<M>) => void;
}
/**
 * A generic map layer which renders its children.
 */
declare class MapGenericLayer<M = any> extends MapLayer<MapGenericLayerProps<M>> {
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onWake(): void;
    /** @inheritdoc */
    onSleep(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    onDetached(): void;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * Component props for MapSystemComponent.
 */
interface MapSystemComponentProps<Modules> extends MapComponentProps<Modules> {
    /**
     * A subscribable which provides the size of the dead zone around each edge of the map projection window, which is
     * displayed but excluded in map range calculations. Expressed as [left, top, right, bottom] in pixels. Defaults to 0
     * on all sides.
     */
    deadZone?: Subscribable<Float64Array>;
    /** A function to be called after the map is rendered. */
    onAfterRender: () => void;
    /** A function to be called when the size of the map's dead zone changes. */
    onDeadZoneChanged: (deadZone: ReadonlyFloat64Array) => void;
    /** A function to be called when the map's projection changes. */
    onMapProjectionChanged: (mapProjection: MapProjection, changeFlags: number) => void;
    /** A function to be called immediately before the map's layers are updated. */
    onBeforeUpdated: (time: number, elapsed: number) => void;
    /** A function to be called immediately after the map's layers are updated. */
    onAfterUpdated: (time: number, elapsed: number) => void;
    /** A function to be called when the map is awakened. */
    onWake: () => void;
    /** A function to be called when the map is put to sleep. */
    onSleep: () => void;
    /** A function to be called when the map is destroyed. */
    onDestroy: () => void;
    /** CSS class(es) to apply to the root of the component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A component that encompasses the compiled map system.
 */
declare class MapSystemComponent<P extends MapSystemComponentProps<any> = MapSystemComponentProps<any>> extends MapComponent<P> {
    protected readonly rootStyles: ObjectSubject<{
        width: string;
        height: string;
    }>;
    protected readonly deadZone: Subscribable<ReadonlyFloat64Array>;
    /** @inheritdoc */
    constructor(props: P);
    /** @inheritdoc */
    onAfterRender(thisNode: VNode): void;
    /**
     * This method is called when the size of this map's dead zone changes.
     * @param deadZone The dead zone.
     */
    protected onDeadZoneChanged(deadZone: ReadonlyFloat64Array): void;
    /** @inheritdoc */
    protected onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    protected setRootSize(size: ReadonlyFloat64Array): void;
    /** @inheritdoc */
    protected onProjectedSizeChanged(): void;
    /** @inheritdoc */
    protected onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    protected onWake(): void;
    /** @inheritdoc */
    protected onSleep(): void;
    /** @inheritdoc */
    render(): VNode;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A map controller.
 */
declare abstract class MapSystemController<Modules extends ModuleRecord = any, Layers extends LayerRecord = any, Controllers extends ControllerRecord = any, Context extends ContextRecord = any> {
    private _isAlive;
    /** Whether this controller is alive. */
    get isAlive(): boolean;
    protected readonly context: MapSystemContext<Modules, Layers, Controllers, Context>;
    /**
     * Constructor.
     * @param context This controller's map context.
     */
    constructor(context: MapSystemContext<Modules, Layers, any, Context>);
    /**
     * This method is called after this controller' map is rendered.
     * @param ref A reference to the rendered map.
     */
    onAfterMapRender(ref: MapSystemComponent): void;
    /**
     * This method is called when the dead zone of this controller's map changes.
     * @param deadZone The map's new dead zone.
     */
    onDeadZoneChanged(deadZone: ReadonlyFloat64Array): void;
    /**
     * This method is called when the projection of this controller's map changes.
     * @param mapProjection The map projection.
     * @param changeFlags Bit flags describing the type of change.
     */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * This method is called immediately before this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onBeforeUpdated(time: number, elapsed: number): void;
    /**
     * This method is called immediately after this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onAfterUpdated(time: number, elapsed: number): void;
    /**
     * This method is called when this controller's map is awakened.
     */
    onWake(): void;
    /**
     * This method is called when this controller's map is put to sleep.
     */
    onSleep(): void;
    /**
     * This method is called when this controller's map is destroyed.
     */
    onMapDestroyed(): void;
    /**
     * Destroys this controller.
     */
    destroy(): void;
}

/**
 * A record of `string`-keyed map model modules.
 */
declare type ModuleRecord = Record<string, any>;
/**
 * A record of `string`-keyed map layers.
 */
declare type LayerRecord = Record<string, any>;
/**
 * A record of `string`-keyed map controllers.
 */
declare type ControllerRecord = Record<string, any>;
/**
 * A record of context properties.
 */
declare type ContextRecord = Record<string, any>;
/**
 * An empty record.
 */
declare type EmptyRecord = Record<never, never>;
/**
 * Adds all modules from a new module record to an existing record. Modules from the new record will overwrite the ones
 * in the existing record if there are key collisions.
 */
declare type ModuleUnion<Modules extends ModuleRecord, New extends ModuleRecord> = Omit<Modules, keyof New> & New;
/**
 * Adds all modules from a new layer record to an existing record. Layers from the new record will overwrite the ones
 * in the existing record if there are key collisions.
 */
declare type LayerUnion<Layers extends LayerRecord, New extends LayerRecord> = Omit<Layers, keyof New> & New;
/**
 * Adds all controllers from a new layer record to an existing record. Controllers from the new record will overwrite
 * the ones in the existing record if there are key collisions.
 */
declare type ControllerUnion<Controllers extends ControllerRecord, New extends ControllerRecord> = Omit<Controllers, keyof New> & New;
/**
 * Adds all properties from a new context record to an existing record. Properties with keys found in the base
 * {@link MapSystemContext} will be ignored. properties from the new record will overwrite the ones in the existing
 * record if there are key collisions.
 */
declare type ContextUnion<Context, New extends ContextRecord> = Omit<Context, keyof Omit<New, keyof MutableMapContext<MapSystemContext>>> & Omit<New, keyof MutableMapContext<MapSystemContext>>;
/**
 * Retrieves a map layer's required modules.
 */
declare type RequiredLayerModules<Layer> = Layer extends MapLayer<infer P> ? P extends MapLayerProps<infer M> ? M : never : never;
/**
 * Retrieves a map controller's required modules.
 */
declare type RequiredControllerModules<Controller> = Controller extends MapSystemController<infer M, any, any, any> ? M : never;
/**
 * Retrieves a map controller's required layers.
 */
declare type RequiredControllerLayers<Controller> = Controller extends MapSystemController<any, infer L, any, any> ? L : never;
/**
 * Retrieves a map controller's required context.
 */
declare type RequiredControllerContext<Controller> = Controller extends MapSystemController<any, any, any, infer Context> ? Context : never;
/**
 * A compiled map from {@link MapSystemBuilder}.
 */
declare type CompiledMapSystem<Modules extends ModuleRecord, Layers extends LayerRecord, Controllers extends ControllerRecord, Context extends ContextRecord> = {
    /** The compiled map context. */
    context: MapSystemContext<Modules, Layers, Controllers, Context>;
    /** The compiled map, rendered as a VNode. */
    map: VNode;
    /** A reference to the compiled map. */
    ref: NodeReference<MapSystemComponent<MapSystemComponentProps<Modules>>>;
};

/**
 * A context which holds data related to a compiled MapSystem map.
 */
declare type MapSystemContext<Modules extends ModuleRecord = EmptyRecord, Layers extends LayerRecord = EmptyRecord, Controllers extends ControllerRecord = EmptyRecord, Context extends ContextRecord = EmptyRecord> = {
    /** The event bus. */
    readonly bus: EventBus;
    /** This context's map model. */
    readonly model: MapModel<Modules>;
    /** This context's map projection. */
    readonly projection: MapProjection;
    /** A subscribable which provides the projected size of this context's map. */
    readonly projectedSize: Subscribable<ReadonlyFloat64Array>;
    /** A subscribable which provides the dead zone of this context's map. */
    readonly deadZone: Subscribable<ReadonlyFloat64Array>;
    /**
     * Retrieves a layer from this context.
     * @param key The key of the layer to retrieve.
     * @returns The layer in this context with the specified key.
     */
    getLayer<K extends keyof Layers & string>(key: K): Layers[K];
    /**
     * Retrieves a controller from this context.
     * @param key The key of the controller to retrieve.
     * @returns The controller in this context with the specified key.
     */
    getController<K extends keyof Controllers & string>(key: K): Controllers[K];
} & Readonly<Context>;
/**
 * A mutable version of {@link MapSystemContext} which allows adding layers and controllers.
 */
declare type MutableMapContext<T> = T extends MapSystemContext<any, infer Layers, infer Controllers, any> ? T & {
    /**
     * Adds a layer to this context.
     * @param key The key of the layer to add.
     * @param layer The layer to add.
     */
    setLayer<K extends keyof Layers & string>(key: K, layer: Layers[K]): void;
    /**
     * Adds a controller to this context.
     * @param key The key of the controller to add.
     * @param controller The controller to add.
     */
    setController<K extends keyof Controllers & string>(key: K, controller: Controllers[K]): void;
} : never;
/**
 * An implementation of the base properties in {@link MapSystemContext}.
 */
declare class DefaultMapSystemContext<Modules extends ModuleRecord = EmptyRecord, Layers extends LayerRecord = EmptyRecord, Controllers extends ControllerRecord = EmptyRecord> {
    readonly bus: EventBus;
    readonly projection: MapProjection;
    readonly projectedSize: Subscribable<ReadonlyFloat64Array>;
    readonly deadZone: Subscribable<ReadonlyFloat64Array>;
    /** This context's map model. */
    readonly model: MapModel<Modules>;
    private readonly layers;
    private readonly controllers;
    /**
     * Creates an instance of a MapSystemContext.
     * @param bus This context's event bus.
     * @param projection This context's map projection.
     * @param projectedSize A subscribable which provides the projected size of this context's map.
     * @param deadZone A subscribable which provides the dead zone of this context's map.
     */
    constructor(bus: EventBus, projection: MapProjection, projectedSize: Subscribable<ReadonlyFloat64Array>, deadZone: Subscribable<ReadonlyFloat64Array>);
    /**
     * Retrieves a layer from this context.
     * @param key The key of the layer to retrieve.
     * @returns The layer in this context with the specified key.
     */
    getLayer<K extends keyof Layers & string>(key: K): Layers[K] & MapLayer;
    /**
     * Retrieves a controller from this context.
     * @param key The key fo the controller to retrieve.
     * @returns The controller in this context with the specified key.
     */
    getController<K extends keyof Controllers & string>(key: K): Controllers[K];
    /**
     * Adds a layer to this context.
     * @param key The key of the layer to add.
     * @param layer The layer to add.
     */
    setLayer<K extends keyof Layers & string>(key: K, layer: Layers[K]): void;
    /**
     * Adds a controller to this context.
     * @param key The key of the controller to add.
     * @param controller The controller to add.
     */
    setController<K extends keyof Controllers & string>(key: K, controller: Controllers[K]): void;
}

/**
 * A binding from a source to a target.
 */
declare type MapSimpleBinding<T> = {
    /** The source of the binding. */
    source: Subscribable<T>;
    /** The target of the binding. */
    target: MutableSubscribable<any, T>;
};
/**
 * A binding from a transformed source to a target.
 */
declare type MapTransformedBinding<S, T> = {
    /** The source of the binding. */
    source: Subscribable<S>;
    /** The target of the binding. */
    target: MutableSubscribable<any, T>;
    /** A function which transforms source values before they are applied to the target. */
    map: (source: S) => T;
};
/**
 * A binding from multiple sources to a target.
 */
declare type MapMultiTransformedBinding<I extends readonly any[], T> = {
    /** The sources of the binding. */
    sources: MappedSubscribableInputs<I>;
    /** The target of the binding. */
    target: MutableSubscribable<any, T>;
    /** A function which transforms source values, as a tuple, before they are applied to the target. */
    map: (sources: Readonly<I>) => T;
};
/**
 * A binding which can be maintained by {@link MapBindingsController}.
 */
declare type MapBinding = MapSimpleBinding<any> | MapTransformedBinding<any, any> | MapMultiTransformedBinding<any, any>;
/**
 * A controller which maintains an arbitrary number of bindings.
 */
declare class MapBindingsController extends MapSystemController {
    private readonly bindings;
    private readonly onDestroy?;
    private readonly maps;
    private readonly pipes;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param bindings This controller's bindings.
     * @param onDestroy A function to execute when the controller is destroyed.
     */
    constructor(context: MapSystemContext<any, any, any, any>, bindings: Iterable<MapBinding>, onDestroy?: (() => void) | undefined);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    onWake(): void;
    /** @inheritdoc */
    onSleep(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Context values required for MapClockUpdateController.
 */
interface MapClockUpdateControllerContext {
    /** The map update frequency. */
    updateFreq: Subscribable<number>;
}
/**
 * Updates a map at regular intervals based on event bus clock events.
 */
declare class MapClockUpdateController extends MapSystemController<any, any, any, MapClockUpdateControllerContext> {
    private freqSub?;
    private clockSub?;
    /** @inheritdoc */
    onAfterMapRender(ref: MapSystemComponent): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A map data module that handles the display of flight plan data.
 */
declare class MapFlightPlanModule {
    private readonly plans;
    /**
     * Gets the flight plan subjects for a specified flight plan.
     * @param index The index of the flight plan.
     * @returns The subject for the specified plan index.
     */
    getPlanSubjects(index: number): PlanSubjects;
}
/**
 * A collection of subjects for consuming flight plan data in the flight plan module.
 */
declare class PlanSubjects {
    /** The current flight plan to display, if any. */
    flightPlan: Subject<FlightPlan | undefined>;
    /** An event that fires when the plan is changed. */
    planChanged: SubEvent<any, void>;
    /** An event that fired when the flight path of the plan is recalculated. */
    planCalculated: SubEvent<any, void>;
    /** The active leg index currently being navigated to. */
    activeLeg: Subject<number>;
}

/**
 * Modules required for MapFlightPlanController.
 */
interface MapFlightPlanControllerModules {
    /** Flight plan module. */
    [MapSystemKeys.FlightPlan]: MapFlightPlanModule;
}
/**
 * Context values required for MapFlightPlanController.
 */
interface MapFlightPlanControllerContext {
    /** The flight planner. */
    [MapSystemKeys.FlightPlanner]: FlightPlanner;
}
/**
 * Controls the map system's flight plan module.
 */
declare class MapFlightPlanController extends MapSystemController<MapFlightPlanControllerModules, any, any, MapFlightPlanControllerContext> {
    private readonly flightPlanModule;
    private planCopiedHandler;
    private planCreatedHandler;
    private planDeletedHandler;
    private planChangeHandler;
    private planCalculatedHandler;
    private activeLegChangedHandler;
    private fplCopiedSub?;
    private fplCreatedSub?;
    private fplDeletedSub?;
    private fplDirectToDataChangedSub?;
    private fplLoadedSub?;
    private fplOriginDestChangedSub?;
    private fplProcDetailsChangedSub?;
    private fplSegmentChangeSub?;
    private fplUserDataDeleteSub?;
    private fplUserDataSetSub?;
    private fplActiveLegChangeSub?;
    private fplCalculatedSub?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A heap which allocates instances of a resource.
 */
declare class ResourceHeap<T> {
    private readonly factory;
    private readonly destructor;
    private readonly onAllocated?;
    private readonly onFreed?;
    readonly maxSize: number;
    private readonly autoShrinkThreshold;
    private readonly cache;
    private numAllocated;
    /**
     * Constructor.
     * @param factory A function which creates new instances of this heap's resource.
     * @param destructor A function which destroys instances of this heap's resource.
     * @param onAllocated A function which is called when an instance of this heap's resource is allocated.
     * @param onFreed A function which is called when an instance of this heap's resource is freed.
     * @param initialSize The initial size of this heap. Defaults to `0`.
     * @param maxSize The maximum size of this heap. Defaults to `Number.MAX_SAFE_INTEGER`. This heap cannot allocate
     * more resources than its maximum size.
     * @param autoShrinkThreshold The size above which this heap will attempt to automatically reduce its size when
     * resources are freed. The heap will never reduce its size below this threshold. Defaults to
     * `Number.MAX_SAFE_INTEGER`.
     */
    constructor(factory: () => T, destructor: (resource: T) => void, onAllocated?: ((resource: T) => void) | undefined, onFreed?: ((resource: T) => void) | undefined, initialSize?: number, maxSize?: number, autoShrinkThreshold?: number);
    /**
     * Allocates a resource instance from this heap. If this heap has an existing free resource available, one will be
     * returned. Otherwise, a new resource instance will be created, added to the heap, and returned.
     * @returns A resource.
     * @throws Error if this heap has reached its allocation limit.
     */
    allocate(): T;
    /**
     * Frees a resource instance allocated from this heap, allowing it to be re-used.
     * @param resource The resource to free.
     */
    free(resource: T): void;
}

/**
 * A consumer of a resource.
 */
declare type ResourceConsumer<T = void> = {
    /**
     * This consumer's priority for its desired resource. Consumers with higher priority will gain access to the resource
     * over consumers with lower priority.
     */
    readonly priority: number;
    /**
     * A callback function which is called when this consumer gains access to its desired resource.
     */
    onAcquired: (resource: T) => void;
    /**
     * A callback function which is called when this consumer loses access to its desired resource.
     */
    onCeded: (resource: T) => void;
};
/**
 * Moderates access to a resource.
 */
declare class ResourceModerator<T = void> {
    private readonly resource;
    private pendingConsumer;
    private assignedConsumer;
    private readonly queuedConsumers;
    /**
     * Constructor.
     * @param resource This resource controlled by this moderator.
     */
    constructor(resource: T);
    /**
     * Makes a claim to this moderator's resource. If the resource is not currently owned, or the claiming consumer has
     * a higher priority than the current owner, access will attempt to pass to the claiming consumer. Otherwise, the
     * claiming consumer will enter a queue. After entering the queue, a consumer will gain access to the claimed
     * resource when all other consumers with a higher priority forfeit their claims to the resource.
     * @param consumer The consumer claiming the resource.
     */
    claim(consumer: ResourceConsumer<T>): void;
    /**
     * Forfeits a claim to this moderator's resource. If the consumer forfeiting its claim is the current owner of the
     * resource, it will immediately lose access to the resource, and access will attempt to pass to the next-highest
     * priority consumer with a claim to the resource. Otherwise, the forfeiting consumer will be removed from the queue
     * to gain access to the resource.
     * @param consumer The consumer that is forfeiting its claim.
     */
    forfeit(consumer: ResourceConsumer<T>): void;
}

/**
 * A module which describes whether the map is following the player airplane.
 */
declare class MapFollowAirplaneModule {
    /** Whether the map is following the player airplane. */
    readonly isFollowing: Subject<boolean>;
}

/**
 * Modules required for MapFollowAirplaneController.
 */
interface MapFollowAirplaneControllerModules {
    /** Own airplane properties module. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
    /** Follow airplane module. */
    [MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule;
}
/**
 * Context properties required for MapFollowAirplaneController.
 */
interface MapFollowAirplaneControllerContext {
    /** Resource moderator for control of the map's projection target. */
    [MapSystemKeys.TargetControl]: ResourceModerator;
}
/**
 * Controls the target position of a map to follow the player airplane.
 */
declare class MapFollowAirplaneController extends MapSystemController<MapFollowAirplaneControllerModules, any, any, MapFollowAirplaneControllerContext> {
    private readonly ownAirplanePropsModule;
    private readonly isFollowingAirplane;
    private readonly mapProjectionParams;
    private readonly targetControl;
    private readonly targetControlConsumer;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onBeforeUpdated(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * An enumeration of possible map rotation types.
 */
declare enum MapRotation {
    /** Map up position does not follow a defined pattern. */
    Undefined = "Undefined",
    /** Map up position points towards true north. */
    NorthUp = "NorthUp",
    /** Map up position points towards the current airplane track. */
    TrackUp = "TrackUp",
    /** Map up position points towards the current airplane heading. */
    HeadingUp = "HeadingUp",
    /** Map up position points towards the current nav desired track. */
    DtkUp = "DtkUp"
}
/**
 * A module describing the rotation behavior of the map.
 */
declare class MapRotationModule {
    /** The type of map rotation to use. */
    readonly rotationType: Subject<MapRotation>;
}

/**
 * Modules required for MapOwnAirplaneIconOrientationController.
 */
interface MapOwnAirplaneIconOrientationControllerModules {
    /** Own airplane icon module. */
    [MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule;
    /** Rotation module. */
    [MapSystemKeys.Rotation]: MapRotationModule;
}
/**
 * Controls the orientation of the own airplane icon set in {@link MapOwnAirplaneIconModule} based on a desired
 * orientation and the map rotation type. If the desired orientation matches the map rotation (e.g. both Heading Up),
 * the icon orientation is set to Map Up; otherwise the orientation is set to the desired orientation.
 */
declare class MapOwnAirplaneIconOrientationController extends MapSystemController<MapOwnAirplaneIconOrientationControllerModules> {
    private readonly ownAirplaneIconModule;
    private readonly desiredIconOrientation;
    private readonly orientationState;
    private needUpdateIconOrientation;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param desiredOrientation The desired orientation of the own airplane icon.
     */
    constructor(context: MapSystemContext<MapOwnAirplaneIconOrientationControllerModules>, desiredOrientation: MapOwnAirplaneIconOrientation | Subscribable<MapOwnAirplaneIconOrientation>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onBeforeUpdated(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapOwnAirplanePropsController.
 */
interface MapOwnAirplanePropsControllerModules {
    /** Own airplane properties. */
    [MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule;
}
/**
 * A key for a property in {@link MapOwnAirplanePropsModule}.
 */
declare type MapOwnAirplanePropsKey = Extract<keyof MapOwnAirplanePropsModule, string>;
/**
 * Updates the properties in a {@link MapOwnAirplanePropsModule}.
 */
declare class MapOwnAirplanePropsController extends MapSystemController<MapOwnAirplanePropsControllerModules> {
    private readonly properties;
    private readonly updateFreq;
    private readonly module;
    private readonly subs;
    private updateFreqSub?;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz.
     */
    constructor(context: MapSystemContext<MapOwnAirplanePropsControllerModules>, properties: Iterable<MapOwnAirplanePropsKey>, updateFreq: Subscribable<number>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    private bindProperty;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Modules required for MapRotationController.
 */
interface MapRotationControllerModules {
    /** Rotation module. */
    [MapSystemKeys.Rotation]: MapRotationModule;
    /** Own airplane properties module. */
    [MapSystemKeys.OwnAirplaneProps]?: MapOwnAirplanePropsModule;
}
/**
 * Required context properties for MapRotationController.
 */
interface MapRotationControllerContext {
    /** Resource moderator for control of the map's rotation. */
    [MapSystemKeys.RotationControl]: ResourceModerator;
}
/**
 * Controls the rotation of a map based on the behavior defined in {@link MapRotationModule}.
 */
declare class MapRotationController extends MapSystemController<MapRotationControllerModules, any, any, MapRotationControllerContext> {
    private readonly rotationModule;
    private readonly ownAirplanePropsModule;
    private readonly rotationParam;
    private hasRotationControl;
    private readonly rotationControl;
    private readonly rotationControlConsumer;
    private readonly rotationFuncs;
    private rotationFunc?;
    private rotationSub?;
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onBeforeUpdated(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * A handler that takes some vector data and returns the appropriate flight path rendering style.
 */
declare type VectorStyleHandler = (vector: CircleVector, isIngress: boolean, isEgress: boolean) => FlightPathRenderStyle;
/**
 * A handler that takes some leg data and returns the appropriate flight path rendering style.
 */
declare type LegStyleHandler = (plan: FlightPlan, leg: LegDefinition, activeLeg: LegDefinition | undefined, legIndex: number, activeLegIndex: number) => FlightPathRenderStyle | FlightPathVectorStyle;
/**
 * A handler that takes some leg data and returns the waypoint rendering role that the
 * waypoint should be rendered under.
 */
declare type LegWaypointHandler = (plan: FlightPlan, leg: LegDefinition, activeLeg: LegDefinition | null, legIndex: number, activeLegIndex: number) => number;
/**
 * A map flight plan renderer that can be supplied styling from the outside.
 */
declare class MapSystemPlanRenderer extends AbstractFlightPathPlanRenderer {
    defaultRoleId: number;
    /**
     * Creates an instance of the MapSystemPlanRenderer.
     * @param defaultRoleId The default role ID to render the plan waypoints under.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in a first-to-last
     * fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(defaultRoleId: number, renderOrder?: FlightPathPlanRenderOrder, renderActiveLegLast?: boolean);
    protected readonly legRenderer: MapSystemLegRenderer;
    /**
     * A handler that returns a leg rendering style for a given set of leg data.
     * @returns A leg rendering style.
     */
    readonly legStyleHandlers: Map<number, LegStyleHandler>;
    /**
     * A handler that returns whether or not a leg waypoint should be displayed.
     * @returns Whether or not the leg should be displayed.
     */
    readonly legWaypointHandlers: Map<number, LegWaypointHandler>;
    /** Whether or not to render flight path ingress turns. */
    renderIngress: Subscribable<boolean>;
    /** Whether or not to render flight path egress turns. */
    renderEgress: Subscribable<boolean>;
    /** @inheritdoc */
    protected renderLeg(leg: LegDefinition, plan: FlightPlan, activeLeg: LegDefinition | undefined, legIndex: number, activeLegIndex: number, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack): void;
}
/**
 * A map system flight plan leg renderer that uses a swappable style.
 */
declare class MapSystemLegRenderer extends AbstractFlightPathLegRenderer {
    protected readonly vectorRenderer: FlightPathVectorLineRenderer;
    currentRenderStyle: FlightPathRenderStyle | FlightPathVectorStyle;
    /** @inheritdoc */
    protected renderVector(vector: CircleVector, isIngress: boolean, isEgress: boolean, leg: LegDefinition, context: CanvasRenderingContext2D, streamStack: GeoProjectionPathStreamStack): void;
}
/**
 * A vector line rendering style to apply to a flight path display on the map.
 */
declare class FlightPathRenderStyle {
    isDisplayed: boolean;
    /**
     * Creates an instance of a FlightPathRenderStyle.
     * @param isDisplayed Whether or not the path is displayed.
     */
    constructor(isDisplayed?: boolean);
    /** The pixel width of the path line. */
    width: number;
    /** The style string for the line. */
    style: string;
    /** A dash-array configuration for the line, if any. */
    dash?: number[];
    /** The width of the outline, in pixels. Defaults to 0 pixels. */
    outlineWidth?: number;
    /** The style of the outline. Defaults to `'black'`. */
    outlineStyle?: string;
    /** An optional override of which parts to render for the leg. */
    partsToRender?: FlightPathLegRenderPart;
    /** The default rendering style. */
    static readonly Default: FlightPathRenderStyle;
    /** A style that does not display the path. */
    static readonly Hidden: FlightPathRenderStyle;
}
/**
 * A configuration for generating flight path rendering styles for individual vectors.
 */
interface FlightPathVectorStyle {
    /** An optional override of which parts to render for the leg. */
    partsToRender?: FlightPathLegRenderPart;
    /** A builder function that provides the style for an individual vector. */
    styleBuilder: VectorStyleHandler;
}

/**
 * A waypoint renderer for the MapSystem API. Supports addition of string-keyed render roles. Each render role is
 * assigned a position in an ordered list that determines the priority of being chosen when roles are selected for
 * rendering waypoints. For each waypoint, the renderer iterates through all render roles in the priority order list
 * and selects the first role under which the waypoint is registered and is visible.
 */
declare class MapSystemWaypointsRenderer extends MapWaypointRenderer<Waypoint> {
    /** The default render role group. */
    static readonly DefaultGroup = "DEFAULT_GROUP";
    protected readonly rolePriorityOrder: number[];
    protected readonly rolesByGroup: Map<string, string[]>;
    protected readonly roleIdMap: Map<string, number>;
    protected currentBit: number;
    /** An event that fires when any roles are added. */
    readonly onRolesAdded: SubEvent<this, void>;
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     */
    constructor(textManager: MapCullableTextLabelManager);
    /**
     * This method is disabled. Please use the `addRenderRole(name: string, def: MapWaypointRenderRoleDef<Waypoint>, group?: string)`
     * overload to add render roles to this renderer.
     * @param role The render role to add.
     * @param def The render role's definition.
     * @returns `false`.
     */
    addRenderRole(role: number, def?: MapWaypointRenderRoleDef<Waypoint>): false;
    /**
     * Adds a new named render role to this renderer. The new render role will be placed at the end of this renderer's
     * render role selection priority order. Roles positioned earlier in the order have a higher priority for being
     * chosen when roles are selected for rendering waypoints.
     * @param name The name of the render role to add.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @param group The group in which to include the new render role, if any. Defaults to
     * {@link MapSystemWaypointsRenderer.DefaultGroup}.
     * @returns Whether the role was successfully added.
     */
    addRenderRole(name: string, def?: MapWaypointRenderRoleDef<Waypoint>, group?: string): boolean;
    /**
     * Adds a new named render role to this renderer and inserts it before an existing render role in this renderer's
     * render role selection priority order. Roles positioned earlier in the order have a higher priority for being
     * chosen when roles are selected for rendering waypoints.
     * @param name The name of the render role to add.
     * @param insertBefore The name of the role before which to insert the new role in this renderer's render role
     * selection priority order. If the name does not match any of this renderer's existing render roles, the new role
     * will be placed at the end of the priority order.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @param group The group in which to include the new render role, if any. Defaults to
     * {@link MapSystemWaypointsRenderer.DefaultGroup}.
     * @returns Whether the role was successfully inserted.
     */
    insertRenderRole(name: string, insertBefore: string, def?: MapWaypointRenderRoleDef<Waypoint>, group?: string): boolean;
    /**
     * Gets a render role associated with a name.
     * @param name The name of the role.
     * @returns The render role associated with the specified name, or undefined if there is no such role.
     */
    getRoleFromName(name: string): number | undefined;
    /**
     * Gets the names of roles in a specified group.
     * @param group A render role group.
     * @returns An array of the names of all render roles belonging to the specified group.
     */
    getRoleNamesByGroup(group: string): readonly string[];
}
/**
 * A class that creates icons for the map system waypoint renderer.
 */
declare class MapSystemIconFactory implements MapWaypointRendererIconFactory<Waypoint> {
    private readonly cache;
    private readonly iconFactories;
    private readonly defaultIconFactories;
    /**
     * Adds an icon factory to the container.
     * @param role The role that this icon factory will be assigned to.
     * @param iconType The unique string type name of the icon.
     * @param factory The factory that will produce the icon.
     */
    addIconFactory<T extends Waypoint>(role: number, iconType: string, factory: (waypoint: T) => MapWaypointIcon<T>): void;
    /**
     * Adds a default icon factory for a role.
     * @param role The role to add a default icon factory for.
     * @param factory The factory that will produce the icons.
     */
    addDefaultIconFactory<T extends Waypoint>(role: number, factory: (waypoint: T) => MapWaypointIcon<T>): void;
    /** @inheritdoc */
    getIcon<T extends Waypoint>(role: number, waypoint: T): MapWaypointIcon<T>;
    /**
     * Creates a new icon for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    private createIcon;
}
/**
 * A class that create labels for the map system waypoint renderer.
 */
declare class MapSystemLabelFactory implements MapWaypointRendererLabelFactory<Waypoint> {
    private readonly cache;
    private readonly labelFactories;
    private readonly defaultLabelFactories;
    /**
     * Adds an label factory to the container.
     * @param role The role to add this label factory for.
     * @param iconType The unique string type name of the waypoint.
     * @param factory The factory that will produce the waypoint label.
     */
    addLabelFactory<T extends Waypoint>(role: number, iconType: string, factory: (waypoint: T) => MapCullableLocationTextLabel): void;
    /**
     * Adds a default label factory for a role.
     * @param role The role to add a default label factory for.
     * @param factory The factory that will produce the labels.
     */
    addDefaultLabelFactory<T extends Waypoint>(role: number, factory: (waypoint: T) => MapCullableLocationTextLabel): void;
    /** @inheritdoc */
    getLabel<T extends Waypoint>(role: number, waypoint: T): MapCullableTextLabel;
    /**
     * Creates a new label for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint to create a label for.
     * @returns A new waypoint label.
     */
    createLabel(role: number, waypoint: Waypoint): MapCullableLocationTextLabel;
}

/**
 * Modules required by MapSystemFlightPlanLayer.
 */
interface MapSystemFlightPlanLayerModules {
    /** Flight plan module. */
    [MapSystemKeys.FlightPlan]: MapFlightPlanModule;
}
/** Props on the MapSystemFlightPlanLayer component. */
interface MapSystemFlightPlanLayerProps extends MapLayerProps<MapSystemFlightPlanLayerModules> {
    /** An instance of the event bus. */
    bus: EventBus;
    /** The waypoint renderer to use with this instance. */
    waypointRenderer: MapSystemWaypointsRenderer;
    /** The icon factory to use with this instance. */
    iconFactory: MapSystemIconFactory;
    /** The label factory to use with this instance. */
    labelFactory: MapSystemLabelFactory;
    /** The flight plan renderer to use with this instance. */
    flightPathRenderer: MapSystemPlanRenderer;
    /** The flight plan index to display. */
    planIndex: number;
}
/**
 * A map system layer that draws the flight plan.
 */
declare class MapSystemFlightPlanLayer extends MapLayer<MapSystemFlightPlanLayerProps> {
    private static readonly WAYPOINT_PREFIX;
    private static readonly CLIP_BOUNDS_BUFFER;
    private static instanceId;
    protected readonly instanceId: number;
    protected readonly flightPathLayerRef: NodeReference<MapCachedCanvasLayer<MapCachedCanvasLayerProps<any>>>;
    protected readonly waypointLayerRef: NodeReference<MapSyncedCanvasLayer<MapCanvasLayerProps<any>>>;
    protected readonly defaultRoleId: number;
    protected readonly planModule: MapFlightPlanModule;
    protected readonly waypointPrefix: string;
    protected readonly legWaypoints: Map<LegDefinition, [Waypoint, number]>;
    protected waypointsUpdating: boolean;
    protected waypointId: number;
    protected readonly facLoader: FacilityLoader;
    protected readonly facWaypointCache: FacilityWaypointCache;
    protected readonly clipBounds: VecNSubject;
    protected readonly clippedPathStream: ClippedPathStream;
    protected readonly pathStreamStack: GeoProjectionPathStreamStack;
    protected updateScheduled: boolean;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes the waypoint renderer for this layer.
     */
    protected initWaypointRenderer(): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    setVisible(val: boolean): void;
    /**
     * Updates waypoints for the flight plan.
     * @throws An error if the waypoints are already updating.
     */
    protected updateWaypoints(): Promise<void>;
    /**
     * Builds or refreshes a flight plan waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    protected buildPlanWaypoint(leg: LegDefinition, roleId: number): Promise<void>;
    /**
     * Builds a flight path terminator based waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    protected buildTerminatorWaypoint(leg: LegDefinition, roleId: number): Promise<void>;
    /**
     * Builds a standard facility fix waypoint for flight plan waypoint display.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    protected buildFixWaypoint(leg: LegDefinition, roleId: number): Promise<void>;
    /** @inheritdoc */
    render(): VNode;
}

/**
 * ADS-B operating modes.
 */
declare enum AdsbOperatingMode {
    Standby = "Standby",
    Surface = "Surface",
    Airborne = "Airborne"
}
/**
 * ADS-B events.
 */
interface AdsbEvents {
    /** The ADS-B operating mode. */
    adsb_operating_mode: AdsbOperatingMode;
}
/**
 * An ADS-B system.
 */
declare class Adsb {
    protected readonly bus: EventBus;
    protected readonly operatingMode: Subject<AdsbOperatingMode>;
    protected readonly eventSubscriber: EventSubscriber<AdsbEvents>;
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode(): AdsbOperatingMode;
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode: AdsbOperatingMode): void;
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber(): EventSubscriber<AdsbEvents>;
    /**
     * Initializes this ADS-B system.
     */
    init(): void;
}

/**
 * TCAS operating modes.
 */
declare enum TcasOperatingMode {
    Off = "Off",
    Standby = "Standby",
    TAOnly = "TAOnly",
    TA_RA = "TA/RA",
    Test = "Test",
    Failed = "Failed"
}
/**
 * TCAS alert level.
 */
declare enum TcasAlertLevel {
    None = 0,
    ProximityAdvisory = 1,
    TrafficAdvisory = 2,
    ResolutionAdvisory = 3
}
/**
 * A time-of-closest-approach prediction made by TCAS.
 */
interface TcasTcaPrediction {
    /** Whether this prediction is valid. */
    readonly isValid: boolean;
    /** The time at which this prediction was most recently updated, as a UNIX timestamp in milliseconds. */
    readonly time: number;
    /** The predicted time to closest horizontal approach. */
    readonly tcpa: NumberUnitReadOnly<UnitFamily.Duration>;
    /** The predicted time to co-altitude. */
    readonly tcoa: NumberUnitReadOnly<UnitFamily.Duration>;
    /** Whether this prediction's intruder violates the protected volume and should be considered a threat. */
    readonly isThreat: boolean;
    /**
     * The predicted 3D displacement vector from own airplane to this prediction's intruder at time of closest horizontal
     * approach. Each component is expressed in units of meters.
     */
    readonly cpaDisplacement: ReadonlyFloat64Array;
    /**
     * The predicted horizontal separation between this prediction's intruder and own airplane at time of closest
     * horizontal approach.
     */
    readonly cpaHorizontalSep: NumberUnitReadOnly<UnitFamily.Distance>;
    /**
     * The predicted vertical separation between this prediction's intruder and own airplane at time of closest
     * horizontal approach.
     */
    readonly cpaVerticalSep: NumberUnitReadOnly<UnitFamily.Distance>;
    /**
     * The cylindrical norm of the predicted displacement vector between this prediction's intruder and own airplane at
     * time of closest horizontal approach. A value less than or equal to 1 indicates the intruder will be inside the
     * protected zone. Larger values correspond to greater separation.
     */
    readonly cpaNorm: number;
}
/**
 * An intruder tracked by TCAS.
 */
interface TcasIntruder {
    /** The traffic contact associated with this intruder. */
    readonly contact: TrafficContact;
    /** A subscribable which provides the alert level assigned to this intruder. */
    readonly alertLevel: Subscribable<TcasAlertLevel>;
    /** The position of this intruder at the time of the most recent update. */
    readonly position: GeoPointReadOnly;
    /** The altitude of this intruder at the time of the most recent update. */
    readonly altitude: NumberUnitReadOnly<UnitFamily.Distance>;
    /** The true ground track of this intruder at the time of the most recent update. */
    readonly groundTrack: number;
    /** The ground speed of this intruder at the time of the most recent update. */
    readonly groundSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The vertical speed of this intruder at the time of the most recent update. */
    readonly verticalSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /**
     * The 3D position vector of this intruder at the time of the last update. Each component is expressed in units of
     * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
     * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
     * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
     * airplane.
     */
    readonly positionVec: ReadonlyFloat64Array;
    /**
     * The 3D velocity vector of this intruder at the time of the last update. Each component is expressed in units of
     * meters per second. The coordinate system is defined the same as for position vectors.
     */
    readonly velocityVec: ReadonlyFloat64Array;
    /** The 3D position vector of this intruder relative to own airplane. */
    readonly relativePositionVec: ReadonlyFloat64Array;
    /** The 3D velocity vector of this intruder relative to own airplane. */
    readonly relativeVelocityVec: ReadonlyFloat64Array;
    /** Whether there is a valid prediction for this intruder's position and velocity. */
    readonly isPredictionValid: boolean;
    /** A time-of-closest-approach prediction for this intruder using sensitivity settings for traffic advisories. */
    readonly tcaTA: TcasTcaPrediction;
    /** A time-of-closest-approach prediction for this intruder using sensitivity settings for resolution advisories. */
    readonly tcaRA: TcasTcaPrediction;
    /**
     * Calculates the predicted 3D displacement vector from own airplane to this intruder at a specified time based on
     * the most recent available data. If insufficient data is available to calculate the prediction, NaN will be written
     * to the result.
     * @param simTime The sim time at which to calculate the separation, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted displacement vector from own airplane to this intruder at the specified time.
     */
    predictDisplacement(simTime: number, out: Float64Array): Float64Array;
    /**
     * Calculates the predicted separation between this intruder and own airplane at a specified time based on the most
     * recent available data and stores the results in the supplied WT_NumberUnit objects. If insufficient data is
     * available to calculate the prediction, NaN will be written to the results.
     * @param simTime The sim time at which to calculate the separation, as a UNIX timestamp in milliseconds.
     * @param horizontalOut A NumberUnit object to which to write the horizontal separation.
     * @param verticalOut A NumberUnit object to which to write the vertical separation.
     */
    predictSeparation(simTime: number, horizontalOut: NumberUnit<UnitFamily.Distance>, verticalOut: NumberUnit<UnitFamily.Distance>): void;
}
/**
 * TCAS parameters for advisories defining the protected zone around the own airplane.
 */
interface TcasAdvisoryParameters {
    /** The radius of the own airplane's protected volume. */
    readonly protectedRadius: NumberUnitInterface<UnitFamily.Distance>;
    /** The half-height of the own airplane's protected volume. */
    readonly protectedHeight: NumberUnitInterface<UnitFamily.Distance>;
}
/**
 * TCAS parameters for time-of-closest-approach calculations.
 */
interface TcasTcaParameters extends TcasAdvisoryParameters {
    /** The maximum lookahead time to closest horizontal approach or co-altitude. */
    readonly tau: NumberUnitInterface<UnitFamily.Duration>;
    /** The horizontal miss distance filter threshold. If not defined, an HMD filter will not be applied. */
    readonly hmd?: NumberUnitInterface<UnitFamily.Distance>;
}
/**
 * A full set of TCAS sensitivity parameters.
 */
declare type TcasSensitivityParameters = {
    /**
     * Protected zone parameters for proximity advisories. If any parameters have a value of `NaN`, proximity advisories
     * will not be issued.
     */
    readonly parametersPA: TcasAdvisoryParameters;
    /**
     * Parameters for time-of-closest-approach calculations for traffic advisories. If any parameters have a value of
     * `NaN`, traffic advisories will not be issued.
     */
    readonly parametersTA: TcasTcaParameters;
    /**
     * Parameters for time-of-closest-approach calculations for resolution advisories. If any parameters have a value of
     * `NaN`, resolution advisories will not be issued.
     */
    readonly parametersRA: TcasTcaParameters;
};
/**
 * Sensitivity settings for TCAS.
 */
interface TcasSensitivity<I extends TcasIntruder = TcasIntruder> {
    /**
     * Selects sensitivity parameters for an intruder.
     * @param intruder An intruder.
     * @returns Sensitivity parameters for the specified intruder.
     */
    selectParameters(intruder: I): TcasSensitivityParameters;
    /**
     * Selects an ALIM for a resolution advisory.
     * @param intruders The intruders involved in the resolution advisory.
     * @returns An ALIM for a resolution advisory involving the specified intruders.
     */
    selectRAAlim(intruders: ReadonlySet<I>): NumberUnitInterface<UnitFamily.Distance>;
}
/**
 * Bit flags describing TCAS resolution advisories.
 */
declare enum TcasResolutionAdvisoryFlags {
    /** A corrective resolution advisory. Requires a change in the own airplane's vertical speed. */
    Corrective = 1,
    /** An upward sense resolution advisory. Commands a vertical speed above a certain value. */
    UpSense = 2,
    /** A downward sense resolution advisory. Commands a vertical speed below a certain value. */
    DownSense = 4,
    /** A resolution advisory which crosses an intruder's altitude. */
    Crossing = 8,
    /** A CLIMB resolution advisory. Commands a positive vertical speed above 1500 FPM. */
    Climb = 16,
    /** A DESCEND resolution advisory. Commands a negative vertical speed below -1500 FPM. */
    Descend = 32,
    /** An INCREASE CLIMB or INCREASE DESCENT resolution advisory. Commands a vertical speed above 2500 FPM or below -2500 FPM. */
    Increase = 64,
    /** A CLIMB or DESCEND resolution advisory that reverses sense. Commands a vertical speed above 1500 FPM or below -1500 FPM. */
    Reversal = 128,
    /** A corrective REDUCE CLIMB resolution advisory. Commands a vertical speed of 0 FPM or less. */
    ReduceClimb = 256,
    /** A corrective REDUCE DESCENT resolution advisory. Commands a vertical speed of 0 FPM or more. */
    ReduceDescent = 512,
    /** A preventative DO NOT CLIMB resolution advisory. Commands a non-positive vertical speed. */
    DoNotClimb = 1024,
    /** A preventative DO NOT DESCEND resolution advisory. Commands a non-negative vertical speed. */
    DoNotDescend = 2048
}
/**
 * Types of TCAS resolution advisories.
 */
declare enum TcasResolutionAdvisoryType {
    /** Upward sense, positive, corrective, required vertical speed 1500 to 2000 fpm. */
    Climb = "Climb",
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    CrossingClimb = "CrossingClimb",
    /** Upward sense, positive, corrective, required vertical speed 1500 to 4400 fpm. */
    MaintainClimb = "MaintainClimb",
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    CrossingMaintainClimb = "CrossingMaintainClimb",
    /** Upward sense, positive, corrective, required vertical speed 2500 to 3000 fpm. */
    IncreaseClimb = "IncreaseClimb",
    /** Upward sense, positive, corrective, transition from downward sense, required vertical speed 1500 to 2000 fpm. */
    ReversalClimb = "ReversalClimb",
    /** Upward sense, negative, corrective, required vertical speed >= 0 fpm. */
    ReduceDescent = "ReduceDescent",
    /** Upward sense, negative, preventative, required vertical speed >= 0 fpm. */
    DoNotDescend0 = "DoNotDescend0",
    /** Upward sense, negative, preventative, required vertical speed >= -500 fpm. */
    DoNotDescend500 = "DoNotDescend500",
    /** Upward sense, negative, preventative, required vertical speed >= -1000 fpm. */
    DoNotDescend1000 = "DoNotDescend1000",
    /** Upward sense, negative, preventative, required vertical speed >= -1500 fpm. */
    DoNotDescend1500 = "DoNotDescend1500",
    /** Upward sense, negative, preventative, required vertical speed >= -2000 fpm. */
    DoNotDescend2000 = "DoNotDescend2000",
    /** Downward sense, positive, corrective, required vertical speed -1500 to -2000 fpm. */
    Descend = "Descend",
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -2000 fpm. */
    CrossingDescend = "CrossingDescend",
    /** Downward sense, positive, corrective, required vertical speed -1500 to -4400 fpm. */
    MaintainDescend = "MaintainDescend",
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -4400 fpm. */
    CrossingMaintainDescend = "CrossingMaintainDescend",
    /** Downward sense, positive, corrective, required vertical speed -2500 to -3000 fpm. */
    IncreaseDescend = "IncreaseDescend",
    /** Downward sense, positive, corrective, transition from upward sense, required vertical speed -1500 to -2000 fpm. */
    ReversalDescend = "ReversalDescend",
    /** Downward sense, negative, corrective, required vertical speed <= 0 fpm. */
    ReduceClimb = "ReduceClimb",
    /** Downward sense, negative, preventative, required vertical speed <= 0 fpm. */
    DoNotClimb0 = "DoNotClimb0",
    /** Downward sense, negative, preventative, required vertical speed <= 500 fpm. */
    DoNotClimb500 = "DoNotClimb500",
    /** Downward sense, negative, preventative, required vertical speed <= 1000 fpm. */
    DoNotClimb1000 = "DoNotClimb1000",
    /** Downward sense, negative, preventative, required vertical speed <= 1500 fpm. */
    DoNotClimb1500 = "DoNotClimb1500",
    /** Downward sense, negative, preventative, required vertical speed <= 2000 fpm. */
    DoNotClimb2000 = "DoNotClimb2000",
    /** Clear of conflict. */
    Clear = "Clear"
}
/**
 * A host for information on the active TCAS resolution advisory.
 */
interface TcasResolutionAdvisoryHost {
    /** The resolution advisory's active intruders, sorted in order of increasing time to closest approach. */
    readonly intruderArray: readonly TcasIntruder[];
    /** The upper vertical speed limit set by the resolution advisory. A value of `NaN` indicates no limit. */
    readonly maxVerticalSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The lower vertical speed limit set by the resolution advisory. A value of `NaN` indicates no limit. */
    readonly minVerticalSpeed: NumberUnitReadOnly<UnitFamily.Speed>;
    /** The resolution advisory's primary type. */
    readonly primaryType: TcasResolutionAdvisoryType;
    /**
     * The resolution advisory's secondary type, if any. A secondary type can only exist if there are multiple
     * intruders. If a secondary type exists, it can only be a negative type.
     */
    readonly secondaryType: TcasResolutionAdvisoryType | null;
    /** A combination of {@link TcasResolutionAdvisoryFlags} entries describing the resolution advisory's primary type. */
    readonly primaryFlags: number;
    /**
     * A combination of {@link TcasResolutionAdvisoryFlags} entries describing the resolution advisory's secondary type.
     * If this resolution advisory does not have a secondary type, this value will be equal to zero.
     */
    readonly secondaryFlags: number;
}
/**
 * TCAS events.
 */
interface TcasEvents {
    /** The TCAS operating mode changed. */
    tcas_operating_mode: TcasOperatingMode;
    /** A new intruder was created. */
    tcas_intruder_added: TcasIntruder;
    /** The alert level of an intruder was changed. */
    tcas_intruder_alert_changed: TcasIntruder;
    /** An intruder was removed. */
    tcas_intruder_removed: TcasIntruder;
    /** The number of intruders associated with active traffic advisories. */
    tcas_ta_intruder_count: number;
    /** The number of intruders associated with an active resolution advisory. */
    tcas_ra_intruder_count: number;
    /** An initial resolution advisory has been issued. */
    tcas_ra_issued: TcasResolutionAdvisoryHost;
    /** An active resolution advisory has been updated. */
    tcas_ra_updated: TcasResolutionAdvisoryHost;
    /** A resolution advisory has been canceled. */
    tcas_ra_canceled: void;
}
/**
 * Options to adjust how resolution advisories are calculated by TCAS.
 */
declare type TcasResolutionAdvisoryOptions = {
    /** The assumed response time of the own airplane following an initial resolution advisory. */
    readonly initialResponseTime: NumberUnitInterface<UnitFamily.Duration>;
    /** The assumed acceleration of the own airplane following an initial resolution advisory. */
    readonly initialAcceleration: NumberUnitInterface<UnitFamily.Acceleration>;
    /** The assumed response time of the own airplane following an updated resolution advisory. */
    readonly subsequentResponseTime: NumberUnitInterface<UnitFamily.Duration>;
    /** The assumed acceleration of the own airplane following an updated resolution advisory. */
    readonly subsequentAcceleration: NumberUnitInterface<UnitFamily.Acceleration>;
    /** A function which determines whether to allow a CLIMB resolution advisory. */
    allowClimb: (simTime: number) => boolean;
    /** A function which determines whether to allow an INCREASE CLIMB resolution advisory. */
    allowIncreaseClimb: (simTime: number) => boolean;
    /** A function which determines whether to allow a DESCEND resolution advisory. */
    allowDescend: (simTime: number) => boolean;
    /** A function which determines whether to allow an INCREASE DESCENT resolution advisory. */
    allowIncreaseDescent: (simTime: number) => boolean;
};
/**
 * A TCAS-II-like system.
 */
declare abstract class Tcas<I extends AbstractTcasIntruder = AbstractTcasIntruder, S extends TcasSensitivity = TcasSensitivity> {
    protected readonly bus: EventBus;
    protected readonly tfcInstrument: TrafficInstrument;
    protected readonly maxIntruderCount: number;
    protected readonly realTimeUpdateFreq: number;
    protected readonly simTimeUpdateFreq: number;
    private static readonly DEFAULT_RA_OPTIONS;
    protected readonly operatingModeSub: Subject<TcasOperatingMode>;
    protected readonly sensitivity: S;
    protected readonly ownAirplane: OwnAirplane;
    protected readonly intrudersSorted: I[];
    protected intrudersFiltered: I[];
    protected readonly intrudersRA: Set<I>;
    protected readonly resolutionAdvisoryHost: TcasResolutionAdvisoryHostClass;
    private contactCreatedConsumer;
    private contactRemovedConsumer;
    private readonly contactCreatedHandler;
    private readonly contactRemovedHandler;
    protected readonly ownAirplaneSubs: {
        position: GeoPointSubject;
        altitude: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
        groundTrack: ConsumerSubject<number>;
        groundSpeed: NumberUnitSubject<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
        verticalSpeed: NumberUnitSubject<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
        radarAltitude: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
        isOnGround: ConsumerSubject<boolean>;
    };
    protected readonly simTime: ConsumerSubject<number>;
    protected lastUpdateSimTime: number;
    protected lastUpdateRealTime: number;
    private readonly alertLevelSubs;
    private readonly eventPublisher;
    private readonly eventSubscriber;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     * @param raOptions Options to adjust how resolution advisories are calculated.
     */
    constructor(bus: EventBus, tfcInstrument: TrafficInstrument, maxIntruderCount: number, realTimeUpdateFreq: number, simTimeUpdateFreq: number, raOptions?: Partial<TcasResolutionAdvisoryOptions>);
    /**
     * Creates a TCAS sensitivity object.
     * @returns A TCAS sensitivity object.
     */
    protected abstract createSensitivity(): S;
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode(): TcasOperatingMode;
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode: TcasOperatingMode): void;
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders(): readonly TcasIntruder[];
    /**
     * Gets this system's resolution advisory host.
     * @returns This system's resolution advisory host.
     */
    getResolutionAdvisoryHost(): TcasResolutionAdvisoryHost;
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber(): EventSubscriber<TcasEvents>;
    /**
     * Initializes this system.
     */
    init(): void;
    /**
     * Responds to changes in this TCAS's operating mode.
     * @param mode The current operating mode.
     */
    protected onOperatingModeChanged(mode: TcasOperatingMode): void;
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    protected intruderComparator(a: I, b: I): number;
    /**
     * Creates a TCAS intruder entry from a traffic contact.
     * @param contact A traffic contact.
     */
    protected abstract createIntruderEntry(contact: TrafficContact): I;
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    private onContactAdded;
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    private onContactRemoved;
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    private onSimTimeChanged;
    /**
     * Executes an update.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    protected doUpdate(simTime: number): void;
    protected abstract updateSensitivity(): void;
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    protected updateIntruderPredictions(simTime: number): void;
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    protected updateIntruderArrays(): void;
    /**
     * Filters an intruder.
     * @param intruder An intruder.
     * @returns Whether the intruder should be tracked by this TCAS.
     */
    protected filterIntruder(intruder: I): boolean;
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    protected updateFilteredIntruderAlertLevels(simTime: number): void;
    protected readonly paSeparationCache: {
        horizontal: NumberUnit<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
        vertical: NumberUnit<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    };
    /**
     * Updates an intruder's alert level.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     */
    protected updateIntruderAlertLevel(simTime: number, intruder: I): void;
    /**
     * Checks whether a resolution advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    protected canIssueResolutionAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a resolution advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    protected canCancelResolutionAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a traffic advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be issued for the intruder.
     */
    protected canIssueTrafficAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a traffic advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be canceled for the intruder.
     */
    protected canCancelTrafficAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a proximity advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be issued for the intruder.
     */
    protected canIssueProximityAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Checks whether a proximity advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be canceled for the intruder.
     */
    protected canCancelProximityAdvisory(simTime: number, intruder: I): boolean;
    /**
     * Updates this TCAS's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    protected updateResolutionAdvisory(simTime: number): void;
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    private initIntruder;
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    private cleanUpIntruder;
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    private onAlertLevelChanged;
}
/**
 * Subscribables which provide data related to the own airplane.
 */
declare type TcasOwnAirplaneSubs = {
    /** A subscribable which provides the own airplane's position. */
    position: Subscribable<GeoPointInterface>;
    /** A subscribable which provides the own airplane's altitude. */
    altitude: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** A subscribable which provides the own airplane's ground track. */
    groundTrack: Subscribable<number>;
    /** A subscribable which provides the own airplane's ground speed. */
    groundSpeed: Subscribable<NumberUnitInterface<UnitFamily.Speed>>;
    /** A subscribable which provides the own airplane's vertical speed. */
    verticalSpeed: Subscribable<NumberUnitInterface<UnitFamily.Speed>>;
    /** A subscribable which provides the own airplane's radar altitude. */
    radarAltitude: Subscribable<NumberUnitInterface<UnitFamily.Distance>>;
    /** A subscribable which provides whether the own airplane is on the ground. */
    isOnGround: Subscribable<boolean>;
};
/**
 * An airplane managed by TCAS.
 */
declare abstract class TcasAirplane {
    protected readonly _position: GeoPoint;
    /** The position of this airplane at the time of the most recent update. */
    readonly position: GeoPointReadOnly;
    /** The altitude of this airplane at the time of the most recent update. */
    protected readonly _altitude: NumberUnit<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    readonly altitude: NumberUnitReadOnly<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    protected _groundTrack: number;
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack(): number;
    /** The ground speed of this airplane at the time of the most recent update. */
    protected readonly _groundSpeed: NumberUnit<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    readonly groundSpeed: NumberUnitReadOnly<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    /** The vertical speed of this airplane at the time of the most recent update. */
    protected readonly _verticalSpeed: NumberUnit<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    readonly verticalSpeed: NumberUnitReadOnly<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    /**
     * The 3D position vector of this airplane at the time of the last update. Each component is expressed in units of
     * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
     * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
     * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
     * airplane.
     */
    readonly positionVec: Float64Array;
    /**
     * The 3D velocity vector of this airplane at the time of the last update. Each component is expressed in units of
     * meters per second. The coordinate system is defined the same as for position vectors.
     */
    readonly velocityVec: Float64Array;
    protected lastUpdateTime: number;
}
/**
 * The own airplane managed by TCAS.
 */
declare class OwnAirplane extends TcasAirplane {
    private readonly subs;
    /** The radar altitude of this airplane at the time of the most recent update. */
    protected readonly _radarAltitude: NumberUnit<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    readonly radarAltitude: NumberUnitReadOnly<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    private _isOnGround;
    /** Whether this airplane is on the ground. */
    get isOnGround(): boolean;
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs: TcasOwnAirplaneSubs);
    /**
     * Calculates the predicted 3D position vector of this airplane at a specified time based on the most recent
     * available data. Each component of the vector is expressed in units of meters, and the origin lies at the most
     * recent updated position of this airplane.
     * @param simTime The sim time at which to calculate the position, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted position vector of this airplane at the specified time.
     */
    predictPosition(simTime: number, out: Float64Array): Float64Array;
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime: number): void;
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, vertical speed, and whether it is on the ground.
     */
    private updateParameters;
    /**
     * Updates this airplane's position and velocity vectors.
     */
    private updateVectors;
}
/**
 * An abstract implementation of {@link TcasIntruder}.
 */
declare abstract class AbstractTcasIntruder extends TcasAirplane implements TcasIntruder {
    readonly contact: TrafficContact;
    private static readonly MIN_GROUND_SPEED;
    private static readonly vec3Cache;
    readonly alertLevel: Subject<TcasAlertLevel>;
    /** The 3D position vector of this intruder relative to own airplane. */
    readonly relativePositionVec: Float64Array;
    /** The 3D velocity vector of this intruder relative to own airplane. */
    readonly relativeVelocityVec: Float64Array;
    private _isPredictionValid;
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid(): boolean;
    /** @inheritdoc */
    readonly tcaTA: TcasTcaPredictionClass;
    /** @inheritdoc */
    readonly tcaRA: TcasTcaPredictionClass;
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact: TrafficContact);
    /** @inheritdoc */
    predictDisplacement(simTime: number, out: Float64Array): Float64Array;
    /** @inheritdoc */
    predictSeparation(simTime: number, horizontalOut: NumberUnit<UnitFamily.Distance>, verticalOut: NumberUnit<UnitFamily.Distance>): void;
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane Own airplane.
     * @param sensitivity The TCAS sensitivity parameters to use when calculating predictions.
     */
    updatePrediction(simTime: number, ownAirplane: OwnAirplane, sensitivity: TcasSensitivityParameters): void;
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    private updateParameters;
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    private updatePosition;
    /**
     * Updates this intruder's velocity.
     * @param ownAirplane The own airplane.
     */
    private updateVelocity;
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    private invalidatePredictions;
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement: Float64Array, out: NumberUnit<UnitFamily.Distance>): NumberUnit<UnitFamily.Distance>;
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement: Float64Array, out: NumberUnit<UnitFamily.Distance>): NumberUnit<UnitFamily.Distance>;
}
/**
 * An default implementation of {@link TcasIntruder}.
 */
declare class DefaultTcasIntruder extends AbstractTcasIntruder {
}
/**
 * A time-of-closest-approach prediction made by TCAS.
 */
declare class TcasTcaPredictionClass implements TcasTcaPrediction {
    private readonly intruder;
    private static readonly vec2Cache;
    private _isValid;
    /** @inheritdoc */
    get isValid(): boolean;
    private _time;
    /** @inheritdoc */
    get time(): number;
    private readonly _tcpa;
    /** @inheritdoc */
    readonly tcpa: NumberUnitReadOnly<UnitFamily.Duration, SimpleUnit<UnitFamily.Duration>>;
    private readonly _tcoa;
    /** @inheritdoc */
    readonly tcoa: NumberUnitReadOnly<UnitFamily.Duration, SimpleUnit<UnitFamily.Duration>>;
    private _isThreat;
    /** @inheritdoc */
    get isThreat(): boolean;
    /** @inheritdoc */
    readonly cpaDisplacement: Float64Array;
    private readonly _cpaHorizontalSep;
    /** @inheritdoc */
    readonly cpaHorizontalSep: NumberUnitReadOnly<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    private readonly _cpaVerticalSep;
    /** @inheritdoc */
    readonly cpaVerticalSep: NumberUnitReadOnly<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    private _cpaNorm;
    /** @inheritdoc */
    get cpaNorm(): number;
    /**
     * Constructor.
     * @param intruder The intruder associated with this prediction.
     */
    constructor(intruder: TcasIntruder);
    /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param tau The maximum lookahead time.
     * @param dmod The radius of the own airplane's protected volume.
     * @param zthr The half-height of the own airplane's protected volume.
     * @param hmd The distance threshold for the horizontal miss distance filter. If not defined, the HMD filter will
     * not be applied.
     */
    update(simTime: number, tau: NumberUnitInterface<UnitFamily.Duration>, dmod: NumberUnitInterface<UnitFamily.Distance>, zthr: NumberUnitInterface<UnitFamily.Distance>, hmd?: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidate(): void;
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    private static calculateDisplacementVector;
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    private static calculateCylindricalNorm;
}
/**
 * An implementation of {@link TcasResolutionAdvisoryHost}.
 */
declare class TcasResolutionAdvisoryHostClass implements TcasResolutionAdvisoryHost {
    private readonly options;
    private readonly ownAirplane;
    /** The base amount of delay between state changes, in milliseconds, before predicted response time is taken into account. */
    private static readonly STATE_CHANGE_DELAY_BASE;
    private static readonly CLIMB_DESC_VS_MPS;
    private static readonly INC_CLIMB_DESC_VS_MPS;
    private static readonly INTRUDER_SORT_FUNC;
    private static readonly TYPE_DEFS;
    private static readonly vec3Cache;
    private readonly initialResponseTimeSeconds;
    private readonly initialAccelMps;
    private readonly subsequentResponseTimeSeconds;
    private readonly subsequentAccelMps;
    private readonly intruders;
    readonly intruderArray: TcasIntruder[];
    private readonly _maxVerticalSpeed;
    /** @inheritdoc */
    readonly maxVerticalSpeed: NumberUnitReadOnly<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    private readonly _minVerticalSpeed;
    /** @inheritdoc */
    readonly minVerticalSpeed: NumberUnitReadOnly<UnitFamily.Speed, CompoundUnit<UnitFamily.Speed>>;
    private _flags;
    /** @inheritdoc */
    get flags(): number;
    private _primaryType;
    /** @inheritdoc */
    get primaryType(): TcasResolutionAdvisoryType;
    private _secondaryType;
    /** @inheritdoc */
    get secondaryType(): TcasResolutionAdvisoryType | null;
    private _primaryFlags;
    /** @inheritdoc */
    get primaryFlags(): number;
    private _secondaryFlags;
    /** @inheritdoc */
    get secondaryFlags(): number;
    private readonly vsConstraints;
    private lastStateChangeTime;
    private stateChangeDelay;
    private isInitial;
    private senseReversalCount;
    private readonly publisher;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options to adjust how the host should calculate resolution advisories.
     * @param ownAirplane The own airplane.
     */
    constructor(bus: EventBus, options: TcasResolutionAdvisoryOptions, ownAirplane: OwnAirplane);
    /**
     * Checks whether this host can issue a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder The query intruder.
     * @returns Whether this host can issue a resolution advisory for an intruder.
     */
    canIssueResolutionAdvisory(simTime: number, intruder: TcasIntruder): boolean;
    /**
     * Checks whether this host can cancel a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @returns Whether this host can cancel a resolution advisory for an intruder.
     */
    canCancelResolutionAdvisory(simTime: number): boolean;
    /**
     * Updates this host's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    update(simTime: number, alim: NumberUnitInterface<UnitFamily.Distance>, intruders: ReadonlySet<TcasIntruder>): void;
    /**
     * Updates this host's resolution advisory's array of active intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    private updateIntruders;
    /**
     * Updates the vertical speed constraints associated with the intruders participating in this host's current
     * resolution advisory.
     * @param alimMeters The value of ALIM (the minimum desired vertical separation between the own airplane and an
     * intruder at time of closest approach), in meters.
     * @param responseTimeSeconds The predicted amount of time, in seconds, for the own airplane to respond to the most
     * recently issued resolution advisory, relative to the present.
     * @param accelMps The predicted vertical acceleration, in meters per second squared, of the own airplane when
     * responding to the most recently issued resolution advisory.
     */
    private updateVsConstraints;
    /**
     * Selects an initial state for a new resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    private selectInitialState;
    /**
     * Updates an existing positive resolution advisory. Positive resolution advisories include the CLIMB and DESCEND and
     * related types (CROSSING, MAINTAIN, INCREASE, REVERSAL).
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    private updatePositive;
    /**
     * Updates an existing negative resolution advisory. Negative resolution advisories include the REDUCE CLIMB/DESCENT
     * and DO NOT CLIMB/DESCEND types.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    private updateNegative;
    /**
     * Updates an existing composite resolution advisory. Composite resolution advisories consist of a (corrective or
     * preventative) negative resolution advisory combined with a negative preventative resolution advisory of the
     * opposite sense.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     * @throws Error if a composite resolution advisory is not active.
     */
    private updateComposite;
    /**
     * Sets the state of this host's current resolution advisory. If the specified state is equal to the current state
     * of the resolution advisory, this method does nothing. If the state is successfully set, the `tcas_ra_issued`
     * event will be published if `isInitial` is `true`, or the `tcas_ra_updated` event if `isInitial` is `false`.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param primaryType The primary type of the resolution advisory.
     * @param secondaryType The secondary type of the resolution advisory.
     * @param isInitial Whether the state to set is for an initial resolution advisory.
     */
    private setState;
    /**
     * Cancels this host's current resolution advisory. If there is no currently active resolution advisory, this
     * method does nothing. If the resolution advisory is successfully cancelled, the `tcas_ra_canceled` event will be
     * published.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    cancel(simTime: number): void;
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * above all current RA intruders.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation above all current RA intruders.
     */
    private getUpSenseRequiredMinVs;
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * below all current RA intruders.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation below all current RA intruders.
     */
    private getDownSenseRequiredMaxVs;
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    private getCompositeRequiredMinVs;
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    private getCompositeRequiredMaxVs;
    /**
     * Calculates the vertical speed required to achieve a desired altitude target at time of closest approach.
     * @param tcpa The time to closest approach from the present, in seconds.
     * @param currentAlt The current altitude of the own airplane, in meters.
     * @param vs The current vertical speed of the own airplane, in meters per second.
     * @param responseTime The response time of the own airplane, in seconds.
     * @param accel The acceleration of the own airplane, in meters per second squared.
     * @param targetAlt The target altitude of the own airplane at time of closest approach, in meters.
     * @returns The vertical speed, in meters per second, required to achieve a desired altitude target at time of
     * closest approach. A value of `NaN` indicates the altitude target cannot be reached with the specified parameters.
     */
    private static calculateVSToTargetAlt;
    /**
     * Gets the least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for a given minimum
     * vertical speed requirement.
     * @param minVsMps A minimum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for the specified
     * minimum vertical speed requirement.
     */
    private static getDoNotDescendType;
    /**
     * Gets the least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for a given maximum
     * vertical speed requirement.
     * @param maxVsMps A maximum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for the specified
     * maximum vertical speed requirement.
     */
    private static getDoNotClimbType;
}

/**
 * A data provider for TCAS advisories.
 */
interface TcasAdvisoryDataProvider {
    /** The set of intruders associated with active proximity advisories. */
    readonly paIntruders: SubscribableSet<TcasIntruder>;
    /** The set of intruders associated with active traffic advisories. */
    readonly taIntruders: SubscribableSet<TcasIntruder>;
    /** The set of intruders associated with active resolution advisories. */
    readonly raIntruders: SubscribableSet<TcasIntruder>;
}
/**
 * A default implementation of {@link TcasAdvisoryDataProvider}.
 */
declare class DefaultTcasAdvisoryDataProvider implements TcasAdvisoryDataProvider {
    private readonly bus;
    private readonly tcas;
    private readonly _paIntruders;
    readonly paIntruders: SubscribableSet<TcasIntruder>;
    private readonly _taIntruders;
    readonly taIntruders: SubscribableSet<TcasIntruder>;
    private readonly _raIntruders;
    readonly raIntruders: SubscribableSet<TcasIntruder>;
    private isInit;
    private isAlive;
    private isPaused;
    private intruderAlertLevelSub?;
    private intruderRemovedSub?;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tcas The TCAS instance.
     */
    constructor(bus: EventBus, tcas: Tcas);
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused?: boolean): void;
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume(): void;
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause(): void;
    /**
     * Updates this provider's sets of intruders associated with active advisories.
     */
    private updateIntruders;
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy(): void;
}

/**
 * Standard TCAS-II sensitivity parameters.
 */
declare class TcasIISensitivityParameters {
    private static readonly PA;
    private static readonly TA_LEVELS;
    private static readonly RA_LEVELS;
    /**
     * Selects a sensitivity level for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): number;
    /**
     * Selects Proximity Advisory sensitivity parameters.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity parameters.
     */
    selectPA(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): TcasAdvisoryParameters;
    /**
     * Selects Traffic Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity parameters for the specified environment.
     */
    selectTA(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): TcasTcaParameters;
    /**
     * Selects Resolution Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Resolution Advisory sensitivity parameters for the specified environment.
     */
    selectRA(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): TcasTcaParameters;
    /**
     * Selects a Resolution Advisory ALIM for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns A Resolution Advisory ALIM for the specified environment.
     */
    selectRAAlim(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): NumberUnitInterface<UnitFamily.Distance>;
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    getPA(level: number): TcasAdvisoryParameters;
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level: number): TcasTcaParameters;
    /**
     * Gets Resolution Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Resolution Advisory sensitivity parameters for the given sensitivity level.
     */
    getRA(level: number): TcasTcaParameters;
    /**
     * Gets a Resolution Advisory ALIM for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns A Resolution Advisory ALIM for the given sensitivity level.
     */
    getRAAlim(level: number): NumberUnitInterface<UnitFamily.Distance>;
}
/**
 * An implementation of {@link TCASSensitivity} which provides sensitivity parameters as defined in the official
 * TCAS II specification.
 */
declare class TcasIISensitivity implements TcasSensitivity {
    private readonly sensitivity;
    private level;
    private readonly params;
    /** @inheritdoc */
    selectParameters(): TcasSensitivityParameters;
    /** @inheritdoc */
    selectRAAlim(): NumberUnitInterface<UnitFamily.Distance>;
    /**
     * Updates sensitivity level based on the current environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    updateLevel(altitude: NumberUnitInterface<UnitFamily.Distance>, radarAltitude: NumberUnitInterface<UnitFamily.Distance>): void;
}

/**
 * Traffic alert level modes.
 */
declare enum MapTrafficAlertLevelVisibility {
    Other = 1,
    ProximityAdvisory = 2,
    TrafficAdvisory = 4,
    ResolutionAdvisory = 8,
    All = 15
}
/**
 * A module describing the display of traffic.
 */
declare class MapTrafficModule {
    readonly tcas: Tcas;
    /** Whether to show traffic information. */
    readonly show: Subject<boolean>;
    /** The TCAS operating mode. */
    readonly operatingMode: Subscribable<TcasOperatingMode>;
    /**
     * The distance from the own airplane beyond which intruders are considered off-scale. If the value is `NaN`,
     * intruders are never considered off-scale.
     */
    readonly offScaleRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** Alert level visibility flags. */
    readonly alertLevelVisibility: Subject<number>;
    /** The difference in altitude above the own airplane above which intruders will not be displayed. */
    readonly altitudeRestrictionAbove: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The difference in altitude below the own airplane below which intruders will not be displayed. */
    readonly altitudeRestrictionBelow: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** Whether displayed intruder altitude is relative. */
    readonly isAltitudeRelative: Subject<boolean>;
    /**
     * Creates an instance of a MapTrafficModule.
     * @param tcas This module's associated TCAS.
     */
    constructor(tcas: Tcas);
}

/**
 * Modules required by MapSystemTrafficLayer.
 */
interface MapSystemTrafficLayerModules {
    /** Traffic module. */
    [MapSystemKeys.Traffic]: MapTrafficModule;
}
/**
 * A map icon for a TCAS intruder.
 */
interface MapTrafficIntruderIcon {
    /** This icon's associated intruder. */
    readonly intruder: TcasIntruder;
    /** The projected position of this icon's intruder, in pixel coordinates, at the time it was last drawn. */
    readonly projectedPos: ReadonlyFloat64Array;
    /** Whether this icon's intruder is off-scale at the time it was last drawn. */
    readonly isOffScale: boolean;
    /**
     * Draws this icon.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    draw(projection: MapProjection, context: CanvasRenderingContext2D, offScaleRange: NumberUnitInterface<UnitFamily.Distance>): void;
}
/**
 * A function which creates map icons for TCAS intruders.
 * @param intruder The intruder for which to create an icon.
 * @param context The context of the icon's parent map.
 */
declare type MapTrafficIntruderIconFactory<Modules = any, Layers extends LayerRecord = any, Controllers extends ControllerRecord = any, Context = any> = (intruder: TcasIntruder, context: MapSystemContext<Modules, Layers, Controllers, Context>) => MapTrafficIntruderIcon;
/**
 * Component props for MapSystemTrafficLayer.
 */
interface MapSystemTrafficLayerProps extends MapLayerProps<MapSystemTrafficLayerModules> {
    /** The context of the layer's parent map. */
    context: MapSystemContext<any, any, any, any>;
    /** A function which creates icons for intruders. */
    iconFactory: MapTrafficIntruderIconFactory;
    /**
     * A function which initializes global canvas styles for the layer.
     * @param context The canvas rendering context for which to initialize styles.
     */
    initCanvasStyles?: (context: CanvasRenderingContext2D) => void;
    /** A subscribable set to update with off-scale intruders. */
    offScaleIntruders?: MutableSubscribableSet<TcasIntruder>;
    /**
     * A subscribable set to update with intruders that are not off-scale but whose projected positions are considered
     * out-of-bounds.
     */
    oobIntruders?: MutableSubscribableSet<TcasIntruder>;
    /**
     * A subscribable which provides the offset of the intruder out-of-bounds boundaries relative to the boundaries of
     * the map's projected window, as `[left, top, right, bottom]` in pixels. Positive offsets are directed toward the
     * center of the map. Defaults to `[0, 0, 0, 0]`.
     */
    oobOffset?: Subscribable<ReadonlyFloat64Array>;
}
/**
 * A map layer which displays traffic intruders.
 */
declare class MapSystemTrafficLayer extends MapLayer<MapSystemTrafficLayerProps> {
    private static readonly DRAW_GROUPS;
    private readonly iconLayerRef;
    private readonly trafficModule;
    private readonly intruderIcons;
    private readonly needHandleOffscaleOob;
    private readonly oobOffset;
    private readonly oobBounds;
    private isInit;
    /** @inheritdoc */
    onVisibilityChanged(isVisible: boolean): void;
    /** @inheritdoc */
    onAttached(): void;
    /**
     * Initializes canvas styles.
     */
    private initCanvasStyles;
    /**
     * Initializes all currently existing TCAS intruders.
     */
    private initIntruders;
    /**
     * Initializes handlers to respond to TCAS events.
     */
    private initTCASHandlers;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /**
     * Updates the boundaries of the intruder out-of-bounds area.
     */
    private updateOobBounds;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /**
     * Redraws all tracked intruders.
     */
    private redrawIntruders;
    /**
     * Updates this layer's visibility.
     */
    private updateVisibility;
    /**
     * A callback which is called when a TCAS intruder is added.
     * @param intruder The new intruder.
     */
    private onIntruderAdded;
    /**
     * A callback which is called when a TCAS intruder is removed.
     * @param intruder The removed intruder.
     */
    private onIntruderRemoved;
    /**
     * A callback which is called when the alert level of a TCAS intruder is changed.
     * @param intruder The intruder.
     */
    private onIntruderAlertLevelChanged;
    /** @inheritdoc */
    render(): VNode;
}
/**
 * An abstract implementation of {@link MapTrafficIntruderIcon} which handles the projection of the intruder's position
 * and off-scale calculations.
 */
declare abstract class AbstractMapTrafficIntruderIcon implements MapTrafficIntruderIcon {
    readonly intruder: TcasIntruder;
    protected readonly trafficModule: MapTrafficModule;
    protected readonly ownshipModule: MapOwnAirplanePropsModule;
    private static readonly geoPointCache;
    readonly projectedPos: Float64Array;
    isOffScale: boolean;
    /**
     * Constructor.
     * @param intruder This icon's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The ownship module for this icon's parent map.
     */
    constructor(intruder: TcasIntruder, trafficModule: MapTrafficModule, ownshipModule: MapOwnAirplanePropsModule);
    /**
     * Draws this icon.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw this icon.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    draw(projection: MapProjection, context: CanvasRenderingContext2D, offScaleRange: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Updates this icon's intruder's projected position and off-scale status.
     * @param projection The map projection.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    protected updatePosition(projection: MapProjection, offScaleRange: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Updates this icon's intruder's projected position and off-scale status using a specific range from the own
     * airplane to define off-scale.
     * @param projection The map projection.
     * @param ownAirplanePos The position of the own airplane.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale.
     */
    protected handleOffScaleRange(projection: MapProjection, ownAirplanePos: GeoPointInterface, offScaleRange: NumberUnitInterface<UnitFamily.Distance>): void;
    /**
     * Draws this icon.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw this icon.
     * @param projectedPos The projected position of this icon's intruder.
     * @param isOffScale Whether this icon's intruder is off-scale.
     */
    protected abstract drawIcon(projection: MapProjection, context: CanvasRenderingContext2D, projectedPos: ReadonlyFloat64Array, isOffScale: boolean): void;
}

/**
 * A handler to determine waypoint visibility.
 */
declare type WaypointVisibilityHandler<T extends Facility> = (w: FacilityWaypoint<T>) => boolean;
/**
 * Filters for the nearest intersections.
 */
interface IntersectionFilters {
    /** A bitmask of allowable intersection types. */
    typeMask: number;
    /** Whether or not to show terminal waypoints. */
    showTerminalWaypoints: boolean;
}
/**
 * Filters for the nearest VORs.
 */
interface VorFilters {
    /** A bitmask of allowable VOR types. */
    typeMask: number;
    /** A bitmask of allowable VOR classes. */
    classMask: number;
}
/**
 * Filters for the nearest airports.
 */
interface AirportFilters {
    /** A bitmask of allowable airport classes. */
    classMask: number;
    /** Whether or not to show closed airports. */
    showClosed: boolean;
}
/**
 * Extended filters for the nearest airports.
 */
interface ExtendedAirportFilters {
    /** A bitmask of allowable runway surface types. */
    runwaySurfaceTypeMask: number;
    /** A bitmask of allowable approach types. */
    approachTypeMask: number;
    /** A bitmask of whether or not to show towered or untowered airports. */
    toweredMask: number;
    /** The minimum runway length to allow. */
    minimumRunwayLength: number;
}
/**
 * A map data module that controls waypoint display options.
 */
declare class MapWaypointDisplayModule {
    /** A handler that dictates airport waypoint visibility. */
    readonly showAirports: Subject<WaypointVisibilityHandler<AirportFacility>>;
    /** A handler that dictates intersection waypoint visibility. */
    readonly showIntersections: Subject<WaypointVisibilityHandler<IntersectionFacility>>;
    /** A handler that dictates NDB waypoint visibility. */
    readonly showNdbs: Subject<WaypointVisibilityHandler<NdbFacility>>;
    /** A handler that dictates VOR waypoint visibility. */
    readonly showVors: Subject<WaypointVisibilityHandler<VorFacility>>;
    /** The maximum range at which airport waypoints should be searched for. */
    readonly airportsRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The maximum range at which intersection waypoints should be searched for. */
    readonly intersectionsRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The maximum range at which NDB waypoints should be searched for. */
    readonly ndbsRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The maximum range at which VOR waypoints should be searched for. */
    readonly vorsRange: NumberUnitSubject<UnitFamily.Distance, SimpleUnit<UnitFamily.Distance>>;
    /** The maximum number of airports that should be displayed. */
    readonly numAirports: Subject<number>;
    /** The maximum number of intersections that should be displayed. */
    readonly numIntersections: Subject<number>;
    /** The maximum number of NDBs that should be displayed. */
    readonly numNdbs: Subject<number>;
    /** The maximum number of VORs that should be displayed. */
    readonly numVors: Subject<number>;
    /** The filter to apply to the intersection search. */
    readonly intersectionsFilter: Subject<IntersectionFilters>;
    /** The filter to apply to the VOR search. */
    readonly vorsFilter: Subject<VorFilters>;
    /** The filter to apply to the airport search. */
    readonly airportsFilter: Subject<AirportFilters>;
    /** The extended airport filter to apply to the airport search. */
    readonly extendedAirportsFilter: Subject<ExtendedAirportFilters>;
    /** A function that will be called with a waypoint when it is registered,
     * and should return the role to use for that waypoint. */
    readonly waypointRoleSelector: Subject<((waypoint: Waypoint) => string) | undefined>;
    /** Forces a refresh of all the waypoints. Useful if a waypoint needs a different role to be selected. */
    readonly refreshWaypoints: SubEvent<void, void>;
}

/**
 * Modules required by MapSystemWaypointsLayer.
 */
interface MapSystemWaypointsLayerModules {
    /** Waypoints display module. */
    [MapSystemKeys.NearestWaypoints]: MapWaypointDisplayModule;
}
/**
 * Props on the MapSystemWaypointsLayer component.
 */
interface MapSystemWaypointsLayerProps extends MapLayerProps<MapSystemWaypointsLayerModules> {
    /** The event bus. */
    bus: EventBus;
    /** The waypoint renderer to use. */
    waypointRenderer: MapSystemWaypointsRenderer;
    /** The icon factory to use with this component. */
    iconFactory: MapSystemIconFactory;
    /** The label factory to use with this component. */
    labelFactory: MapSystemLabelFactory;
    /**
     * Whether to use the map's projection target as the center for facility searches instead of the map's center.
     * Defaults to `false`.
     */
    useMapTargetAsSearchCenter?: boolean;
    /** An optional waypoint cache to use with this layer. Will default to DefaultFacilityWaypointCache if not supplied. */
    waypointCache?: FacilityWaypointCache;
}
/**
 * A class that renders waypoints into a layer.
 */
declare class MapSystemWaypointsLayer extends MapLayer<MapSystemWaypointsLayerProps> {
    private readonly waypointsLayer;
    private readonly displayModule;
    private readonly waypointCache;
    private readonly searchItemLimits;
    private readonly searchRadiusLimits;
    /** @inheritdoc */
    onAttached(): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    private initEventHandlers;
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     */
    private onSessionsStarted;
    /**
     * Initializes this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    private initWaypointRenderer;
    /**
     * Defines the render role for this layer's waypoints.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    private defineRenderRole;
    /** @inheritdoc */
    setVisible(val: boolean): void;
    /**
     * Checks to see if a waypoint should be visible.
     * @param waypoint The waypoint to check.
     * @returns True if visible, false otherwise.
     */
    private isWaypointVisible;
    /** @inheritdoc */
    render(): VNode;
    /**
     * Registers a waypoint with this layer's waypoint renderer.
     * @param waypoint The waypoint to register.
     * @param renderer The renderer to register the waypoint to.
     */
    private registerWaypoint;
    /**
     * Deregisters a waypoint with this layer's waypoint renderer.
     * @param waypoint The waypoint to deregister.
     * @param renderer The renderer to deregister the waypoint from.
     */
    private deregisterWaypoint;
}

/**
 * A map data module that controls the terrain color reference point.
 */
declare class MapTerrainColorsModule {
    /** The terrain colors reference point. */
    readonly reference: Subject<EBingReference>;
    /** Whether or not to show the map terrain isolines. */
    readonly showIsoLines: Subject<boolean>;
    /** The terrain colors array. */
    readonly colors: ArraySubject<number>;
    /** The elevation range over which to assign the terrain colors, as `[minimum, maximum]` in feet. */
    readonly colorsElevationRange: Vec2Subject;
}

/**
 * A module that describes the display of weather on a Bing Map instance.
 */
declare class MapWxrModule {
    /** Whether the weather radar is enabled. */
    readonly isEnabled: Subject<boolean>;
    /** The current map weather radar arc sweep angle in degrees. */
    readonly weatherRadarArc: NumberUnitSubject<UnitFamily.Angle, SimpleUnit<UnitFamily.Angle>>;
    /** The current weather radar mode. */
    readonly weatherRadarMode: Subject<EWeatherRadar.TOPVIEW | EWeatherRadar.HORIZONTAL | EWeatherRadar.VERTICAL>;
    /**
     * The current weather radar colors. Each entry `E_i` of the array is a tuple `[color, rate]` that defines a color
     * stop, where `color` is an RGBA color expressed as `R + G * 256 + B * 256^2 + A * 256^3` and `rate` is a
     * precipitation rate in millimeters per hour.
     *
     * In general, the color defined by `E_i` is applied to precipitation rates ranging from the rate defined by `E_i-1`
     * to the rate defined by `E_i`. There are two special cases. The color defined by `E_0` is applied to the
     * precipitation rates from zero to the rate defined by `E_0`. The color defined by `E_n-1`, where `n` is the length
     * of the array, is applied to the precipitation rates from the rate defined by `E_n-2` to positive infinity.
     */
    readonly weatherRadarColors: ArraySubject<readonly [number, number]>;
    private readonly _wxrMode;
    /**
     * A subscribable containing the combined WxrMode from the mode and arc subjects,
     * suitable for consumption in a MapBingLayer.
     * @returns The WxrMode subscribable.
     */
    get wxrMode(): Subscribable<WxrMode>;
}

/**
 * A class that builds a configuration for the waypoint display.
 */
declare class WaypointDisplayBuilder {
    protected readonly iconFactory: MapSystemIconFactory;
    protected readonly labelFactory: MapSystemLabelFactory;
    protected readonly waypointRenderer: MapSystemWaypointsRenderer;
    protected roleGroup: string;
    protected isCenterTarget: boolean;
    protected facilityWaypointCache: FacilityWaypointCache | undefined;
    /**
     * Creates an instance of the WaypointDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     */
    constructor(iconFactory: MapSystemIconFactory, labelFactory: MapSystemLabelFactory, waypointRenderer: MapSystemWaypointsRenderer);
    /**
     * Adds a icon configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an icon for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addIcon<T extends Waypoint>(role: number | string, type: string, config: (waypoint: T) => MapWaypointIcon<T>): this;
    /**
     * Adds a default icon configuration to the waypoint display system, if no other configuration is found.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultIcon<T extends Waypoint>(role: number | string, config: (waypoint: T) => MapWaypointIcon<T>): this;
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an label for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addLabel<T extends Waypoint>(role: number | string, type: string, config: (waypoint: T) => MapCullableLocationTextLabel): this;
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultLabel<T extends Waypoint>(role: number | string, config: (waypoint: T) => MapCullableLocationTextLabel): this;
    /**
     * Determines the role ID given either a numeric or string based role.
     * @param role The role to determine.
     * @returns The numeric role ID.
     */
    private determineRoleId;
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name: string): this;
    /**
     * Gets the ID of a role in the waypoint display system.
     * @param role The name of the role to get the ID for.
     * @returns The ID of the role.
     * @throws An error if an invalid role name is supplied.
     */
    getRoleId(role: string): number;
    /**
     * Configures the center for waypoint searches for this display.
     * @param center If center, then waypoint searches will use the map center. If target,
     * waypoint searches will use the map target with offset.
     * @returns The modified builder.
     */
    withSearchCenter(center: 'center' | 'target'): this;
    /**
     * Gets if the waypoint search is using the map target with offset as the search center.
     * @returns True if the search center is the map target, false if it is the map center.
     */
    getIsCenterTarget(): boolean;
    /**
     * Configures the facility waypoint cache to use with the waypoint display.
     * @param cache The facility waypoint cache to use, or undefined to use the default.
     * @returns The modified builder.
     */
    withWaypointCache(cache: FacilityWaypointCache | undefined): this;
    /**
     * Gets the currently set facility waypoint cache.
     * @returns The currently set facility waypoint cache.
     */
    getWaypointCache(): FacilityWaypointCache | undefined;
}

/**
 * A class that builds the configuration for the flight plan display.
 */
declare class FlightPlanDisplayBuilder extends WaypointDisplayBuilder {
    private readonly flightPlanRenderer;
    readonly planIndex: number;
    protected roleGroup: string;
    /**
     * Creates an instance of the FlightPlanDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     * @param flightPlanRenderer The flight plan renderer to use with this builder.
     * @param planIndex The flight plan index to be displayed by this system.
     */
    constructor(iconFactory: MapSystemIconFactory, labelFactory: MapSystemLabelFactory, waypointRenderer: MapSystemWaypointsRenderer, flightPlanRenderer: MapSystemPlanRenderer, planIndex: number);
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name: string): this;
    /**
     * Configures the flight path display to use styles returned by the provided function.
     * @param handler The handler to use to return the required path rendering styles.
     * @returns The modified builder.
     */
    withLegPathStyles(handler: LegStyleHandler): this;
    /**
     * Configures the flight plan waypoint display to use the roles returned by the
     * provided function.
     * @param handler The handler to use to return the required waypoint display roles.
     * @returns The modified builder.
     */
    withLegWaypointRoles(handler: LegWaypointHandler): this;
    /**
     * Configures the flight plan flight path display to set visibility of leg-to-leg
     * turn anticipation transitions.
     * @param visible Whether or not the leg-to-leg turn anticipation transitions will be visible.
     * @returns The modified builder.
     */
    withAnticipationTurns(visible: boolean | Subscribable<boolean>): this;
}

/**
 * A key for a property in {@link MapAutopilotPropsModule}.
 */
declare type MapAutopilotPropsKey = Extract<keyof MapAutopilotPropsModule, string>;

/**
 * A function which defines a custom build step.
 */
declare type MapSystemCustomBuilder<Args extends any[] = any[], RequiredModules extends ModuleRecord = any, RequiredLayers extends LayerRecord = any, RequiredContext extends ContextRecord = any> = (mapBuilder: MapSystemBuilder<RequiredModules, RequiredLayers, any, RequiredContext>, ...args: Args) => MapSystemBuilder<any, any, any, any>;
/**
 * Retrieves the extra arguments, after the map builder, of a custom builder.
 */
declare type CustomBuilderArgs<Builder> = Builder extends MapSystemCustomBuilder<infer Args> ? Args : never;
/**
 * Retrieves a custom map builder's required modules.
 */
declare type RequiredCustomBuilderModules<Builder> = Builder extends MapSystemCustomBuilder<any, infer M> ? M : never;
/**
 * Retrieves a custom map builder's required layers.
 */
declare type RequiredCustomBuilderLayers<Builder> = Builder extends MapSystemCustomBuilder<any, any, infer L> ? L : never;
/**
 * Retrieves a custom map builder's required context.
 */
declare type RequiredCustomBuilderContext<Builder> = Builder extends MapSystemCustomBuilder<any, any, any, infer Context> ? Context : never;
/**
 * A map model module factory.
 */
declare type ModuleFactory = {
    /** The key of the module to create. */
    key: string;
    /** The constructor of the module to create. */
    factory: () => any;
};
/**
 * A map layer factory.
 */
declare type LayerFactory = {
    /** The key of the layer to create. */
    key: string;
    /** A function which renders the layer to create. */
    factory: (context: MapSystemContext<any, any, any, any>) => VNode;
    /** The order value of the layer to create. */
    order: number;
};
/**
 * A map controller factory.
 */
declare type ControllerFactory = {
    /** A function which creates the controller. */
    factory: (context: MapSystemContext<any, any, any, any>) => MapSystemController<any, any, any>;
};
/**
 * A map context property factory.
 */
declare type ContextFactory = {
    /** The key of the property to create. */
    key: string;
    /** A function which creates the context property. */
    factory: (context: MapSystemContext<any, any, any, any>) => any;
    /** The value determining in which order to create the property.  */
    order: number;
};
/**
 * Checks if a set of module, layer, and context records meet certain requirements. If the requirements are met, the
 * specified type is returned. If the requirements are not met, `never` is returned.
 */
declare type ConditionalReturn<Modules, RequiredModules, Layers, RequiredLayers, Context, RequiredContext, ReturnType> = Modules extends RequiredModules ? Layers extends RequiredLayers ? Context extends RequiredContext ? ReturnType : never : never : never;
/** Checks if a type is exactly the `any` type. */
declare type IsAny<T> = boolean extends (T extends never ? true : false) ? true : false;
/** Returns a type if it is not `any`, otherwise returns a default type. */
declare type DefaultIfAny<T, Default> = IsAny<T> extends true ? Default : T;
/**
 * Options for handling off-scale and out-of-bounds traffic intruders on a traffic layer.
 */
declare type TrafficOffScaleOobOptions = {
    /** A subscribable set to update with off-scale intruders. */
    offScaleIntruders?: MutableSubscribableSet<TcasIntruder>;
    /**
     * A subscribable set to update with intruders that are not off-scale but whose projected positions are considered
     * out-of-bounds.
     */
    oobIntruders?: MutableSubscribableSet<TcasIntruder>;
    /**
     * A subscribable which provides the offset of the intruder out-of-bounds boundaries relative to the boundaries of
     * the map's projected window, as `[left, top, right, bottom]` in pixels. Positive offsets are directed toward the
     * center of the map. Defaults to `[0, 0, 0, 0]`.
     */
    oobOffset?: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>;
};
/**
 * Builds maps. Each builder is configured with a series of build steps which collectively define how the builder
 * compiles finished maps. In addition to defining basic map properties such as size and range, build steps can also
 * customize map behavior and appearance through adding map model modules, layers, and controllers.
 *
 * Each map compiled by the builder is associated with a {@link MapSystemContext}, which holds references to the map
 * projection, map model, all layers and controllers, and other data associated with the map. Layers and controllers
 * have access to the context when they are created during compilation, and a reference to the context is stored with
 * the compiled map.
 *
 * A single builder can compile multiple maps. Each compiled map is a separate entity, with its own model, layers,
 * controllers, and context.
 */
declare class MapSystemBuilder<Modules extends ModuleRecord = any, Layers extends LayerRecord = any, Controllers extends ControllerRecord = any, Context extends ContextRecord = any> {
    readonly bus: EventBus;
    protected static readonly RESTRICTED_CONTEXT_KEYS: Set<string>;
    protected readonly moduleFactories: Map<string, ModuleFactory>;
    protected readonly layerFactories: Map<string, LayerFactory>;
    protected readonly controllerFactories: Map<string, ControllerFactory>;
    protected readonly contextFactories: Map<string, ContextFactory>;
    protected readonly initCallbacks: Map<string, (context: MapSystemContext<any, any, any, any>) => void>;
    protected projectedSize: Subscribable<ReadonlyFloat64Array>;
    protected deadZone?: Subscribable<ReadonlyFloat64Array>;
    protected targetOffset?: ReadonlyFloat64Array;
    protected nominalRangeEndpoints?: ReadonlyFloat64Array;
    protected range?: number;
    /** The number of map model modules added to this builder. */
    get moduleCount(): number;
    /** The number of map layers added to this builder. */
    get layerCount(): number;
    /** The number of map controllers added to this builder. */
    get controllerCount(): number;
    /**
     * Creates an instance of a map system builder.
     * @param bus This builder's event bus.
     */
    protected constructor(bus: EventBus);
    /**
     * Creates a new Garmin map builder. The builder is initialized with a default projected size of `[100, 100]` pixels.
     * @param bus The event bus.
     * @returns A new Garmin map builder.
     */
    static create(bus: EventBus): MapSystemBuilder;
    /**
     * Configures this builder to generate a map with a given projected window size.
     * @param size The size of the projected window, as `[width, height]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withProjectedSize(size: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>): this;
    /**
     * Configures this builder to generate a map with a given dead zone.
     * @param deadZone The dead zone, as `[left, top, right, bottom]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withDeadZone(deadZone: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>): this;
    /**
     * Configures this builder to generate a map with an initial projected target offset.
     * @param offset The initial projected target offset, as `[x, y]` in pixels.
     * @returns This builder, after it has been configured.
     */
    withTargetOffset(offset: ReadonlyFloat64Array): this;
    /**
     * Configures this builder to generate a map with specific initial range endpoints. The endpoints are defined
     * relative to the width and height of the map's projected window, *excluding* the dead zone.
     * @param endpoints The initial range endpoints, as `[x1, y1, x2, y2]`.
     * @returns This builder, after it has been configured.
     */
    withRangeEndpoints(endpoints: ReadonlyFloat64Array): this;
    /**
     * Configures this build to generate a map with a specific initial range.
     * @param range The initial range.
     * @returns This builder, after it has been configured.
     */
    withRange(range: NumberUnitInterface<UnitFamily.Distance>): this;
    /**
     * Adds a map module to this builder. When this builder compiles its map, all added modules will be created and added
     * to the map's model. If an existing module has been added to this builder with the same key, it will be replaced.
     * @param key The key (name) of the module.
     * @param factory A function which creates the module.
     * @returns This builder, after the map module has been added.
     */
    withModule(key: string, factory: () => any): this;
    /**
     * Adds a map layer to this builder. When this builder compiles its map, all added layers will be created and
     * attached to the map. Layers with a lower assigned order will be attached before and appear below layers with
     * greater assigned order values. If an existing layer has been added to this builder with the same key, it will be
     * replaced.
     * @param key The key of the layer.
     * @param factory A function which renders the layer as a VNode.
     * @param order The order assigned to the layer. Layers with lower assigned order will be attached to the map before
     * and appear below layers with greater assigned order values. Defaults to the number of layers already added to this
     * builder.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the layer.
     */
    withLayer<L extends MapLayer = any, UseModules extends ModuleRecord = any, UseContext extends ContextRecord = any>(key: string, factory: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, EmptyRecord, EmptyRecord, DefaultIfAny<UseContext, Context>>) => VNode, order?: number): ConditionalReturn<DefaultIfAny<UseModules, Modules>, RequiredLayerModules<L>, any, any, any, any, this>;
    /**
     * Adds a controller to this builder. When this builder compiles its map, all added controllers will be created and
     * hooked up to the map's lifecycle callbacks. If an existing controller has been added to this builder with the same
     * key, it will be replaced.
     * @param key The key of the controller.
     * @param factory A function which creates the controller.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the controller.
     */
    withController<Controller extends MapSystemController<any, any, any, any>, UseModules extends ModuleRecord = any, UseLayers extends LayerRecord = any, UseControllers extends ControllerRecord = any, UseContext extends ContextRecord = any>(key: string, factory: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UseControllers, Controllers>, DefaultIfAny<UseContext, Context>>) => Controller): ConditionalReturn<DefaultIfAny<UseModules, Modules>, RequiredControllerModules<Controller>, DefaultIfAny<UseLayers, Layers>, RequiredControllerLayers<Controller>, DefaultIfAny<UseContext, Context>, RequiredControllerContext<Controller>, this>;
    /**
     * Adds a context property to this builder. When the builder compiles its map, all added properties will be available
     * on the context. Properties are created on the context in the order they were added to the builder, and property
     * factories have access to previously created properties on the context. If an existing property has been added to
     * this builder with the same key, it will be replaced.
     * @param key The key of the property to add.
     * @param factory A function which creates the value of the property.
     * @returns This builder, after the context property has been added.
     */
    withContext<UseContext extends ContextRecord = any>(key: Exclude<string, keyof MapSystemContext>, factory: (context: MapSystemContext<Record<never, never>, Record<never, never>, Record<never, never>, DefaultIfAny<UseContext, Context>>) => any): this;
    /**
     * Configures this builder to execute a callback function immediately after it is finished compiling a map. If an
     * existing callback has been added to this builder with the same key, it will be replaced.
     * @param key The key of the callback.
     * @param callback The callback function to add.
     * @returns This builder, after the callback has been added.
     */
    withInit<UseModules extends ModuleRecord = any, UseLayers extends LayerRecord = any, UseControllers extends ControllerRecord = any, UseContext extends ContextRecord = any>(key: string, callback: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UseControllers, Controllers>, DefaultIfAny<UseContext, Context>>) => void): this;
    /**
     * Assigns an order value to a layer. Layers with a lower assigned order will be attached before and appear below
     * layers with greater assigned order values.
     * @param key The key of the layer to which to assign the order value.
     * @param order The order value to assign.
     * @returns This builder, after the order value has been assigned.
     */
    withLayerOrder(key: keyof Layers & string, order: number): this;
    /**
     * Configures this builder to add a controller which maintains a list of bindings from source to target
     * subscribables.
     * @param key The key of the controller.
     * @param bindings The bindings to maintain.
     * @param onDestroy A function to execute when the controller is destroyed.
     * @returns This builder, after it has been configured.
     */
    withBindings<UseModules extends ModuleRecord = any, UseLayers extends LayerRecord = any, UseContext extends ContextRecord = any>(key: string, bindings: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, EmptyRecord, DefaultIfAny<UseContext, Context>>) => Iterable<MapBinding>, onDestroy?: () => void): this;
    /**
     * Configures this builder to generate a map which is updated at a regular frequency based on event bus clock events.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'updateFreq': Subscribable<number>`
     *
     * Controllers:
     * * `[MapSystemKeys.ClockUpdate]: MapClockUpdateController`.
     * @param updateFreq The map's update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withClockUpdate(updateFreq: number | Subscribable<number>): this;
    /**
     * Configures this builder to add a resource moderator for control of the map's projection target.
     *
     * Adds the context property `[MapSystemKeys.TargetControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withTargetControlModerator(): this;
    /**
     * Configures this builder to add a resource moderator for control of the map's rotation.
     *
     * Adds the context property `[MapSystemKeys.RotationControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRotationControlModerator(): this;
    /**
     * Configures this builder to add a resource moderator for control of the map's range.
     *
     * Adds the context property `[MapSystemKeys.RangeControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRangeControlModerator(): this;
    /**
     * Configures this builder to generate a map whose projection target follows the player airplane. The follow airplane
     * behavior will be active if and only if the controller owns the projection target control resource. The
     * controller's priority for the resource is `0`.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TargetControl]: ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`
     *
     * Controllers:
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneController`
     * @returns This builder, after it has been configured.
     */
    withFollowAirplane(): this;
    /**
     * Configures this builder to generate a map which supports common rotation behavior. The rotation behavior will be
     * active if and only if the controller owns the rotation control resource. The controller's priority for the
     * resource is `0`.
     *
     * Requires the module `'ownAirplaneProps': MapOwnAirplanePropsModule` to support player airplane-derived rotation
     * behavior, such as Heading Up and Track Up.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'[MapSystemKeys.RotationControl]': ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.Rotation]: MapRotationModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Rotation]: MapRotationController`
     * @returns This builder, after it has been configured.
     */
    withRotation(): this;
    /**
     * Configures this builder to generate a map which displays an icon depicting the position of the player airplane.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule`
     *
     * Layers:
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneLayer`
     * @param iconSize The size of the icon, in pixels.
     * @param iconFilePath The path to the icon's image asset, or a subscribable which provides it.
     * @param iconAnchor The point on the icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with `[0, 0]` at the
     * top left and `[1, 1]` at the bottom right.
     * @param cssClass The CSS class(es) to apply to the root of the airplane icon layer.
     * @param order The order assigned to the icon layer. Layers with lower assigned order will be attached to the map
     * before and appear below layers with greater assigned order values. Defaults to the number of layers already added
     * to this builder.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIcon(iconSize: number | Subscribable<number>, iconFilePath: string | Subscribable<string>, iconAnchor: ReadonlyFloat64Array | Subscribable<ReadonlyFloat64Array>, cssClass?: string | SubscribableSet<string>, order?: number): this;
    /**
     * Configures this builder to add a controller which controls and optimizes the orientation of the own airplane icon
     * in response to a desired orientation and the map rotation type. If the desired orientation matches the map
     * rotation (e.g. both Heading Up), the icon orientation is set to Map Up; otherwise the orientation is set to the
     * desired orientation.
     *
     * Requires the modules `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule` and
     * `[MapSystemKeys.Rotation]: MapRotationModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneIconOrientation]: MapOwnAirplaneIconOrientationController`.
     * @param desiredOrientation The desired orientation of the own airplane icon.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIconOrientation<UseModules = any>(desiredOrientation: MapOwnAirplaneIconOrientation | Subscribable<MapOwnAirplaneIconOrientation>): ConditionalReturn<DefaultIfAny<UseModules, Modules>, MapOwnAirplaneIconOrientationControllerModules, any, any, any, any, this>;
    /**
     * Configures this builder to bind properties in an added {@link MapOwnAirplanePropsModule} to data derived from
     * event bus events.
     *
     * Requires the module `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsController`.
     * @param properties The properties to bind.
     * @param updateFreq The update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplanePropBindings<UseModules = any>(properties: Iterable<MapOwnAirplanePropsKey>, updateFreq: number | Subscribable<number>): ConditionalReturn<DefaultIfAny<UseModules, Modules>, MapOwnAirplanePropsControllerModules, any, any, any, any, this>;
    /**
     * Configures this builder to add a module describing the player airplane's autopilot properties, and optionally
     * binds the module's properties to data received over the event bus.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsModule`
     *
     * Controllers:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsController` (optional)
     * @param propertiesToBind Properties on the autopilot module to bind to data received over the event bus.
     * @param updateFreq The update frequency, in hertz, of the data bindings, or a subscribable which provides it. If
     * not defined, the data bindings will update every frame. Ignored if `propertiesToBind` is undefined.
     * @returns This builder, after it has been configured.
     */
    withAutopilotProps(propertiesToBind?: Iterable<MapAutopilotPropsKey>, updateFreq?: number | Subscribable<number>): this;
    /**
     * Configures this builder to generate a map which includes a layer displaying text.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     *
     * Layers:
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param enableCulling Whether to enable text culling. Defaults to `false`.
     * @param order The order value to assign to the text layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to this builder.
     * @param cssClass The CSS class(es) to apply to the text layer.
     * @returns This builder, after it has been configured.
     */
    withTextLayer(enableCulling: boolean, order?: number, cssClass?: string | SubscribableSet<string>): this;
    /**
     * Configures this builder to generate a map which displays Bing Map terrain and weather.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.TerrainColors]: MapTerrainColorsModule`
     * * `[MapSystemKeys.Weather]: MapWxrModule`
     *
     * Layers:
     * * `[MapSystemKeys.Bing]: MapBingLayer`
     * @param bingId The ID to assign to the Bing Map instance bound to the layer.
     * @param delay The delay, in milliseconds, to wait after the Bing layer has been rendered before attempting to bind
     * a Bing Map instance.
     * @param mode The mode of the map, optional. If omitted, will be EBingMode.PLANE.
     * @param order The order value to assign to the Bing layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @param cssClass The CSS class(es) to apply to the root of the map bing layer.
     * @returns This builder, after it has been configured.
     */
    withBing(bingId: string, delay?: number, mode?: EBingMode, order?: number, cssClass?: string | SubscribableSet<string>): this;
    /**
     * Configures this builder to generate a map which uses a {@link MapSystemWaypointsRenderer} to render waypoints.
     *
     * Requires the `[MapSystemKeys.TextManager]: MapCullableTextLabelManager` context property.
     *
     * Adds the `[MapSystemKeys.WaypointRenderer]: MapSystemWaypointsRenderer` context property.
     * @returns This builder, after it has been configured.
     */
    withWaypoints<UseContext = any>(): ConditionalReturn<any, any, any, any, DefaultIfAny<UseContext, Context>, {
        [MapSystemKeys.TextManager]: MapCullableTextLabelManager;
    }, this>;
    /**
     * Configures this builder to generate a map which displays waypoints near the map center or target. Waypoints
     * displayed in this manner are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     *
     * Modules:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointDisplayModule`
     *
     * Layers:
     * * `[MapSystemKeys.NearestWaypoints]: MapSystemWaypointsLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param configure A function to configure the waypoint display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the waypoint layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the root of the nearest waypoints layer.
     * @returns This builder, after it has been configured.
     */
    withNearestWaypoints(configure: (builder: WaypointDisplayBuilder) => void, enableTextCulling?: boolean, order?: number, cssClass?: string | SubscribableSet<string>): this;
    /**
     * Configures this builder to generate a map which displays a flight plan. Waypoints displayed as part of the flight
     * plan are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.FlightPlanner]: FlightPlanner`
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     * * `[MapSystemKeys.FlightPathRenderer]: MapSystemPlanRenderer`
     *
     * Modules:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanModule`
     *
     * Layers:
     * * `` `${[MapSystemKeys.FlightPlan]}${planIndex}`: MapSystemFlightPlanLayer ``
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanController`
     * @param configure A function to configure the waypoint display.
     * @param flightPlanner The flight planner.
     * @param planIndex The index of the flight plan to display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the plan layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the flight plan canvas elements.
     * @returns This builder, after it has been configured.
     */
    withFlightPlan(configure: (builder: FlightPlanDisplayBuilder) => void, flightPlanner: FlightPlanner, planIndex: number, enableTextCulling?: boolean, order?: number, cssClass?: string | SubscribableSet<string>): this;
    /**
     * Configures this builder to generate a map which displays airspaces.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.AirspaceManager]: GenericAirspaceRenderManager`
     *
     * Modules:
     * * `[MapSystemKeys.Airspace]: MapAirspaceModule`
     *
     * Layers:
     * * `[MapSystemKeys.Airspace]: MapAirspaceLayer`
     * @param cache The airspace cache to use to store airspaces retrieved for rendering.
     * @param showTypes The airspace show types to define in the airspace module. Each show type will be assigned a
     * {@link Subject} in the `show` property of the module. The Subject controls the visibility of airspace types
     * included in its show type. Airspace types that are not included in any defined show type will never be displayed.
     * @param selectRenderer A function which selects a {@link MapAirspaceRenderer}
     * @param renderOrder A function which determines the rendering order of airspaces. The function should return a
     * negative number when airspace `a` should be rendered before (below) airspace `b`, a positive number when airspace
     * `a` should be rendered after (above) airspace `b`, and `0` when the relative render order of the two airspaces
     * does not matter. If not defined, there will be no guarantee on the order in which airspaces are rendered.
     * @param options Options for the airspace layer. Option defaults are as follows:
     * * `maxSearchRadius`: 10 nautical miles
     * * `maxSearchItemCount`: 100
     * * `searchDebounceDelay`: 500 (milliseconds)
     * * `renderTimeBudget`: 0.2 (milliseconds)
     * @param order The order to assign to the airspace layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withAirspaces(cache: LodBoundaryCache, showTypes: MapAirspaceShowTypes, selectRenderer: (airspace: LodBoundary) => MapAirspaceRenderer, renderOrder?: (a: LodBoundary, b: LodBoundary) => number, options?: Partial<Pick<MapAirspaceLayerProps, 'maxSearchRadius' | 'maxSearchItemCount' | 'searchDebounceDelay' | 'renderTimeBudget'>>, order?: number): this;
    /**
     * Configures this builder to generate a map which displays TCAS intruders.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.Traffic]: MapTrafficModule`
     *
     * Layers:
     * * `[MapSystemKeys.Traffic]: MapSystemTrafficLayer`
     * @param tcas The TCAS used by the traffic display.
     * @param iconFactory A function which creates intruder icons for the traffic display.
     * @param initCanvasStyles A function which initializes global canvas styles for the traffic display.
     * @param offScaleOobOptions A function which generates options for handling off-scale and out-of-bounds intruders.
     * @param order The order to assign to the traffic layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the root of the traffic component.
     * @returns This builder, after it has been configured.
     */
    withTraffic<UseModules extends ModuleRecord = any, UseLayers extends LayerRecord = any, UserControllers extends ControllerRecord = any, UseContext extends ContextRecord = any>(tcas: Tcas, iconFactory: MapTrafficIntruderIconFactory<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UserControllers, Controllers>, DefaultIfAny<UseContext, Context>>, initCanvasStyles?: (context: CanvasRenderingContext2D) => void, offScaleOobOptions?: (context: MapSystemContext<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UserControllers, Controllers>, DefaultIfAny<UseContext, Context>>) => TrafficOffScaleOobOptions, order?: number, cssClass?: string | SubscribableSet<string>): this;
    /**
     * Configures this builder using a custom build step.
     * @param builder A function which defines a custom build step.
     * @param args Arguments to pass to the custom build function.
     * @returns This builder, after it has been configured.
     */
    with<Builder extends MapSystemCustomBuilder<any[], any, any>, UseModules = any, UseLayers extends LayerRecord = any, UseContext = any>(builder: Builder, ...args: CustomBuilderArgs<Builder>): ConditionalReturn<DefaultIfAny<UseModules, Modules>, RequiredCustomBuilderModules<Builder>, DefaultIfAny<UseLayers, Layers>, RequiredCustomBuilderLayers<Builder>, DefaultIfAny<UseContext, Context>, RequiredCustomBuilderContext<Builder>, this>;
    /**
     * Compiles a map. The compiled map consists of a map context, a rendered map (as a VNode), and a node reference to
     * the rendered map component.
     *
     * The compiled map will be bound to a model (accessible through the map context) which contains all the modules
     * added to this builder.
     *
     * The map will also contain all layers added to this builder, with layers assigned lower order values appearing
     * below layers assigned greater order values. The layers can be retrieved by their keys from the map context.
     *
     * All controllers added to this builder will be created with the map and hooked up to the map's lifecycle callbacks.
     * The controllers can be retrieved by their keys from the map context.
     * @param cssClass The CSS class(es) to apply to the root of the rendered map component.
     * @returns A compiled map.
     */
    build<UseModules extends ModuleRecord = any, UseLayers extends LayerRecord = any, UseControllers extends ControllerRecord = any, UseContext extends ContextRecord = any>(cssClass?: string | SubscribableSet<string>): CompiledMapSystem<DefaultIfAny<UseModules, Modules>, DefaultIfAny<UseLayers, Layers>, DefaultIfAny<UseControllers, Controllers>, DefaultIfAny<UseContext, Context>>;
    /**
     * Builds a new map context. The map context will be initialized with all context properties and modules added to
     * this builder.
     * @returns The new map context.
     */
    protected buildContext(): MutableMapContext<MapSystemContext<any, any, any, any>>;
}

/**
 * Callbacks supported by MapSystemGenericController.
 */
declare type MapSystemGenericControllerCallbacks<Context extends MapSystemContext<any, any, any, any>> = {
    /** */
    onAfterMapRender?: (context: Context) => void;
    /** */
    onDeadZoneChanged?: (context: Context, deadZone: ReadonlyFloat64Array) => void;
    /** */
    onMapProjectionChanged?: (context: Context, mapProjection: MapProjection, changeFlags: number) => void;
    /** */
    onBeforeUpdated?: (context: Context, time: number, elapsed: number) => void;
    /** */
    onAfterUpdated?: (context: Context, time: number, elapsed: number) => void;
    /** */
    onWake?: (context: Context) => void;
    /** */
    onSleep?: (context: Context) => void;
    /** */
    onMapDestroyed?: (context: Context) => void;
    /** */
    onDestroyed?: (context: Context) => void;
};
/**
 * A map controller which delegates its behavior to injected callback functions.
 */
declare class MapSystemGenericController<Modules extends ModuleRecord = any, Layers extends LayerRecord = any, Controllers extends ControllerRecord = any, Context extends ContextRecord = any> extends MapSystemController<Modules, Layers, Controllers, Context> {
    private readonly callbacks;
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param callbacks The callback functions to which this controller delegates its behavior.
     */
    constructor(context: MapSystemContext<Modules, Layers, any, Context>, callbacks: MapSystemGenericControllerCallbacks<MapSystemContext<Modules, Layers, Controllers, Context>>);
    /** @inheritdoc */
    onAfterMapRender(): void;
    /** @inheritdoc */
    onDeadZoneChanged(deadZone: ReadonlyFloat64Array): void;
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection: MapProjection, changeFlags: number): void;
    /** @inheritdoc */
    onBeforeUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    onAfterUpdated(time: number, elapsed: number): void;
    /** @inheritdoc */
    onWake(): void;
    /** @inheritdoc */
    onSleep(): void;
    /** @inheritdoc */
    onMapDestroyed(): void;
    /** @inheritdoc */
    destroy(): void;
}

/**
 * Utility methods related to MapSystem.
 */
declare class MapSystemUtils {
    /**
     * Converts a nominal relative projected x coordinate to a true relative projected x coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelX A nominal relative projected x coordinate.
     * @param width The width of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected x coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeX(nominalRelX: number, width: number, deadZone: ReadonlyFloat64Array): number;
    /**
     * Converts a nominal relative projected y coordinate to a true relative projected y coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelY A nominal relative projected y coordinate.
     * @param height The height of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected y coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeY(nominalRelY: number, height: number, deadZone: ReadonlyFloat64Array): number;
    /**
     * Converts nominal relative projected coordinates to a true relative projected coordinates. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominal Nominal relative projected coordinates.
     * @param size The size of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @param out The vector to which to write the result.
     * @returns The true relative projected coordinates that are equivalent to the specified nominal coordinates.
     */
    static nominalToTrueRelativeXY(nominal: ReadonlyFloat64Array, size: ReadonlyFloat64Array, deadZone: ReadonlyFloat64Array, out: Float64Array): Float64Array;
}

/**
 * Waypoint roles used by the map system waypoint display system.
 */
declare enum MapSystemWaypointRoles {
    /** The normal waypoint display role. */
    Normal = "Normal",
    /** The waypoint role for displaying waypoints along the flight plan. */
    FlightPlan = "FlightPlan"
}

/**
 * Component props for the SynVisComponent.
 */
interface SynVisProps extends ComponentProps {
    /** The unique ID to assign to the component's bound Bing instance. */
    bingId: string;
    /** The amount of time, in milliseconds, to delay binding the component's Bing instance. Defaults to 0. */
    bingDelay?: number;
    /**
     * A subscribable which provides the internal resolution for the Bing component.
     */
    resolution: Subscribable<ReadonlyFloat64Array>;
    /**
     * The earth colors for the display. Index 0 defines the water color, and indexes 1 to the end of the array define
     * the terrain colors. If not defined, all colors default to black.
     */
    earthColors?: SubscribableArray<number>;
    /**
     * The elevation range over which to assign the earth terrain colors, as `[minimum, maximum]` in feet. The terrain
     * colors are assigned at regular intervals over the entire elevation range, starting with the first terrain color at
     * the minimum elevation and ending with the last terrain color at the maximum elevation. Terrain below and above the
     * minimum and maximum elevation are assigned the first and last terrain colors, respectively. Defaults to
     * `[0, 30000]`.
     */
    earthColorsElevationRange?: Subscribable<ReadonlyFloat64Array>;
    /**
     * A subscribable which provides the sky color.
     */
    skyColor: Subscribable<number>;
    /** CSS class(es) to add to the root of the component. */
    class?: string | SubscribableSet<string>;
}
/**
 * A synthetic vision display.
 */
declare class SynVisComponent extends DisplayComponent<SynVisProps> {
    protected readonly bingRef: NodeReference<HTMLImageElement>;
    /**
     * A callback which is called when the Bing component is bound.
     */
    protected onBingBound: () => void;
    /**
     * Renders the syn vis component.
     * @returns A component VNode.
     */
    render(): VNode;
}

/** The acceptable priority types for a given warning. */
declare enum WarningType {
    Warning = 0,
    Caution = 1,
    Test = 2,
    SoundOnly = 3
}
/** The main logic for a system warning. */
declare class Warning {
    /** The category of the warnining. */
    readonly type: WarningType;
    /** The short-form text. */
    readonly shortText?: string;
    /** The long-form text. */
    readonly longText?: string;
    /** The name of a sound to play along with the visual warning. */
    readonly soundId?: string;
    /** The XML logic element triggering this warning if true. */
    readonly condition: CompositeLogicXMLElement;
    /** Does this only fire once? */
    readonly once?: boolean;
    /** If a one-shot, has this been triggered already? */
    private _triggered;
    /** The event ID for this sound. */
    private _soundEventId?;
    /**
     * Creates an instance of a Warning.
     * @param type The type of warning this is.
     * @param condition An XML logic element with the trigger logic.
     * @param shortText The warning message in short form.
     * @param longText The warning message in long form.
     * @param soundId The sound name to use with this warning.
     * @param once True if this warning only fires once
     */
    constructor(type: WarningType, condition: CompositeLogicXMLElement, shortText?: string, longText?: string, soundId?: string, once?: boolean);
    /**
     * Whether or not we have any text at all.
     * @returns True if any non-empty text strings are set.
     */
    get hasText(): boolean;
    /**
     * The alert is being fired, take action.
     */
    trigger(): void;
    /**
     * A text description for the warning, for debugging purposes.
     * @returns A string
     */
    get description(): string;
    /**
     * Whether or not the warning has been triggered in this session.
     * @returns True if the warning has been triggered.
     */
    get triggered(): boolean;
    /**
     * Can this alert fire?
     * @returns True if the current configuration allows the alert to fire.
     */
    get canTrigger(): boolean;
    /**
     * The event ID Coherent returns when this sound has been played.
     * @returns A Name_Z based on the sound ID.
     */
    get eventId(): Name_Z | undefined;
}
/** The basic component for handling warning logic. */
declare class WarningManager {
    private warnings;
    private warnActiveStates;
    private logicHost;
    private textCb;
    private soundCb?;
    private curSndIdx;
    private curTxtIdx;
    /**
     * Create a WarningManager.
     * @param warnings An array of warnings to manage.
     * @param logicHost An event bus.
     * @param textCb A callback to display new warning text.
     * @param soundCb A callback to play an instrument sound from a sound ID.
     */
    constructor(warnings: Array<Warning>, logicHost: CompositeLogicXMLHost, textCb: (warning: Warning | undefined) => void, soundCb?: (warning: Warning, active: boolean) => void);
    /**
     * Handle a warning firing.  This is rather complex, but it basically keeps
     * track of every warning that is active, both for text and for sound, and
     * makes sure that the highest priority version of each is played or
     * displayed, masking and restoring lower priority warnings as needed.
     * @param warnIndex The index of our warnings array that's firing.
     * @param active 1 if the warning is active, 0 otherwise.
     */
    private handleWarning;
}

/** Create a list of system warnings. */
declare class XMLWarningFactory {
    private instrument;
    /**
     * Create an XMLWarningFactory.
     * @param instrument The instrument that the warnings run in.
     */
    constructor(instrument: BaseInstrument);
    /**
     * Parse a panel.xml configuration to create a list of warnings.  The warning
     * priority is defined by their order in panel.xml, with higher priority
     * warnings coming sooner in the file.
     * @param document The configuration as an XML document.
     * @returns An array of Warnings
     */
    parseConfig(document: Document): Array<Warning>;
}

/** Events relating to the alert system. */
interface SystemAlertEvents {
    /** An event to fire with an alert index when a new alert arrives. */
    alert_triggered: number;
    /** An event to fire with an alert index when an existing alert is cleared. */
    alert_cleared: number;
    /** An event to fire when a master acknowledge is executed. */
    master_acknowledge: AnnunciationType;
}
/**
 * A publisher for system alert messages.  This publisher works primarily with integers
 * that are indicies into an array of annunciation messages for the host instrument
 * as provided by the panel.xml configuration parser.
 * */
declare class SystemAlertPublisher extends BasePublisher<SystemAlertEvents> {
    /**
     * Publish an alert event.
     * @param event The event from SystemAlertEvents.
     * @param value The value for the event.
     */
    publishAlert<K extends keyof SystemAlertEvents>(event: K, value: SystemAlertEvents[K]): void;
}

/** A CAS alert manager. */
declare class SystemAlertManager {
    private bus;
    private logicHost;
    private soundPublisher;
    private alertPublisher;
    private warningSoundId;
    private cautionSoundId;
    private initialized;
    private annunciations;
    private activeAnns;
    /**
     * Create a SystemAlertManager instance.
     * @param bus The event bus
     * @param annunciations An array of the system annunciations to monitor
     * @param logicHost An actively updated composite logic host.
     * @param warningSoundId The identifier of the warning sound, if other than default
     * @param cautionSoundId The identifier of the caution sound, if other than default
     */
    constructor(bus: EventBus, annunciations: Annunciation[], logicHost: CompositeLogicXMLHost, warningSoundId?: string, cautionSoundId?: string);
    /**
     * Set both sets of simvars relevant to a master caution or warning status.
     * @param type The type of the status to set
     * @param active Whether or not the status is active
     */
    private setMasterStatus;
    /**
     * Handle an annunciation going active.
     * @param idx The index of the annunciations array for the annunciation.
     */
    protected handleAnnunciationActive(idx: number): void;
    /**
     * Handle an annunciation going inactive.
     * @param idx The index of the annunciations array for the annunciation.
     */
    protected handleAnnunciationInactive(idx: number): void;
    /**
     * Handle a master warning or caution acknowledgement.
     * @param type The type of alert to acknowledge.
     */
    protected handleAcknowledgement(type: AnnunciationType): void;
    /**
     * See if there is still an active, unacked annunciation of the given type.
     * @param type The annunciation type to check for.
     * @returns True if there is an active, unacked annunciation of the given type, false otherwise.
     */
    protected checkForActiveType(type: AnnunciationType): boolean;
    /**
     * Add an annunciation to the active list if it's new, or update it if already there.
     * @param idx The index of the annunciations array for the annunciation.
     * @returns The index of the added or updated annunciation in the active list.
     */
    protected addOrUpdateAnnunciation(idx: number): number;
    /**
     * Remove an annunciation from the active list if present.
     * @param idx The index of the annunciations array for the annunciation.
     * @returns True if the annunciation was removed, false otherwise.
     */
    protected removeAnnunciation(idx: number): boolean;
}

/**
 * The state of a given plane director.
 */
declare enum DirectorState {
    /** The plane director is not currently armed or active. */
    Inactive = "Inactive",
    /** The plane director is currently armed. */
    Armed = "Armed",
    /** The plane director is currently active. */
    Active = "Active"
}
/**
 * An autopilot plane director guidance mode.
 */
interface PlaneDirector {
    /**
     * Activates the guidance mode.
     */
    activate(): void;
    /**
     * Arms the guidance mode.
     */
    arm(): void;
    /**
     * Deactivates the guidance mode.
     */
    deactivate(): void;
    /**
     * Updates the guidance mode control loops.
     */
    update(): void;
    /**
     * A callback called when a mode signals it should
     * be activated.
     */
    onActivate?: () => void;
    /**
     * A callback called when a mode signals it should
     * be armed.
     */
    onArm?: () => void;
    /**
     * A callback called when a mode signals it should
     * be deactivated.
     */
    onDeactivate?: () => void;
    /** The current director state. */
    state: DirectorState;
}
/**
 * A director that handles OBS Lateral Navigation.
 */
interface ObsDirector extends PlaneDirector {
    /** Whether or not OBS mode is active. */
    readonly obsActive: boolean;
    /**
     * Sets the flight plan leg whose terminator defines this director's OBS fix.
     * @param index The global leg index of the leg.
     * @param leg The leg to track.
     */
    setLeg(index: number, leg: LegDefinition | null): void;
    /** Whether or not OBS mode can be activated currently. */
    canActivate(): boolean;
    /** Starts tracking the OBS course. */
    startTracking(): void;
    /** Stops tracking the OBS course. */
    stopTracking(): void;
}
/**
 * A plane director that provides no behavior.
 */
declare class EmptyDirector implements PlaneDirector {
    /** No-op. */
    activate(): void;
    /** No-op. */
    deactivate(): void;
    /** No-op. */
    update(): void;
    /** No-op. */
    onActivate: () => void;
    /** No-op */
    onArm: () => void;
    /** No-op. */
    arm(): void;
    state: DirectorState;
    /** An instance of the empty plane director. */
    static instance: EmptyDirector;
}

/**
 * An interface that describes a manager for dictating nav to nav transfer behavior
 * and criteria.
 */
interface NavToNavManager {
    /**
     * A callback called when the nav transfer has been completed.
     */
    onTransferred: () => void;
    /**
     * A method that determines whether or not nav mode can be armed
     * when approach mode is attempted to be armed.
     * @returns True if it can be armed, false otherwise.
     */
    canLocArm(): boolean;
    /**
     * A method that determines whether or not an armed loc nav mode can
     * become active.
     * @returns True if it can become active, false otherwise.
     */
    canLocActivate(): boolean;
}

/**
 * The current vertical navigation state.
 */
declare enum VNavState {
    /** VNAV Disabled. */
    Disabled = 0,
    /** VNAV Enabled and Inactive. */
    Enabled_Inactive = 1,
    /** VNAV Enabled and Active. */
    Enabled_Active = 2
}
/**
 * The current VNAV path mode.
 */
declare enum VNavPathMode {
    /** VNAV path is not active. */
    None = 0,
    /** VNAV path is armed for capture. */
    PathArmed = 1,
    /** VNAV path is actively navigating. */
    PathActive = 2,
    /** The current VNAV path is not valid. */
    PathInvalid = 3
}
/**
 * The current Approach Guidance Mode.
 */
declare enum ApproachGuidanceMode {
    /** VNAV is not currently following approach guidance. */
    None = 0,
    /** VNAV has armed ILS glideslope guidance for capture. */
    GSArmed = 1,
    /** VNAV is actively following ILS glideslope guidance. */
    GSActive = 2,
    /** VNAV RNAV glidepath guidance is armed for capture. */
    GPArmed = 3,
    /** VNAV is actively follow RNAV glidepath guidance. */
    GPActive = 4
}
/**
 * The current VNAV altitude capture type.
 */
declare enum VNavAltCaptureType {
    /** Altitude capture is not armed. */
    None = 0,
    /** Altitude will capture the selected altitude. */
    Selected = 1,
    /** Altitude will capture the VANV target altitude. */
    VNAV = 2
}
/**
 * A Vertical Flight Plan cooresponding to a lateral flight plan.
 */
interface VerticalFlightPlan {
    /** The Flight Plan Index */
    planIndex: number;
    /** The number of legs in this flight plan. */
    length: number;
    /** The Flight Plan Segments in the VerticalFlightPlan (should always be the same as the lateral plan) */
    segments: VNavPlanSegment[];
    /** The VNav Constraints in this Vertical Flight Plan */
    constraints: VNavConstraint[];
    /** The global leg index of the destination leg, or undefined */
    destLegIndex: number | undefined;
    /** The global leg index of the FAF leg, or undefined */
    fafLegIndex: number | undefined;
    /** The global leg index of the first descent constraint, or undefined */
    firstDescentConstraintLegIndex: number | undefined;
    /** The global leg index of the last descent constraint, or undefined */
    lastDescentConstraintLegIndex: number | undefined;
    /** The global leg index of the first missed approach leg, or undefined */
    missedApproachStartIndex: number | undefined;
    /** The global leg index of the currently active vertical direct leg, or undefined */
    verticalDirectIndex: number | undefined;
    /**
     * The flight path angle, in degrees, of this plan's vertical direct constraint, or `undefined` if there is no
     * vertical direct constraint. Positive angles represent descending paths.
     */
    verticalDirectFpa: number | undefined;
    /** The current along leg distance for the active lateral leg in this flight plan */
    currentAlongLegDistance: number | undefined;
    /** Whether the corresponding lateral flight plan has changed since the last time this plan was calculated. */
    planChanged: boolean;
}
/**
 * Details about the next TOD and BOD.
 */
interface TodBodDetails {
    /**
     * The global index of the leg that contains the next BOD, or -1 if there is no BOD. The next BOD is defined as the
     * next point in the flight path including or after the active leg where the VNAV profile transitions from a descent
     * to a level-off, discontinuity, or the end of the flight path. The BOD is always located at the end of its
     * containing leg.
     */
    bodLegIndex: number;
    /**
     * The global index of the leg that contains the TOD associated with the next BOD, or -1 if there is no such TOD. The
     * TOD is defined as the point along the flight path at which the aircraft will intercept the VNAV profile continuing
     * to the next BOD if it continues to fly level at its current altitude.
     */
    todLegIndex: number;
    /** The distance from the TOD to the end of its containing leg, in meters. */
    todLegDistance: number;
    /** The distance along the flight path from the airplane's present position to the TOD, in meters. */
    distanceFromTod: number;
    /** The distance along the flight path from the airplane's present position to the BOD, in meters. */
    distanceFromBod: number;
    /** The global index of the leg that contains the current VNAV constraint. */
    currentConstraintLegIndex: number;
}
/**
 * Details about the next TOC and BOC.
 */
interface TocBocDetails {
    /**
     * The global index of the leg that contains the next BOC, or -1 if there is no BOC. The BOC is always located at the
     * beginning of its containing leg.
     */
    bocLegIndex: number;
    /** The global index of the leg that contains the next TOC, or -1 if there is no such TOC. */
    tocLegIndex: number;
    /** The distance from the TOC to the end of its containing leg, in meters. */
    tocLegDistance: number;
    /** The distance along the flight path from the airplane's present position to the TOC, in meters. */
    distanceFromToc: number;
    /** The distance along the flight path from the airplane's present position to the BOC, in meters. */
    distanceFromBoc: number;
    /** The index of the vertical constraint defining the TOC altitude, or -1 if there is no TOC. */
    tocConstraintIndex: number;
    /** The TOC altitude in meters. A negative value indicates there is no TOC. */
    tocAltitude: number;
}
/**
 * A leg in the calculated Vertical Flight Plan.
 */
interface VNavLeg {
    /** The index of the flight plan segment. */
    segmentIndex: number;
    /** The index of the leg within the plan segment. */
    legIndex: number;
    /** The name of the leg. */
    name: string;
    /** The fpa of the leg in degrees. Always a positive number. */
    fpa: number;
    /** The distance of the leg in meters. */
    distance: number;
    /** Whether the leg is eligible for VNAV. */
    isEligible: boolean;
    /** If the leg is a bottom of descent. */
    isBod: boolean;
    /** Whether or not the altitude provided is advisory. */
    isAdvisory: boolean;
    /** The altitude that the leg ends at in meters. */
    altitude: number;
    /** Whether or not the constraint at this leg is user defined. */
    isUserDefined: boolean;
    /** Whether or not the leg is a direct to target. */
    isDirectToTarget: boolean;
    /** The constrant altitude assigned to this leg that is invalid, in meters, if one exists. */
    invalidConstraintAltitude?: number;
}
/**
 * A Vertical Flight Plan Constraint.
 */
interface VNavConstraint {
    /** The global leg index for the constraint. */
    index: number;
    /** The minimum altitude of the constraint in meters, or negative infinity if the constraint has no minimum altitude. */
    minAltitude: number;
    /** The max altitude of the constraint in meters, or positive infinity if the constraint has no maximum altitude. */
    maxAltitude: number;
    /** The target altitude of the constraint in meters. */
    targetAltitude: number;
    /**
     * Whether or not this constraint is a target that will be held at
     * during a level-off or whether it will instead be passed through
     * with no level off.
     */
    isTarget: boolean;
    /** Whether or not this constraint is the last constraint prior to a MANSEQ or other VNAV ineligible leg type. */
    isPathEnd: boolean;
    /** If this constraint isPathEnd, what is the leg index of the next vnav eligible leg. */
    nextVnavEligibleLegIndex?: number;
    /** The name of the leg at this constraint. */
    name: string;
    /** The total distance of the legs that make up this constriant segment in meters. */
    distance: number;
    /** The flight path angle to take through the legs in this constraint in degrees. Always a positive number. */
    fpa: number;
    /** The legs contained in this constraint segment. */
    legs: VNavLeg[];
    /** The type of constraint segment. */
    type: 'climb' | 'descent' | 'direct' | 'manual' | 'missed' | 'dest';
    /** Whether or not this constraint is beyond the FAF. */
    isBeyondFaf: boolean;
}
/**
 * A segment in the Vertical Flight Plan.
 */
interface VNavPlanSegment {
    /** The index offset that the segment begins at. */
    offset: number;
    /** The VNAV legs contained in the segment. */
    legs: VNavLeg[];
}
/**
 * The current state of VNAV availability from the director.
 */
declare enum VNavAvailability {
    Available = "Available",
    InvalidLegs = "InvalidLegs"
}
/**
 * The current altitude constraint details including target altitude and type.
 */
declare type AltitudeConstraintDetails = {
    /** The type of this constraint. */
    type: Exclude<AltitudeRestrictionType, AltitudeRestrictionType.Between>;
    /** The altitude for this constraint, in feet. */
    altitude: number;
};
/**
 * The current speed constraint details including the currently applicable speed constraint (if any),
 * the next speed constraint (if any) and the distance to the next speed constraint (if any).
 */
declare type SpeedConstraintDetails = {
    /** The currently applicable speed constraint. */
    readonly currentSpeedConstraint: SpeedConstraint;
    /** The next applicable speed constraint. */
    readonly nextSpeedConstraint: SpeedConstraint;
    /** The distance to the next speed constraint, in NM. */
    readonly distanceToNextSpeedConstraint?: number;
};

/**
 * A Vertical Navigation Manager.
 */
interface VNavManager {
    /**
     * Sets the state of the manager.
     */
    setState(vnavState: VNavState): void;
    /**
     * Tries to activate the manager.
     */
    tryActivate(): void;
    /**
     * Tries to deactivate the manager.
     * @param newMode Is the new mode to set active in the Autopilot if Path Mode is currently active.
     */
    tryDeactivate(newMode?: APVerticalModes): void;
    /**
     * Updates the manager.
     */
    update(): void;
    /**
     * A callback called by the autopilot to check if a vertical mode can be activated.
     */
    canVerticalModeActivate: (mode: APVerticalModes) => boolean;
    /** A callback called when the APVNavPathDirector Deactivates. */
    onPathDirectorDeactivated: () => void;
    /**
     * A callback called by the autopilot to arm the supplied vertical mode.
     */
    armMode?: (mode: APVerticalModes) => void;
    /**
     * A callback called by the autopilot to activate the supplied vertical mode.
     */
    activateMode?: (mode: APVerticalModes) => void;
    /** A callback called when the manager is activated. */
    onActivate?: () => void;
    /** A callback called when the manager is deactivated. */
    onDeactivate?: () => void;
    /** The current manager state. */
    state: VNavState;
}

declare enum APVerticalModes {
    NONE = 0,
    PITCH = 1,
    VS = 2,
    FLC = 3,
    ALT = 4,
    PATH = 5,
    GP = 6,
    GS = 7,
    CAP = 8,
    TO = 9,
    GA = 10,
    FPA = 11,
    FLARE = 12
}
declare enum APLateralModes {
    NONE = 0,
    ROLL = 1,
    LEVEL = 2,
    GPSS = 3,
    HEADING = 4,
    VOR = 5,
    LOC = 6,
    BC = 7,
    ROLLOUT = 8,
    NAV = 9,
    TO = 10,
    GA = 11,
    HEADING_HOLD = 12,
    TRACK = 13,
    TRACK_HOLD = 14
}
declare enum APAltitudeModes {
    NONE = 0,
    ALTS = 1,
    ALTV = 2
}
/** AP Values Object */
declare type APValues = {
    /** The selected altitude, in feet. */
    readonly selectedAltitude: Subject<number>;
    /** The selected vertical speed target, in feet per minute. */
    readonly selectedVerticalSpeed: Subject<number>;
    /** The selected flight path angle target, in degrees */
    readonly selectedFlightPathAngle: Subject<number>;
    /** The selected indicated airspeed target, in knots. */
    readonly selectedIas: Subject<number>;
    /** The selected mach target. */
    readonly selectedMach: Subject<number>;
    /** Whether the selected airspeed target is in mach. */
    readonly isSelectedSpeedInMach: Subject<boolean>;
    /** The selected pitch target, in degrees. */
    readonly selectedPitch: Subject<number>;
    /** The maximum bank setting ID. */
    readonly maxBankId: Subject<number>;
    /** The maximum Bank Angle the autopilot may command in absolute degrees. */
    readonly maxBankAngle: Subject<number>;
    /** The selected heading, in degrees. */
    readonly selectedHeading: Subject<number>;
    /** The captured altitude, in feet. */
    readonly capturedAltitude: Subject<number>;
    /** Approach is Activated in Flight Plan */
    readonly approachIsActive: Subject<boolean>;
    /** The activated approach has an LPV GP */
    readonly approachHasGP: Subject<boolean>;
    /** The Nav 1 Radio is tuned to an ILS with a GS signal */
    readonly nav1HasGs: Subject<boolean>;
    /** The Nav 2 Radio is tuned to an ILS with a GS signal */
    readonly nav2HasGs: Subject<boolean>;
    /** The Nav 3 Radio is tuned to an ILS with a GS signal */
    readonly nav3HasGs: Subject<boolean>;
    /** The Nav 4 Radio is tuned to an ILS with a GS signal */
    readonly nav4HasGs: Subject<boolean>;
    /** The Active Lateral Mode */
    readonly lateralActive: Subject<APLateralModes>;
    /** The Active Vertical Mode */
    readonly verticalActive: Subject<APVerticalModes>;
    /** The Armed Lateral Mode */
    readonly lateralArmed: Subject<APLateralModes>;
    /** The Armed Vertical Mode */
    readonly verticalArmed: Subject<APVerticalModes>;
    /** The AP Approach Mode is on */
    readonly apApproachModeOn: Subject<boolean>;
    /** Returns whether nav to nav says that LOC can be armed. */
    navToNavLocArm?: () => boolean;
};
/**
 * An autopilot configuration.
 */
interface APConfig {
    /**
     * Creates the autopilot's VNAV Manager.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's VNAV Manager.
     */
    createVNavManager(apValues: APValues): VNavManager | undefined;
    /**
     * Creates the autopilot's nav-to-nav manager.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's nav-to-nav manager.
     */
    createNavToNavManager(apValues: APValues): NavToNavManager | undefined;
    /**
     * Creates the autopilot's variable bank manager.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's variable bank manager.
     */
    createVariableBankManager(apValues: APValues): Record<any, any> | undefined;
    /**
     * Creates the autopilot's VNAV Path mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's VNAV Path mode director.
     */
    createVNavPathDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's heading mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's heading mode director.
     */
    createHeadingDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's heading hold (level off and then capture heading)
     * @param apValues The autopilot's state values.
     * @returns The autopilot's heading hold director.
     */
    createHeadingHoldDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's track mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's heading mode director.
     */
    createTrackDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's track hold (level off and then capture track)
     * @param apValues The autopilot's state values.
     * @returns The autopilot's heading hold director.
     */
    createTrackHoldDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's roll mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's heading mode director.
     */
    createRollDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's wings level mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's wings level mode director.
     */
    createWingLevelerDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's GPS LNAV mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's GPS LNAV mode director.
     */
    createGpssDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's VOR mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's VOR mode director.
     */
    createVorDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's LOC mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's LOC mode director.
     */
    createLocDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's back-course mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's back-course mode director.
     */
    createBcDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's ROLLOUT mode director.
     * @returns The autopilot's ROLLOUT mode director.
     */
    createRolloutDirector(): PlaneDirector | undefined;
    /**
     * Creates the autopilot's pitch mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's pitch mode director.
     */
    createPitchDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's vertical speed mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's vertical speed mode director.
     */
    createVsDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's flight path angle mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's flight path angle mode director.
     */
    createFpaDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's flight level change mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's flight level change mode director.
     */
    createFlcDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's altitude hold mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's altitude hold mode director.
     */
    createAltHoldDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's altitude capture mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's altitude capture mode director.
     */
    createAltCapDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's GPS glidepath mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's GPS glidepath mode director.
     */
    createGpDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's ILS glideslope mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's ILS glideslope mode director.
     */
    createGsDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the auto land FLARE mode director.
     * @param apValues The autopilot's state values.
     * @returns The autopilot's FLARE mode director.
     */
    createFlareDirector(): PlaneDirector | undefined;
    /**
     * Creates the autopilot's vertical takeoff mode director (or combined vertical takeoff/go-around mode director).
     * @returns The autopilot's vertical takeoff mode director.
     */
    createToVerticalDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's vertical go-around mode director.
     * @returns The autopilot's vertical go-around mode director.
     */
    createGaVerticalDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's lateral takeoff mode director (or combined lateral takeoff/go-around mode director).
     * @returns The autopilot's lateral takeoff mode director.
     */
    createToLateralDirector(apValues: APValues): PlaneDirector | undefined;
    /**
     * Creates the autopilot's lateral go-around mode director.
     * @returns The autopilot's lateral go-around mode director.
     */
    createGaLateralDirector(apValues: APValues): PlaneDirector | undefined;
    /** The autopilot's default lateral mode. */
    defaultLateralMode: APLateralModes | (() => APLateralModes);
    /** The autopilot's default vertical mode. */
    defaultVerticalMode: APVerticalModes | (() => APVerticalModes);
    /** The default maximum bank angle the autopilot may command in degrees. */
    defaultMaxBankAngle: number;
    /** The altitude hold slot index to use. Defaults to 1 */
    altitudeHoldSlotIndex?: 1 | 2 | 3;
    /** The default altitude hold value set during init, defaults to 0 */
    altitudeHoldDefaultAltitude?: number;
    /** The heading hold slot index to use. Defaults to 1 */
    headingHoldSlotIndex?: 1 | 2 | 3;
}

declare enum APStates {
    None = 0,
    APActive = 1,
    YawDamper = 2,
    Heading = 4,
    Nav = 8,
    NavArmed = 16,
    Approach = 32,
    ApproachArmed = 64,
    Backcourse = 128,
    BackcourseArmed = 256,
    Alt = 512,
    AltS = 1024,
    AltV = 2048,
    VS = 4096,
    FLC = 8192,
    GP = 16384,
    GPArmed = 32768,
    GS = 65536,
    GSArmed = 131072,
    Path = 262144,
    PathArmed = 524288,
    PathInvalid = 1048576,
    Pitch = 2097152,
    Roll = 4194304,
    VNAV = 8388608,
    ATSpeed = 16777216,
    ATMach = 33554432,
    ATArmed = 67108864,
    FD = 134217728
}

/** AP Mode Types */
declare enum APModeType {
    LATERAL = 0,
    VERTICAL = 1,
    APPROACH = 2
}
/** Interface for APModePressEvents */
interface APModePressEvent {
    /** The Mode */
    mode: APLateralModes | APVerticalModes;
    /** The Set Value, if any */
    set?: boolean;
}
/**
 * A class that manages the autopilot modes and autopilot mode states.
 */
declare abstract class APStateManager {
    protected readonly bus: EventBus;
    protected readonly apConfig: APConfig;
    private keyEventManager?;
    private readonly apListener;
    private apListenerRegistered;
    private managedModeSet;
    stateManagerInitialized: Subject<boolean>;
    lateralPressed: SubEventInterface<this, APModePressEvent>;
    verticalPressed: SubEventInterface<this, APModePressEvent>;
    approachPressed: SubEventInterface<this, boolean | undefined>;
    vnavPressed: SubEventInterface<this, boolean>;
    apMasterOn: Subject<boolean>;
    isFlightDirectorOn: Subject<boolean>;
    isFlightDirectorCoPilotOn: Subject<boolean>;
    /**
     * Creates an instance of the APStateManager.
     * @param bus An instance of the event bus.
     * @param apConfig This autopilot's configuration.
     */
    constructor(bus: EventBus, apConfig: APConfig);
    /**
     * A callback which is called when the autopilot listener has been registered.
     */
    protected onAPListenerRegistered(): void;
    /**
     * Sets up key intercepts for the simulation autopilot key events.
     * @param manager The key intercept manager.
     */
    protected abstract setupKeyIntercepts(manager: KeyEventManager): void;
    /**
     * Handles an intercepted key event.
     * @param data The event data.
     */
    protected abstract handleKeyIntercepted(data: KeyEventData): void;
    /**
     * Checks whether the AP State Manager has completed listerner steps,
     * and if so, finishes initializing and then notifies Autopilot of the same.
     * @param force forces the initialize
     */
    initialize(force?: boolean): void;
    /**
     * Sets the Flight Director State
     * @param on is wheter to set the FD On.
     */
    setFlightDirector(on: boolean): void;
    /**
     * Sets Managed Mode.
     * @param set is wheter to set or unset managed mode.
     */
    private setManagedMode;
    /**
     * Toggles VNAV L Var value.
     */
    protected toggleVnav(): void;
    /**
     * Sends AP Mode Events from the Intercept to the Autopilot.
     * @param type is the AP Mode Type for this event
     * @param mode is the mode to set/unset.
     * @param set is whether to actively set or unset this mode.
     */
    protected sendApModeEvent(type: APModeType, mode?: APLateralModes | APVerticalModes, set?: boolean): void;
    /**
     * Method to override with steps to run before initialze method is run.
     */
    protected onBeforeInitialize(): void;
}

/**
 * A collection of autopilot plane directors.
 */
declare type APDirectors = {
    /** The autopilot's heading mode director. */
    readonly headingDirector?: PlaneDirector;
    /** The autopilot's heading hold mode director. */
    readonly headingHoldDirector?: PlaneDirector;
    /** The autopilot's track mode director. */
    readonly trackDirector?: PlaneDirector;
    /** The autopilot's track hold mode director. */
    readonly trackHoldDirector?: PlaneDirector;
    /** The autopilot's roll mode director. */
    readonly rollDirector?: PlaneDirector;
    /** The autopilot's wings level mode director. */
    readonly wingLevelerDirector?: PlaneDirector;
    /** The autopilot's GPS LNAV mode director. */
    readonly gpssDirector?: PlaneDirector;
    /** The autopilot's VOR mode director. */
    readonly vorDirector?: PlaneDirector;
    /** The autopilot's LOC  mode director. */
    readonly locDirector?: PlaneDirector;
    /** The autopilot's back-course mode director. */
    readonly bcDirector?: PlaneDirector;
    /** The autopilot's ROLLOUT mode director. */
    readonly rolloutDirector?: PlaneDirector;
    /** The autopilot's pitch mode director. */
    readonly pitchDirector?: PlaneDirector;
    /** The autopilot's vertical speed mode director. */
    readonly vsDirector?: PlaneDirector;
    /** The autopilot's vertical speed mode director. */
    readonly fpaDirector?: PlaneDirector;
    /** The autopilot's flight level change mode director. */
    readonly flcDirector?: PlaneDirector;
    /** The autopilot's altitude hold mode director. */
    readonly altHoldDirector?: PlaneDirector;
    /** The autopilot's wings altitude capture director. */
    readonly altCapDirector?: PlaneDirector;
    /** The autopilot's VNAV path mode director. */
    readonly vnavPathDirector?: PlaneDirector;
    /** The autopilot's GPS glidepath mode director. */
    readonly gpDirector?: PlaneDirector;
    /** The autopilot's ILS glideslope mode director. */
    readonly gsDirector?: PlaneDirector;
    /** The autopilot's FLARE mode director. */
    readonly flareDirector?: PlaneDirector;
    /** The autopilot's vertical takeoff (or combined to/ga) mode director. */
    readonly toVerticalDirector?: PlaneDirector;
    /** The autopilot's vertical go-around mode director. */
    readonly gaVerticalDirector?: PlaneDirector;
    /** The autopilot's lateral takeoff (or combined to/ga) mode director. */
    readonly toLateralDirector?: PlaneDirector;
    /** The autopilot's lateral go-around mode director. */
    readonly gaLateralDirector?: PlaneDirector;
};
/**
 * An Autopilot.
 */
declare class Autopilot {
    protected readonly bus: EventBus;
    protected readonly flightPlanner: FlightPlanner;
    protected readonly config: APConfig;
    readonly stateManager: APStateManager;
    /** This autopilot's plane directors. */
    readonly directors: APDirectors;
    /** This autopilot's nav-to-nav transfer manager. */
    readonly navToNavManager: NavToNavManager | undefined;
    /** This autopilot's VNav Manager. */
    readonly vnavManager: VNavManager | undefined;
    /** This autopilot's variable bank angle Manager. */
    readonly variableBankManager: Record<any, any> | undefined;
    protected cdiSource: NavSourceId;
    protected lateralModes: Map<APLateralModes, PlaneDirector>;
    protected verticalModes: Map<APVerticalModes, PlaneDirector>;
    protected verticalAltitudeArmed: APAltitudeModes;
    protected verticalApproachArmed: APVerticalModes;
    protected altCapArmed: boolean;
    protected lateralModeFailed: boolean;
    protected inClimb: boolean;
    protected currentAltitude: number;
    protected vnavCaptureType: VNavAltCaptureType;
    protected flightPlanSynced: boolean;
    /** Can be set to false in child classes to override behavior for certain aircraft. */
    protected requireApproachIsActiveForNavToNav: boolean;
    readonly apValues: APValues;
    protected autopilotInitialized: boolean;
    /**
     * Creates an instance of the Autopilot.
     * @param bus The event bus.
     * @param flightPlanner This autopilot's associated flight planner.
     * @param config This autopilot's configuration.
     * @param stateManager This autopilot's state manager.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, config: APConfig, stateManager: APStateManager);
    /**
     * Creates this autopilot's directors.
     * @param config This autopilot's configuration.
     * @returns This autopilot's directors.
     */
    private createDirectors;
    /**
     * Update method for the Autopilot.
     */
    update(): void;
    /**
     * This method runs each update cycle before the update occurs.
     */
    protected onBeforeUpdate(): void;
    /**
     * This method runs each update cycle after the update occurs.
     */
    protected onAfterUpdate(): void;
    /**
     * This method runs whenever the initialized state of the Autopilot changes.
     */
    protected onInitialized(): void;
    /**
     * Handles input from the State Manager when a lateral mode button is pressed.
     * @param data is the AP Lateral Mode Event Data
     */
    protected lateralPressed(data: APModePressEvent): void;
    /**
     * Handles input from the State Manager when a vertical mode button is pressed.
     * @param data is the AP Vertical Mode Event Data
     */
    protected verticalPressed(data: APModePressEvent): void;
    /**
     * Checks if a mode is active or armed and optionally deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    protected isLateralModeActivatedOrArmed(mode: APLateralModes): boolean;
    /**
     * Checks if a mode is active or armed and deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    protected deactivateArmedOrActiveVerticalMode(mode: APVerticalModes): boolean;
    /**
     * Handles input from the State Manager when the APPR button is pressed.
     * @param set is whether this event commands a specific set
     */
    protected approachPressed(set?: boolean): void;
    /**
     * Handles input from the State Manager when the TOGA button is pressed
     * (K event AUTO_THROTTLE_TO_GA)
     */
    protected togaPressed(): void;
    /**
     * Returns the AP Lateral Mode that can be armed.
     * @returns The AP Lateral Mode that can be armed.
     */
    protected getArmableApproachType(): APLateralModes;
    /**
     * Callback to set the lateral active mode.
     * @param mode is the mode being set.
     */
    protected setLateralActive(mode: APLateralModes): void;
    /**
     * Callback to set the lateral armed mode.
     * @param mode is the mode being set.
     */
    private setLateralArmed;
    /**
     * Callback to set the vertical active mode.
     * @param mode is the mode being set.
     */
    private setVerticalActive;
    /**
     * Callback to set the vertical armed mode.
     * @param mode is the mode being set.
     */
    private setVerticalArmed;
    /**
     * Callback to set the vertical approach armed mode.
     * @param mode is the mode being set.
     */
    private setVerticalApproachArmed;
    /**
     * Method called when the ALT button is pressed.
     */
    protected setAltHold(): void;
    /**
     * Initializes the Autopilot with the available lateral modes from the config.
     */
    private initLateralModes;
    /**
     * Initializes the Autopilot with the available Nav To Nav Manager.
     */
    private initNavToNavManager;
    /**
     * Initializes the Autopilot with the available VNav Manager.
     */
    protected initVNavManager(): void;
    /**
     * Initializes the Autopilot with the available vertical modes from the config.
     */
    private initVerticalModes;
    /**
     * Checks if all the active and armed modes are still in their proper state
     * and takes corrective action if not.
     */
    private checkModes;
    /**
     * Runs update on each of the active and armed modes.
     */
    private updateModes;
    /**
     * Checks and sets the proper armed altitude mode.
     */
    protected manageAltitudeCapture(): void;
    /**
     * Monitors subevents and bus events.
     */
    private monitorEvents;
    /**
     * Overridable method for setting the selected speed values for the A/P to follow.
     */
    protected monitorApSpeedValues(): void;
    /**
     * Additional events to be monitored (to be overridden).
     */
    protected monitorAdditionalEvents(): void;
    /**
     * Manages the FD state and the modes when AP/FD are off.
     */
    protected handleApFdStateChange(): void;
    /**
     * Sets a sim AP mode.
     * @param mode The mode to set.
     * @param enabled Whether or not the mode is enabled or disabled.
     */
    private setSimAP;
    /**
     * Checks if the sim AP is in roll mode and sets it if not.
     */
    protected checkRollModeActive(): void;
    /**
     * Checks if the sim AP is in pitch mode and sets it if not.
     */
    private checkPitchModeActive;
    /**
     * Get the default lateral mode from APConfig
     * @returns default lateral mode
     */
    private getDefaultLateralMode;
    /**
     * Get the default vertical mode from APConfig
     * @returns default vertical mode
     */
    private getDefaultVerticalMode;
}

/**
 * A class that synchronizes the local NXi state to the sim GPS system.
 */
declare class GpsSynchronizer {
    private bus;
    private flightPlanner;
    private readonly facLoader;
    private magvar;
    private distanceToCurrentLeg;
    private groundSpeed;
    private trueTrack;
    private zuluTime;
    private numPlanLegs;
    private hasReachedDestination;
    private isDestinationLegActive;
    private isDirectToActive;
    private readonly gpFpa;
    private readonly gpDeviation;
    private readonly isApproachActive;
    private readonly gpAvailable;
    private readonly gsiScaling;
    /**
     * Creates an instance of GpsSynchronizer.
     * @param bus The bus to source events from.
     * @param flightPlanner An instance of the flight planner.
     * @param facLoader An instance of the facility loader.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, facLoader: FacilityLoader);
    /**
     * Updates the GpsSynchronizer.
     */
    update(): void;
    /**
     * Handles when the active plan segments are changed.
     */
    private onPlanChanged;
    /**
     * Handles when the course steered by LNAV changes.
     * @param course The course steered by LNAV, in degrees true.
     */
    private onLNavCourseToSteerChanged;
    /**
     * Checks to see if we are in a direct to state.
     * @param plan The Active Flight Plan.
     */
    private checkDirectToState;
    private onDirectToActive;
    private onDestinationReached;
    private onGpDeviation;
    private onGpFpa;
    private onApproachActive;
    private onApproachHasGp;
    private onGsiScaling;
    /**
     * Checks to see if we have reached the plan destination.
     * @param plan The Active Flight Plan
     */
    private checkDestinationLegActive;
    /**
     * Checks the approach mode on leg change.
     * @param plan The Active Flight Plan.
     * @param isApproachActive Whether the approach is active.
     * @param fafIndex The destination leg index.
     */
    private checkApproachMode;
    /**
     * Handles when the active leg index changes.
     * @param plan The Active Flight Plan.
     */
    private onWaypointIndexChanged;
    /**
     * Handles when the number of active plan legs changes.
     * @param numLegs The number of active plan legs.
     */
    private onNumLegsChanged;
    /**
     * Handles when the previous leg changes.
     * @param plan The Active Flight Plan
     */
    private onIsPrevLegChanged;
    /**
     * Handles when the LNAV Distance to Destination Changes.
     * @param dis The new distance to destination.
     */
    private onLnavDistanceToDestinationChanged;
    /**
     * Handles when the LNAV DTK changes.
     * @param dtk The new DTK.
     */
    private onDtkChanged;
    /**
     * Handles when the LNAV XTK changes.
     * @param xtk The new XTK.
     */
    private onXtkChanged;
    /**
     * Handles when the LNAV DIS to WP changes.
     * @param dis The distance.
     */
    private onLnavDistanceChanged;
    /**
     * Handles when the LNAV Bearing to WP changes.
     * @param brg The bearing.
     */
    private onLnavBearingChanged;
    /**
     * Handles when the True Ground Track Changes.
     * @param trk The true track.
     */
    private onTrackTrueChanged;
    /**
     * Handles when the Ground Speed changes.
     * @param gs The current ground speed.
     */
    private onGroundSpeedChanged;
    /**
     * Handles when the true heading changes.
     * @param hdg The true heading.
     */
    private onTrueHeadingChanged;
    /**
     * Handles when the magvar changes.
     * @param magvar The new magvar.
     */
    private onMagvarChanged;
    /**
     * Handle when the VNAV Target Altitude changes.
     * @param targetAlt Target Altitude [feet] (can be -1 if none is defined or available)
     */
    private onTargetAltChanged;
    /**
     * Handle when the VNAV Active Leg Altitude Changes.
     * @param alt The active leg altitude in meters.
     */
    private onActiveLegAltChanged;
    /**
     * Handles when the VNAV required VS changes.
     * @param vs The required vertical speed.
     */
    private requiredVsChanged;
    /**
     * Handles when the distance to the GlidePath Target changes.
     * @param dis The distance to the glidepath target (runway).
     */
    private onGpDistanceChanged;
    /**
     * Handles when the plane position changes.
     * @param pos The new plane position.
     */
    private onPositionChanged;
    /**
     * Handles when the GPS CDI scale changes.
     * @param scaleNm The scale, in nautical miles.
     */
    private onCdiScaleChanged;
    /**
     * Handles checking the approach type and timezone.
     * @param plan The active flight plan.
     * @param approachIndex The approach index in the active plan.
     */
    private checkApproachTypeAndTimezone;
    /**
     * Handles checking the approach waypoint type.
     * @param leg The active lateral leg.
     */
    private checkApproachWaypointType;
}

/**
 * LNAV transition modes.
 */
declare enum LNavTransitionMode {
    /** LNAV is attempting to track a non-transition vector. */
    None = 0,
    /** LNAV is attempting to track an ingress vector. */
    Ingress = 1,
    /** LNAV is attempting to track an egress vector. */
    Egress = 2,
    /**
     * LNAV is attempting to track a non-transition vector prior to where the ingress transition joins the base flight
     * path after deactivating suspend mode.
     */
    Unsuspend = 3
}
/**
 * Sim var names for LNAV data.
 */
declare enum LNavVars {
    /** The current desired track, in degrees true. */
    DTK = "L:WTAP_LNav_DTK",
    /**
     * The current crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    XTK = "L:WTAP_LNav_XTK",
    /** Whether LNAV is tracking a path. */
    IsTracking = "L:WTAP_LNav_Is_Tracking",
    /** The global leg index of the flight plan leg LNAV is currently tracking. */
    TrackedLegIndex = "L:WTAP_LNav_Tracked_Leg_Index",
    /** The currently active LNAV transition mode. */
    TransitionMode = "L:WTAP_LNav_Transition_Mode",
    /** The index of the vector LNAV is currently tracking. */
    TrackedVectorIndex = "L:WTAP_LNav_Tracked_Vector_Index",
    /** The current course LNAV is attempting to steer, in degrees true. */
    CourseToSteer = "L:WTAP_LNav_Course_To_Steer",
    /** Whether LNAV sequencing is suspended. */
    IsSuspended = "L:WTAP_LNav_Is_Suspended",
    /**
     * The along-track distance from the start of the currently tracked leg to the plane's present position. A negative
     * distance indicates the plane is before the start of the leg.
     */
    LegDistanceAlong = "L:WTAP_LNav_Leg_Distance_Along",
    /**
     * The along-track distance remaining in the currently tracked leg. A negative distance indicates the plane is past
     * the end of the leg.
     */
    LegDistanceRemaining = "L:WTAP_LNav_Leg_Distance_Remaining",
    /**
     * The along-track distance from the start of the currently tracked vector to the plane's present position. A
     * negative distance indicates the plane is before the start of the vector.
     */
    VectorDistanceAlong = "L:WTAP_LNav_Vector_Distance_Along",
    /**
     * The along-track distance remaining in the currently tracked vector. A negative distance indicates the plane is
     * past the end of the vector.
     */
    VectorDistanceRemaining = "L:WTAP_LNav_Vector_Distance_Remaining",
    /**
     * The along-track distance from the current vector end where LNAV will sequence to the next vector.
     * A positive value means the vector will be sequenced this distance prior to the vector end.
     */
    VectorAnticipationDistance = "L:WTAP_LNav_Vector_Anticipation_Distance",
    /** The current along-track ground speed of the airplane. */
    AlongTrackSpeed = "L:WTAP_LNav_Along_Track_Speed"
}
/**
 * Events derived from LNAV sim vars.
 */
interface LNavSimVarEvents {
    /** The current desired track, in degrees true. */
    lnav_dtk: number;
    /**
     * The current crosstrack error, in nautical miles. Negative values indicate deviation to the left, as viewed when
     * facing in the direction of the track. Positive values indicate deviation to the right.
     */
    lnav_xtk: number;
    /** Whether LNAV is tracking a path. */
    lnav_is_tracking: boolean;
    /** The global leg index of the flight plan leg LNAV is currently tracking. */
    lnav_tracked_leg_index: number;
    /** The currently active LNAV transition mode. */
    lnav_transition_mode: LNavTransitionMode;
    /** The index of the vector LNAV is currently tracking. */
    lnav_tracked_vector_index: number;
    /** The current course LNAV is attempting to steer, in degrees true. */
    lnav_course_to_steer: number;
    /** Whether LNAV sequencing is suspended. */
    lnav_is_suspended: boolean;
    /**
     * The along-track distance from the start of the currently tracked leg to the plane's present position, in nautical
     * miles. A negative distance indicates the plane is before the start of the leg.
     */
    lnav_leg_distance_along: number;
    /**
     * The along-track distance remaining in the currently tracked leg, in nautical miles. A negative distance indicates
     * the plane is past the end of the leg.
     */
    lnav_leg_distance_remaining: number;
    /**
     * The along-track distance from the start of the currently tracked vector to the plane's present position, in
     * nautical miles. A negative distance indicates the plane is before the start of the vector.
     */
    lnav_vector_distance_along: number;
    /**
     * The along-track distance remaining in the currently tracked vector, in nautical miles. A negative distance
     * indicates the plane is past the end of the vector.
     */
    lnav_vector_distance_remaining: number;
    /**
     * The along-track distance from the current vector end where LNAV will sequence to the next vector in nautical miles.
     * A positive value means the vector will be sequenced this distance prior to the vector end.
     */
    lnav_vector_anticipation_distance: number;
    /** The current along-track ground speed of the airplane, in knots. */
    lnav_along_track_speed: number;
}
/**
 * A LNAV tracking state.
 */
declare type LNavTrackingState = {
    /** Whether LNAV is currently tracking a flight path. */
    isTracking: boolean;
    /** The global index of the tracked flight plan leg. */
    globalLegIndex: number;
    /** The LNAV transition mode. */
    transitionMode: LNavTransitionMode;
    /** The index of the tracked flight path vector. */
    vectorIndex: number;
    /** Whether LNAV sequencing is suspended. */
    isSuspended: boolean;
};
/**
 * Events published by LNAV.
 */
declare type LNavEvents = LNavSimVarEvents & {
    /** The current LNAV tracking state. */
    lnav_tracking_state: LNavTrackingState;
};
/**
 * A publisher for LNAV sim var events.
 */
declare class LNavSimVarPublisher extends SimVarPublisher<LNavSimVarEvents> {
    private static simvars;
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus: EventBus);
}

/**
 * Utility class for working with LNAV.
 */
declare class LNavUtils {
    /**
     * Gets the flight path vectors to navigate for a leg and a given transition mode.
     * @param calc The calculations for a flight plan leg.
     * @param mode A transition mode.
     * @param isSuspended Whether sequencing is suspended.
     * @returns The flight path vectors to navigate for the given leg and transition mode.
     */
    static getVectorsForTransitionMode(calc: LegCalculations, mode: LNavTransitionMode, isSuspended: boolean): FlightPathVector[];
    /**
     * Checks whether two LNAV tracking states are equal.
     * @param a The first state.
     * @param b The second state.
     * @returns Whether the two LNAV tracking states are equal.
     */
    static lnavTrackingStateEquals(a: LNavTrackingState, b: LNavTrackingState): boolean;
}

/**
 * A Utility Class for VNAV
 */
declare class VNavUtils {
    /**
     * Checks if a constraint is a user-created constraint.
     * @param lateralLeg The Lateral Flight Plan Leg.
     * @returns If this constraint is a user-created constraint.
     */
    static isUserConstraint(lateralLeg: LegDefinition): boolean;
    /**
     * Gets the required vertical speed to meet an altitude constraint.
     * @param distance The distance to the constraint, in nautical miles.
     * @param targetAltitude The target altitude for the constraint, in feet.
     * @param currentAltitude The current altitude, in feet.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The required vertical speed, in feet per minute, to meet the altitude constraint.
     */
    static getRequiredVs(distance: number, targetAltitude: number, currentAltitude: number, groundSpeed: number): number;
    /**
     * Gets the vertical speed required to maintain a given flight path angle and groundspeed.
     * @param fpa The flight path angle, in degrees. Positive angles represent an ascending flight path.
     * @param groundspeed The groundspeed, in knots.
     * @returns The vertical speed required to maintain the specified flight path angle and groundspeed.
     */
    static getVerticalSpeedFromFpa(fpa: number, groundspeed: number): number;
    /**
     * Gets the equivalent flight path angle for a given vertical speed and groundspeed. For this calculation, positive
     * flight path angles represent an ascending flight path.
     * @param vs The vertical speed, in feet per minute.
     * @param groundspeed The groundspeed, in knots.
     * @returns The flight path angle equivalent to the specified vertical speed and ground speed.
     */
    static getFpaFromVerticalSpeed(vs: number, groundspeed: number): number;
    /**
     * Gets the flight path angle for a given distance and altitude. Positive flight path angles represent an ascending
     * flight path.
     * @param distance The distance to get the angle for, in the same unit as `altitude`.
     * @param altitude The altitude to get the angle for, in the same unit as `distance`.
     * @returns The required flight path angle, in degrees.
     */
    static getFpa(distance: number, altitude: number): number;
    /**
     * Gets the change in altitude along a flight path angle for a given lateral distance covered.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param distance The lateral distance covered.
     * @returns The change in altitude along the specified flight path angle for the specified lateral distance covered,
     * expressed in the same units as `distance`.
     */
    static altitudeForDistance(fpa: number, distance: number): number;
    /**
     * Gets the lateral distance covered along a flight path angle for a given change in altitude.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param altitude The change in the altitude.
     * @returns The lateral distance covered along the specified flight path angle for the specified change in altitude,
     * expressed in the same units as `altitude`.
     */
    static distanceForAltitude(fpa: number, altitude: number): number;
    /**
     * Gets the missed approach leg index.
     * @param plan The flight plan.
     * @returns The Destination leg global leg index.
     */
    static getMissedApproachLegIndex(plan: FlightPlan): number;
    /**
     * Gets the FAF index in the plan.
     * @param plan The flight plan.
     * @returns The FAF index in the plan.
     */
    static getFafIndex(plan: FlightPlan): number | undefined;
    /**
     * Finds and returns the FAF index in the plan.
     * @param lateralPlan The lateral flight plan.
     * @param iterator The FlightPlanLegIterator instance.
     * @returns The FAF index in the lateral flight plan.
     */
    static getFafIndexReverse(lateralPlan: FlightPlan, iterator: FlightPlanLegIterator): number;
    /**
     * Gets the index of the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint that contains the specified flight plan leg, or `-1` if one could not
     * be found.
     */
    static getConstraintIndexFromLegIndex(verticalPlan: VerticalFlightPlan, globalLegIndex: number): number;
    /**
     * Gets the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint that contains the specified flight plan leg, or `undefined` if one could not be
     * found.
     */
    static getConstraintFromLegIndex(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the index of the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint immediately prior to the constraint that contains the specified flight
     * plan leg, or `-1` if one could nto be found.
     */
    static getPriorConstraintIndexFromLegIndex(verticalPlan: VerticalFlightPlan, globalLegIndex: number): number;
    /**
     * Gets the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint immediately prior to the constraint that contains the specified flight plan leg, or
     * `undefined` if one could nto be found.
     */
    static getPriorConstraintFromLegIndex(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets and returns whether the input leg index is a path end.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex is the global leg index to check.
     * @returns whether the input leg index is a path end.
     */
    static getIsPathEnd(verticalPlan: VerticalFlightPlan, globalLegIndex: number): boolean;
    /**
     * Gets the global leg index for the constraint containing an indexed leg.
     * @param verticalPlan The vertical plan.
     * @param globalLegIndex A global leg index.
     * @returns The global leg index for the constraint containing the leg at the specified global index, or -1 if one
     * could not be found.
     */
    static getConstraintLegIndexFromLegIndex(verticalPlan: VerticalFlightPlan, globalLegIndex: number): number;
    /**
     * Gets a constraint segment distance from the constraint legs.
     * @param constraint The constraint to calculate a distance for.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromConstraint(constraint: VNavConstraint): number;
    /**
     * Gets a constraint segment distance from the Vertical Plan legs.
     * @param constraint The constraint to calculate a distance for.
     * @param previousConstraint The constraint that preceds the constraint we are calculating the distance for.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromLegs(constraint: VNavConstraint, previousConstraint: VNavConstraint | undefined, verticalPlan: VerticalFlightPlan): number;
    /**
     * Gets the distance from the current location in the plan to the constraint.
     * @param constraint The vnav constraint to calculate the distance to.
     * @param lateralPlan The lateral flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The current distance along leg.
     * @returns the distance to the constraint, or positive infinity if a discontinuity exists between the ppos and the constraint.
     */
    static getDistanceToConstraint(constraint: VNavConstraint, lateralPlan: FlightPlan, activeLegIndex: number, distanceAlongLeg: number): number;
    /**
     * Gets VNAV Constraint Details from a constraint.
     * @param constraint The constraint to get details from.
     * @param out The object to which write the results.
     * @returns The VNav Constraint Details.
     */
    static getConstraintDetails(constraint: VNavConstraint, out: AltitudeConstraintDetails): AltitudeConstraintDetails;
    /**
     * Gets and returns the vertical direct constraint based on an input index.
     * @param verticalPlan The vertical flight plan.
     * @param selectedGlobalLegIndex The global leg index selected for vertical direct.
     * @param activeLegIndex The active leg index.
     * @returns The Vnav Constraint for the vertical direct or undefined.
     */
    static getVerticalDirectConstraintFromIndex(verticalPlan: VerticalFlightPlan, selectedGlobalLegIndex: number, activeLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the next descent constraint with a defined minimum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint with a defined minimum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextDescentTargetConstraint(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the next descent constraint minimum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint defined minimum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextDescentTargetAltitude(verticalPlan: VerticalFlightPlan, globalLegIndex: number): number | undefined;
    /**
     * Gets the next climb constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint with a defined maximum altitude at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetConstraint(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the next climb constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetAltitude(verticalPlan: VerticalFlightPlan, globalLegIndex: number): number | undefined;
    /**
     * Gets the next missed approach constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint with a defined maximum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextMaprTargetConstraint(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the next missed approach constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextMaprTargetAltitude(verticalPlan: VerticalFlightPlan, globalLegIndex: number): number | undefined;
    /**
     * Gets the VNAV desired altitude.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index to get the target for.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current VNAV desired altitude.
     */
    static getDesiredAltitude(verticalPlan: VerticalFlightPlan, globalLegIndex: number, distanceAlongLeg: number): number;
    /**
     * Gets and returns the FAF altitude.
     * @param verticalPlan The vertical flight plan.
     * @returns the FAF constraint altitude.
     */
    static getFafAltitude(verticalPlan: VerticalFlightPlan): number | undefined;
    /**
     * Gets the VNAV TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    static getTodBodDetails(verticalPlan: VerticalFlightPlan, activeLegIndex: number, distanceAlongLeg: number, currentAltitude: number, currentVS: number, out: TodBodDetails): TodBodDetails;
    /**
     * Gets the VNAV TOC/BOC details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC details.
     */
    static getTocBocDetails(verticalPlan: VerticalFlightPlan, activeLegIndex: number, distanceAlongLeg: number, currentGroundSpeed: number, currentAltitude: number, currentVS: number, out: TocBocDetails): TocBocDetails;
    /**
     * Gets the VNAV TOC/BOC to cruise altitude details for a vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param cruiseAltitude The cruise altitude, in meters.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC to cruise altitude details.
     */
    static getCruiseTocBocDetails(lateralPlan: FlightPlan, verticalPlan: VerticalFlightPlan, activeLegIndex: number, distanceAlongLeg: number, currentGroundSpeed: number, currentAltitude: number, currentVS: number, cruiseAltitude: number, out: TocBocDetails): TocBocDetails;
    /**
     * Checks whether or not the vertical plan has a leg at a given globalLegIndex.
     * @param verticalPlan The Vertical Flight Plan.
     * @param globalLegIndex The global leg index to check.
     * @returns True if the leg exists.
     */
    static verticalPlanHasLeg(verticalPlan: VerticalFlightPlan, globalLegIndex: number): boolean;
    /**
     * Gets a VNAV leg from a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromPlan(verticalPlan: VerticalFlightPlan, globalLegIndex: number): VNavLeg;
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @param verticalPlan The vertical flight plan.
     * @param segmentIndex The segment index of the leg to get.
     * @param legIndex The index of the leg to get within the specified segment.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromSegmentInPlan(verticalPlan: VerticalFlightPlan, segmentIndex: number, legIndex: number): VNavLeg;
    /**
     * Gets the constraint for a vertical direct based on an input global leg index.
     * @param verticalPlan The vertical flight plan.
     * @param activeGlobalLegIndex The current active global leg index.
     * @param selectedGlobalLegIndex The input global leg index selected.
     * @returns The constraint, or undefined if none exists.
     */
    static getConstraintForVerticalDirect(verticalPlan: VerticalFlightPlan, activeGlobalLegIndex: number, selectedGlobalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the VNAV segments from the calculated VNAV plan.
     * @param verticalPlan The vertical flight plan.
     * @returns The vnav segments.
     * @throws Not found if the index is not valid.
     */
    static getVerticalSegmentsFromPlan(verticalPlan: VerticalFlightPlan): VNavPlanSegment[];
    /**
     * Gets whether a lateral plan leg is a hold or procedure turn.
     * @param lateralLeg The Lateral Leg in the flight plan (LegDefinition).
     * @returns Whether the leg is a hold or procedure turn.
     */
    static isLegTypeHoldOrProcedureTurn(lateralLeg: LegDefinition): boolean;
    /**
     * Creates a new empty vertical flight plan constraint.
     * @param index The leg index of the constraint.
     * @param minAltitude The bottom altitude of the constraint.
     * @param maxAltitude THe top altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    static createConstraint(index: number, minAltitude: number, maxAltitude: number, name: string, type?: 'climb' | 'descent' | 'direct' | 'missed' | 'manual'): VNavConstraint;
    /**
     * Creates a new vertical flight plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    static createLeg(segmentIndex: number, legIndex: number, name: string, distance?: number): VNavLeg;
    /**
     * Finds the index of the first climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getFirstClimbConstraintIndex(verticalPlan: VerticalFlightPlan): number;
    /**
     * Finds the index of the last climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getLastClimbConstraintIndex(verticalPlan: VerticalFlightPlan): number;
    /**
     * Finds the index of the first descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getFirstDescentConstraintIndex(verticalPlan: VerticalFlightPlan): number;
    /**
     * Finds the index of the last descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getLastDescentConstraintIndex(verticalPlan: VerticalFlightPlan): number;
    /**
     * Checks whether two speed constraints are equal.
     * @param a The first speed constraint.
     * @param b The second speed constraint.
     * @returns Whether the two speed constraints are equal.
     */
    static speedConstraintEquals(a: SpeedConstraint, b: SpeedConstraint): boolean;
    /**
     * Checks whether two altitude constraint details are equal.
     * @param a The first altitude constraint details.
     * @param b The second altitude constraint details.
     * @returns Whether the two altitude constraint details are equal.
     */
    static altitudeConstraintDetailsEquals(a: AltitudeConstraintDetails, b: AltitudeConstraintDetails): boolean;
    /**
     * Checks whether two speed constraint details are equal.
     * @param a The first speed constraint details.
     * @param b The second speed constraint details.
     * @returns Whether the two speed constraint details are equal.
     */
    static speedConstraintDetailsEquals(a: SpeedConstraintDetails, b: SpeedConstraintDetails): boolean;
    /**
     * Computes the path error distance that should be used given the groundspeed.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The path error distance to use.
     */
    static getPathErrorDistance(groundSpeed: number): number;
}

/**
 * A function which calculates a desired pitch angle, in degrees, to capture a target altitude.
 * @param targetAltitude The altitude to capture, in feet.
 * @param indicatedAltitude The current indicated altitude, in feet.
 * @param initialFpa The flight path angle of the airplane, in degrees, when altitude capture was first activated.
 * Positive values indicate a descending path.
 * @param aoa The current angle of attack, in degrees. Positive values indicate nose-up attitude.
 * @param verticalSpeed The current vertical speed of the airplane, in feet per minute.
 * @param tas The current true airspeed of the airplane, in knots.
 * @returns The desired pitch angle, in degrees, to capture the specified altitude. Positive values indicate nose-up
 * pitch.
 */
declare type APAltCapDirectorCaptureFunc = (targetAltitude: number, indicatedAltitude: number, initialFpa: number, aoa: number, verticalSpeed: number, tas: number) => number;
/**
 * An altitude capture autopilot director.
 */
declare class APAltCapDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly captureAltitude;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private capturedAltitude;
    private initialFpa;
    private selectedAltitude;
    private verticalWindAverage;
    /**
     * Creates an instance of the APAltCapDirector.
     * @param bus The event bus to use with this director.
     * @param apValues Autopilot data for this director.
     * @param captureAltitude A function which calculates desired pitch angles to capture a target altitude. If not
     * defined, a default function is used.
     */
    constructor(bus: EventBus, apValues: APValues, captureAltitude?: APAltCapDirectorCaptureFunc);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     * @param captured is whether the altitude was captured.
     */
    deactivate(captured?: boolean): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Attempts to activate altitude capture.
     */
    private tryActivate;
    /**
     * Sets the initial capture FPA from the current vs value when capture is initiated.
     * @param vs target vertical speed.
     */
    private setCaptureFpa;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     * @param tas The airplane's current true airspeed, in knots.
     */
    private setPitch;
    /**
     * Calculates a desired pitch angle, in degrees, to capture a target altitude.
     * @param targetAltitude The altitude to capture, in feet.
     * @param indicatedAltitude The current indicated altitude, in feet.
     * @param initialFpa The flight path angle of the airplane, in degrees, when altitude capture was first activated.
     * Positive values indicate a descending path.
     * @param aoa The current angle of attack, in degrees. Positive values indicate nose-up attitude.
     * @param verticalSpeed The current vertical speed of the airplane, in feet per minute.
     * @param tas The current true airspeed of the airplane, in knots.
     * @returns The desired pitch angle, in degrees, to capture the specified altitude. Positive values indicate nose-up
     * pitch.
     */
    private static captureAltitude;
}

/**
 * An altitude hold autopilot director.
 */
declare class APAltDirector implements PlaneDirector {
    private readonly bus;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private tas;
    private capturedAltitude;
    private indicatedAltitude;
    private verticalWindAverage;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Attempts to activate altitude capture.
     */
    private tryActivate;
    /**
     * Holds a captured altitude.
     * @param targetAltitude is the captured targed altitude
     */
    private holdAltitude;
    /**
     * Gets a desired pitch from the selected vs value.
     * @param vs target vertical speed.
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    private getFpa;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * A Flight Level Change autopilot director.
 */
declare class APFLCDirector implements PlaneDirector {
    private readonly bus;
    protected pitchClamp: number;
    private forceCurrentIasOnActivation;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private _lastTime;
    private currentIas;
    private selectedIas;
    private selectedMach;
    private isSelectedSpeedInMach;
    private selectedAltitude;
    private currentAltitude;
    private currentPitch;
    private pitchController;
    private filter;
    /**
     * Creates an instance of the FLC Director.
     * @param bus The event bus to use with this instance.
     * @param apValues is the AP selected values subject.
     * @param pitchClamp is the maximum pitch angle, in degrees, to clamp FLC at.
     * @param forceCurrentIasOnActivation Whether this director should force set the current IAS as the target speed on activation.
     */
    constructor(bus: EventBus, apValues: APValues, pitchClamp?: number, forceCurrentIasOnActivation?: boolean);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director can be armed, but it will never automatically activate and remain in the armed state.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Initializes this director on activation.
     */
    protected initialize(): void;
    /**
     * Gets a desired pitch from the current AP speed target
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Gets a desired pitch from a given speed target
     * @param targetIas target airspeed in knots
     * @returns The desired pitch angle.
     */
    protected getDesiredPitchFromSpeed(targetIas: number): number;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    protected setPitch(targetPitch: number): void;
    /** Reset the pitch filter */
    protected resetFilter(): void;
}

/**
 * Options for {@link APHdgDirector}.
 */
declare type APFPADirectorOptions = {
    /**
     * The maximum flight path angle, in degrees, supported by the director, or a function which returns it. If not defined,
     * the director will not limit the FPA.
     */
    maxFpa: number | (() => number) | undefined;
};
/**
 * A flight path angle autopilot director.
 */
declare class APFPADirector implements PlaneDirector {
    private readonly bus;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private readonly maxFpaFunc;
    private tas;
    private selectedFpa;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxFpa`: `undefined`
     */
    constructor(bus: EventBus, apValues: APValues, options?: Partial<Readonly<APFPADirectorOptions>>);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Gets a desired fpa.
     * @param vs Vertical speed in feet/min to calculate as FPA for
     * @returns The desired pitch angle.
     */
    private getFpaFromVs;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * An RNAV LPV glidepath autopilot director.
 */
declare class APGPDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private gpDeviation;
    private fpa;
    private verticalWindAverage;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * Options for {@link APGSDirector}.
 */
declare type APGSDirectorOptions = {
    /**
     * Force the director to always use a certain NAV/GS source
     */
    forceNavSource: NavRadioIndex;
};
/**
 * A glideslope autopilot director.
 */
declare class APGSDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private gsLocation;
    private glideslope?;
    private verticalWindAverage;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues is the APValues object from the Autopilot.
     * @param options APGSDirector options.
     */
    constructor(bus: EventBus, apValues: APValues, options?: Partial<Readonly<APGSDirectorOptions>>);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    private canArm;
    /**
     * Tracks the Glideslope.
     */
    private trackGlideslope;
}

/**
 * Options for {@link APHdgDirector}.
 */
declare type APHdgDirectorOptions = {
    /**
     * The maximum bank angle, in degrees, supported by the director, or a function which returns it. If not defined,
     * the director will use the maximum bank angle defined by its parent autopilot (via `apValues`).
     */
    maxBankAngle: number | (() => number) | undefined;
    /**
     * Whether the director is to be used as a TO/GA lateral mode. If `true`, the director will not control the
     * `AUTOPILOT HEADING LOCK` simvar.
     */
    isToGaMode: boolean;
};
/**
 * A heading autopilot director.
 */
declare class APHdgDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private static readonly BANK_SERVO_RATE;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private currentBankRef;
    private currentHeading;
    private toGaHeading;
    private readonly bankServo;
    private readonly maxBankAngleFunc;
    private readonly isToGaMode;
    /**
     * Creates a new instance of APHdgDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `isToGaMode`: `false`
     */
    constructor(bus: EventBus, apValues: APValues, options?: Partial<Readonly<APHdgDirectorOptions>>);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): Promise<void>;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired bank from a Target Selected Heading.
     * @param targetHeading The target heading.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
}

/**
 * An autopilot heading hold director.
 * Levels the wings upon activation, and then holds the captured heading
 */
declare class APHdgHoldDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private static readonly BANK_SERVO_RATE;
    /** bank angle below which we capture the heading */
    private static readonly MIN_BANK_THRESHOLD;
    state: DirectorState;
    /** A callback called when the heading hold director activates. */
    onActivate?: () => void;
    /** A callback called when the heading hold director arms. */
    onArm?: () => void;
    private currentBankRef;
    private currentHeading;
    private currentBank;
    private readonly currentBankSub;
    private readonly currentHeadingSub;
    private readonly bankServo;
    private readonly maxBankAngleFunc;
    /** heading captured at wings level, or null if not yet captured */
    private capturedHeading;
    /**
     * Creates an instance of the heading hold director.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `isToGaMode`: `false`
     */
    constructor(bus: EventBus, apValues: APValues, options?: Partial<Readonly<APHdgDirectorOptions>>);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired bank from a Target Selected Heading.
     * @param targetHeading The target heading.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
}

/**
 * Calculates an intercept angle, in degrees, to capture the desired track from a navigation signal for
 * {@link APNavDirector}.
 * @param distanceToSource The distance from the plane to the source of the navigation signal, in nautical miles.
 * @param deflection The lateral deflection of the desired track relative to the plane, normalized from `-1` to `1`.
 * Negative values indicate that the desired track is to the left of the plane.
 * @param tas The true airspeed of the plane, in knots.
 * @param isLoc Whether the source of the navigation signal is a localizer. Defaults to `false`.
 * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
 */
declare type APNavDirectorInterceptFunc = (distanceToSource: number, deflection: number, tas: number, isLoc?: boolean) => number;
/**
 * Options for {@link APNavDirector}.
 */
declare type APNavDirectorOptions = {
    /**
     * The maximum bank angle, in degrees, supported by the director, or a function which returns it. If not defined,
     * the director will use the maximum bank angle defined by its parent autopilot (via `apValues`).
     */
    maxBankAngle: number | (() => number) | undefined;
    /**
     * A function used to translate DTK and XTK into a track intercept angle.
     */
    lateralInterceptCurve: APNavDirectorInterceptFunc;
    /**
     * Whether to disable arming on the director. If `true`, the director will always skip the arming phase and instead
     * immediately activate itself when requested.
     */
    disableArming: boolean;
    /**
     * Force the director to always use a certain NAV/CDI source
     */
    forceNavSource: NavRadioIndex;
};
/**
 * A Nav/Loc autopilot director.
 */
declare class APNavDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly mode;
    private static readonly BANK_SERVO_RATE;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    /** A callback called when the director deactivates. */
    onDeactivate?: () => void;
    private readonly bankServo;
    private currentBankRef;
    private currentHeading;
    private currentTrack;
    private navSource?;
    private cdi?;
    private obs?;
    private loc?;
    private magVar?;
    private ppos;
    private navLocation;
    private tas;
    private isApproachMode;
    private isNavLock;
    private readonly maxBankAngleFunc;
    private readonly lateralInterceptCurve?;
    private readonly disableArming;
    private readonly forceNavSource;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param mode The APLateralMode for this instance of the director.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `lateralInterceptCurve`: A default function tuned for slow GA aircraft.
     * * `disableArming`: `false`
     */
    constructor(bus: EventBus, apValues: APValues, mode: APLateralModes, options?: Partial<Readonly<APNavDirectorOptions>>);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Sets the NAV1 Lock state.
     * @param newState The new state of the NAV1 lock.
     */
    setNavLock(newState: boolean): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    private canArm;
    /**
     * Method to check whether the director can activate.
     * @returns Whether or not this director can activate.
     */
    private canActivate;
    /**
     * Gets a desired bank from the nav input data.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Gets a xtk value from the nav input data.
     * @param deviation is the input deviation value
     * @param isLoc is whether this is a LOC signal.
     * @returns The xtk value.
     */
    private getXtk;
    /**
     * Gets the lateral distance from PPOS to the nav signal.
     * @returns The distance value in nautical miles.
     */
    private getNavDistance;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
    /**
     * Checks if we might be getting a wild deviation because of the zone of confusion and allows APNavDirector some time to resolve.
     * @returns Whether we might be in the zone of confusion.
     */
    private checkForZoneOfConfusion;
    /**
     * Method to monitor nav events to keep track of NAV related data needed for guidance.
     */
    private monitorEvents;
}

/**
 * An autopilot pitch director.
 */
declare class APPitchDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly pitchIncrement;
    private readonly minPitch;
    private readonly maxPitch;
    state: DirectorState;
    private keyEventManager?;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private selectedPitch;
    private currentPitch;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the AP Values subjects.
     * @param pitchIncrement is the pitch increment, in degrees, to use when the user presses the pitch inc/dec keys (default: 0.5)
     * @param minPitch is the negative minimum pitch angle, in degrees, to clamp the pitch to. (default: -15)
     * @param maxPitch is the positive maximum pitch angle, in degrees, to clamp the pitch to. (default: 20)
     */
    constructor(bus: EventBus, apValues: APValues, pitchIncrement?: number, minPitch?: number, maxPitch?: number);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Responds to key intercepted events.
     * @param k the key event data
     */
    private onKeyIntercepted;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * Options for control of the roll director.
 */
declare type APRollDirectorOptions = {
    /**
     * The minimum bank angle, in degrees, below which the roll director will command wings level, or a function which
     * returns it.
     */
    minBankAngle: number | (() => number);
    /**
     * The maximum bank angle, in degrees, that the roll director will not exceed, or a function which returns it. If not
     * defined, the director will use the maximum bank angle defined by its parent autopilot (via `apValues`).
     */
    maxBankAngle: number | (() => number) | undefined;
};
/**
 * An autopilot roll director.
 */
declare class APRollDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private static readonly BANK_SERVO_RATE;
    state: DirectorState;
    /** A callback called when the LNAV director activates. */
    onActivate?: () => void;
    /** A callback called when the LNAV director arms. */
    onArm?: () => void;
    private currentBankRef;
    private desiredBank;
    private actualBank;
    private readonly bankServo;
    private readonly minBankAngleFunc;
    private readonly maxBankAngleFunc;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues The AP Values.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `minBankAngle`: `0`
     * * `maxBankAngle`: `undefined`
     */
    constructor(bus: EventBus, apValues: APValues, options?: Partial<Readonly<APRollDirectorOptions>>);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
}

/**
 * A heading autopilot director.
 */
declare class APTrkDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private static readonly BANK_SERVO_RATE;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private currentBankRef;
    private currentTrack;
    private toGaTrack;
    private readonly bankServo;
    private readonly maxBankAngleFunc;
    private readonly isToGaMode;
    /**
     * Creates a new instance of APHdgDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `isToGaMode`: `false`
     */
    constructor(bus: EventBus, apValues: APValues, options?: Partial<Readonly<APHdgDirectorOptions>>);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): Promise<void>;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired bank from a Target Selected Track.
     * @param targetTrack The target track.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
}

/**
 * An autopilot track hold director.
 * Levels the wings upon activation, and then holds the captured track
 */
declare class APTrkHoldDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private static readonly BANK_SERVO_RATE;
    /** bank angle below which we capture the track */
    private static readonly MIN_BANK_THRESHOLD;
    state: DirectorState;
    /** A callback called when the track hold director activates. */
    onActivate?: () => void;
    /** A callback called when the track hold director arms. */
    onArm?: () => void;
    private currentBankRef;
    private currentTrack;
    private currentBank;
    private readonly currentBankSub;
    private readonly currentTrackSub;
    private readonly bankServo;
    private readonly maxBankAngleFunc;
    /** track captured at wings level, or null if not yet captured */
    private capturedTrack;
    /**
     * Creates an instance of the track hold director.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `isToGaMode`: `false`
     */
    constructor(bus: EventBus, apValues: APValues, options?: Partial<Readonly<APHdgDirectorOptions>>);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired bank from a Target Selected Track.
     * @param targetTrack The target track.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
}

/**
 * A vertical speed autopilot director.
 */
declare class APVSDirector implements PlaneDirector {
    private readonly bus;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    private tas;
    private selectedVS;
    private verticalWindAverage;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    private getDesiredPitch;
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    private getFpa;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * Calculates an intercept angle, in degrees, to capture the desired GPS track for {@link LNavDirector}.
 * @param dtk The desired track, in degrees true.
 * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
 * desired track.
 * @param tas The true airspeed of the plane, in knots.
 * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
 */
declare type LNavDirectorInterceptFunc = (dtk: number, xtk: number, tas: number) => number;
/**
 * Options for {@link LNavDirector}.
 */
declare type LNavDirectorOptions = {
    /**
     * The maximum bank angle, in degrees, supported by the director, or a function which returns it. If not defined,
     * the director will use the maximum bank angle defined by its parent autopilot (via `apValues`).
     */
    maxBankAngle: number | (() => number) | undefined;
    /**
     * A function used to translate DTK and XTK into a track intercept angle.
     */
    lateralInterceptCurve: LNavDirectorInterceptFunc;
    /**
     * Whether the director supports vector anticipation. If `true`, the director will begin tracking the next flight
     * path vector before
     */
    hasVectorAnticipation: boolean;
    /**
     * The minimum radio altitude, in feet, required for the director to activate, or `undefined` if there is no minimum
     * altitude.
     */
    minimumActivationAltitude: number | undefined;
    /**
     * Whether to disable arming on the director. If `true`, the director will always skip the arming phase and instead
     * immediately activate itself when requested.
     */
    disableArming: boolean;
};
/**
 * A class that handles lateral navigation.
 */
declare class LNavDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly flightPlanner;
    private readonly obsDirector?;
    private static readonly ANGULAR_TOLERANCE;
    private static readonly ANGULAR_TOLERANCE_METERS;
    private static readonly BANK_SERVO_RATE;
    private static readonly VECTOR_ANTICIPATION_BANK_RATE;
    private readonly vec3Cache;
    private readonly geoPointCache;
    private readonly geoCircleCache;
    private readonly publisher;
    state: DirectorState;
    /** A callback called when the LNAV director activates. */
    onActivate?: () => void;
    /** A callback called when the LNAV director arms. */
    onArm?: () => void;
    private readonly aircraftState;
    private currentLeg;
    private currentVector;
    private dtk;
    private xtk;
    private bearingToVectorEnd;
    private courseToSteer;
    private alongVectorDistance;
    private vectorDistanceRemaining;
    private vectorAnticipationDistance;
    private alongTrackSpeed;
    private anticipationVector;
    private anticipationDtk;
    private anticipationXtk;
    private anticipationBearingToVectorEnd;
    private inhibitNextSequence;
    private currentBankRef;
    private readonly bankServo;
    private readonly currentState;
    private readonly anticipationState;
    private readonly currentBankAngleState;
    private readonly lnavData;
    private isObsDirectorTracking;
    private canArm;
    private awaitCalculateId;
    private isAwaitingCalculate;
    private isNavLock;
    private readonly lnavDataHandler;
    private readonly maxBankAngleFunc;
    private readonly lateralInterceptCurve?;
    private readonly hasVectorAnticipation;
    private readonly minimumActivationAltitude;
    private readonly disableArming;
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues The AP Values.
     * @param flightPlanner The flight planner to use with this instance.
     * @param obsDirector The OBS Director.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `lateralInterceptCurve`: A default function tuned for slow GA aircraft.
     * * `hasVectorAnticipation`: `false`
     * * `minimumActivationAltitude`: `undefined`
     * * `disableArming`: `false`
     */
    constructor(bus: EventBus, apValues: APValues, flightPlanner: FlightPlanner, obsDirector?: ObsDirector | undefined, options?: Partial<Readonly<LNavDirectorOptions>>);
    /**
     * Resets the current vectors and transition mode.
     */
    private resetVectors;
    /**
     * Activates the LNAV director.
     */
    activate(): void;
    /**
     * Arms the LNAV director.
     */
    arm(): void;
    /**
     * Deactivates the LNAV director.
     */
    deactivate(): void;
    /**
     * Sets the NAV1 Lock state.
     * @param newState The new state of the NAV1 lock.
     */
    setNavLock(newState: boolean): void;
    /**
     * Updates the lateral director.
     */
    update(): void;
    /**
     * Navigates the currently tracked flight path.
     */
    private navigateFlightPath;
    /**
     * Updates a bank angle state for a tracked flight path vector.
     * @param vector The tracked flight path vector.
     * @param dtk The desired track, in degrees true.
     * @param xtk The cross-track error, in nautical miles.
     * @param bearingToVectorEnd The bearing from the airplane to the end of the tracked vector, in degrees true.
     * @param bankAngleState The bank angle state to udpate.
     * @returns The updated bank angle state.
     */
    private updateBankAngle;
    /**
     * Gets a desired bank from a desired track.
     * @param desiredTrack The desired track.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Adjusts a bank angle state's desired bank angle for arc vectors.
     * @param vector The arc vector to adjust for.
     * @param bankAngleState The bank angle state to adjust.
     * @returns The adjusted bank angle state.
     */
    private adjustBankAngleForArc;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
    /**
     * Calculates the tracking from the current leg.
     * @param plan The active flight plan.
     */
    private calculateTracking;
    /**
     * Updates this director's vector anticipation data, including the anticipation distance, DTK and XTK for the
     * anticipated vector, and bearing from the airplane to the end of the anticipated vector.
     * @param plan The active flight plan.
     */
    private updateVectorAnticipation;
    /**
     * Applies suspends that apply at the end of a leg.
     * @param plan The active flight plan.
     * @param state The current LNAV state.
     * @param out The LNAV state to which to write.
     * @returns The LNAV state after applying end-of-leg suspends.
     */
    private applyEndOfLegSuspends;
    /**
     * Applies suspends that apply at the beginning of a leg.
     * @param plan The active flight plan.
     * @param state The current LNAV state.
     * @param out The LNAV state to which to write.
     * @returns The LNAV state after applying start-of-leg suspends.
     */
    private applyStartOfLegSuspends;
    /**
     * Advances an LNAV state to the next trackable vector.
     * @param plan The active flight plan.
     * @param state The state from which to advance.
     * @param awaitCalculateOnNextLeg Whether to await leg calculations when advancing to the next leg. If `true`, the
     * state will only advance as far as the first vector of the next leg.
     * @param out The state to which to write the results.
     * @returns The LNAV state after advancing to the next trackable vector.
     */
    private advanceToNextVector;
    /**
     * Advances an LNAV state to the next leg.
     * @param plan The active flight plan.
     * @param state The state from which to advance.
     * @param out The state to which to write the results.
     * @returns The LNAV state after advancing to the next leg.
     */
    private advanceToNextLeg;
    /**
     * Attempts to activate/deactivate suspend on an LNAV state.
     * @param plan The active flight plan.
     * @param state The state for which to set suspended.
     * @param suspend The suspended state to set.
     * @param out The state to which to write the results.
     * @param inhibitResuspend Whether to inhibit resuspend of the suspended leg once suspend ends on that leg. Ignored
     * if `suspend` is `false`. Defaults to `false`.
     * @param resetVectorsOnSuspendEnd Whether to reset the tracked vector to the beginning of the suspended leg once
     * suspend ends on that leg. Ignored if `suspend` is `false`. Defaults to `false`.
     * @returns The LNAV state after the suspend state has been set.
     */
    private trySetSuspended;
    /**
     * Tries to activate when armed.
     */
    private tryActivate;
    /**
     * Awaits a flight plan calculation. Starts a calculation of the active flight plan and suspends all tracking and
     * sequencing until the calculation is finished. If this method is called while a previous execution is still
     * awaiting, the new await takes precedence.
     */
    private awaitCalculate;
    /**
     * Gets an along-track distance from the start of a tracked flight plan leg given a distance along a tracked vector.
     * @param plan The active flight plan.
     * @param state The LNAV state.
     * @param alongVectorDistance The along-track distance from the start of the tracked vector, in nautical miles.
     * @returns The along-track distance, in nautical miles, from the start of the specified flight plan leg given the
     * specified state and along-vector distance.
     */
    private getAlongLegDistance;
    /**
     * Gets an along-track distance from the end of a tracked flight plan leg given a distance remaining along a tracked
     * vector.
     * @param plan The active flight plan.
     * @param state The LNAV state.
     * @param vectorDistanceRemaining The along-track distance from the end of the tracked vector, in nautical miles.
     * @returns The along-track distance, in nautical miles, from the end of the specified flight plan leg given the
     * specified state and along-vector distance.
     */
    private getLegDistanceRemaining;
    /**
     * Copies one LNAV state object to another.
     * @param source The LNAV state from which to copy.
     * @param target The LNAV state to which to copy.
     * @returns The target LNAV state of the copy operation.
     */
    private static copyStateInfo;
    /**
     * Gets the ideal bank angle, in degrees, to follow a flight path vector under conditions of no cross-track error
     * and no wind, at a given ground speed.
     * @param vector The flight path vector to follow.
     * @param groundSpeed Ground speed, in knots.
     * @returns The ideal bank angle, in degrees, to follow the specified flight path vector at the specified ground
     * speed.
     */
    private static getVectorIdealBankAngle;
}

/**
 * Options for {@link APBackCourseDirector}.
 */
declare type APBackCourseDirectorOptions = {
    /**
     * The maximum bank angle, in degrees, supported by the director, or a function which returns it. If not defined,
     * the director will use the maximum bank angle defined by its parent autopilot (via `apValues`).
     */
    maxBankAngle: number | (() => number) | undefined;
    /**
     * A function used to translate DTK and XTK into a track intercept angle.
     */
    lateralInterceptCurve: APNavDirectorInterceptFunc;
};
/**
 * A BackCourse autopilot director.
 */
declare class APBackCourseDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    private readonly mode;
    private static readonly BANK_SERVO_RATE;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    /** A callback called when the director deactivates. */
    onDeactivate?: () => void;
    private readonly bankServo;
    private currentBankRef;
    private currentHeading;
    private currentTrack;
    private navSource?;
    private cdi?;
    private loc?;
    private magVar?;
    private ppos;
    private navLocation;
    private tas;
    private isApproachMode;
    private readonly maxBankAngleFunc;
    private readonly lateralInterceptCurve?;
    /**
     * Creates a new instance of APBackCourseDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param mode The APLateralMode for this instance of the director.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `lateralInterceptCurve`: A default function tuned for slow GA aircraft.
     */
    constructor(bus: EventBus, apValues: APValues, mode: APLateralModes, options?: Partial<Readonly<APBackCourseDirectorOptions>>);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    private canArm;
    /**
     * Method to check whether the director can activate.
     * @returns Whether or not this director can activate.
     */
    private canActivate;
    /**
     * Gets a desired bank from the nav input data.
     * @returns The desired bank angle.
     */
    private desiredBank;
    /**
     * Gets a xtk value from the nav input data.
     * @param deviation is the input deviation value
     * @param isLoc is whether this is a LOC signal.
     * @returns The xtk value.
     */
    private getXtk;
    /**
     * Gets the lateral distance from PPOS to the nav signal.
     * @returns The distance value in nautical miles.
     */
    private getNavDistance;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
    /**
     * Checks if we might be getting a wild deviation because of the zone of confusion and allows APNavDirector some time to resolve.
     * @returns Whether we might be in the zone of confusion.
     */
    private checkForZoneOfConfusion;
    /**
     * Method to monitor nav events to keep track of NAV related data needed for guidance.
     */
    private monitorEvents;
}

/**
 * An autopilot wing leveler director.
 */
declare class APLvlDirector implements PlaneDirector {
    private readonly bus;
    private isToGaMode;
    private static readonly BANK_SERVO_RATE;
    state: DirectorState;
    /** A callback called when the wing leveler director activates. */
    onActivate?: () => void;
    /** A callback called when the wing leveler director arms. */
    onArm?: () => void;
    private currentBankRef;
    private desiredBank;
    private readonly bankServo;
    /**
     * Creates an instance of the wing leveler.
     * @param bus The event bus to use with this instance.
     * @param isToGaMode Whether this director is being used as a TO/GA lateral mode
     * (and thus shouldn't set the 'AUTOPILOT WING LEVELER' simvar)
     */
    constructor(bus: EventBus, isToGaMode?: boolean);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    private setBank;
}

/**
 * A VNAV Path autopilot director.
 */
declare class APVNavPathDirector implements PlaneDirector {
    private readonly bus;
    private readonly apValues;
    state: DirectorState;
    /** @inheritdoc */
    onActivate?: () => void;
    /** @inheritdoc */
    onArm?: () => void;
    /** @inheritdoc */
    onDeactivate?: () => void;
    protected deviation: number;
    protected fpa: number;
    protected verticalWindAverage: SimpleMovingAverage;
    protected tas: number;
    protected groundSpeed: number;
    /**
     * Creates an instance of the APVNavPathDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus: EventBus, apValues: APValues);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Gets a desired pitch from the FPA, AOA and Deviation.
     * @returns The desired pitch angle.
     */
    protected getDesiredPitch(): number;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    protected setPitch(targetPitch: number): void;
}

/**
 * An autopilot TOGA Pitch Director to be used for either a vertical TO or GA mode.
 */
declare class APTogaPitchDirector implements PlaneDirector {
    private readonly targetPitchValue;
    state: DirectorState;
    /** A callback called when the director activates. */
    onActivate?: () => void;
    /** A callback called when the director arms. */
    onArm?: () => void;
    /**
     * Creates an instance of the LateralDirector.
     * @param targetPitchValue the pitch to set, in positive degrees, by this director.
     */
    constructor(targetPitchValue?: number);
    /**
     * Activates this director.
     */
    activate(): void;
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm(): void;
    /**
     * Deactivates this director.
     */
    deactivate(): void;
    /**
     * Updates this director.
     */
    update(): void;
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    private setPitch;
}

/**
 * A bank angle controller that maintains a constant radius turn.
 */
declare class ArcTurnController {
    private readonly bankController;
    private readonly precessionController;
    private previousTime?;
    private previousRadiusError?;
    private readonly filter;
    /**
     * Gets the bank angle output for a given radius error.
     * @param radiusError The radius error.
     * @returns The bank angle output.
     */
    getOutput(radiusError: number): number;
    /**
     * Resets the controller.
     */
    reset(): void;
}

/**
 * VNav Path Calculator Interface
 */
interface VNavPathCalculator {
    /** The default FPA for this path calculator */
    flightPathAngle: number;
    /** The maximum FPA allowed for path calculator */
    maxFlightPathAngle: number;
    /** An event fired when a vertical plan has been built or rebuilt, with the index of the plan as the event data. */
    readonly planBuilt: ReadonlySubEvent<this, number>;
    /** An event fired when a path has been calculated, with the index of the plan as the event data. */
    readonly vnavCalculated: ReadonlySubEvent<this, number>;
    /**
     * Gets a vertical flight plan by index, or throws not found if the plan does not exist.
     * @param planIndex The vertical flight plan index.
     * @returns The requested vertical flight plan.
     * @throws Not found if the flight plan index is not valid.
     */
    getVerticalFlightPlan(planIndex: number): VerticalFlightPlan;
    /**
     * Creates an empty vertical plan at a specified index.
     * @param planIndex The Vertical Plan Index to create.
     * @returns The newly created Vertical Plan.
     */
    createVerticalPlan(planIndex: number): VerticalFlightPlan;
    /**
     * Gets the index of the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The index of the VNAV constraint defining the target VNAV altitude for the specified flight plan leg, or
     * `-1` if one could not be found.
     */
    getTargetConstraintIndex(planIndex: number, globalLegIndex: number): number;
    /**
     * Gets the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The VNAV constraint defining the target VNAV altitude for the specified flight plan leg, or `undefined`
     * if one could not be found.
     */
    getTargetConstraint(planIndex: number, globalLegIndex: number): VNavConstraint | undefined;
    /**
     * Gets the VNAV target altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The VNAV target altitude for the specified flight plan leg, or `undefined` if none exists.
     */
    getTargetAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /**
     * Gets and returns the Current Vertical Flight Phase.
     * @param planIndex The vertical flight plan index.
     * @returns the VerticalFlightPhase.
     */
    getFlightPhase(planIndex: number): VerticalFlightPhase;
    /**
     * Gets and returns the current constraint altitude in meters.
     * @param planIndex The vertical flight plan index.
     * @param globalLegIndex The global index of the leg for which to get the current constraint.
     * @returns The current constraint altitude in meters, or `undefined` if there is no current constraint.
     */
    getCurrentConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /**
     * Gets and returns the current constraint details.
     * @param planIndex The vertical flight plan index.
     * @param globalLegIndex is the global leg index to check.
     * @returns the VNavConstraintDetails.
     */
    getCurrentConstraintDetails(planIndex: number, globalLegIndex: number): AltitudeConstraintDetails;
    /**
     * Gets and returns the next constraint altitude in meters.
     * @param planIndex The vertical flight plan index.
     * @param globalLegIndex The global index of the leg for which to get the next constraint.
     * @returns The next constraint altitude in meters or `undefined` if there is no next constraint.
     */
    getNextConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /**
     * Gets the next altitude limit for the current phase of flight. (used to calculate the required VS and is not always the next constraint)
     * In descent, this will return the next above altitude in the vertical plan.
     * In climb, this will return the next below altitude in the vertical plan.
     * @param planIndex The vertical flight plan index.
     * @param activeLateralLeg The current active lateral leg.
     * @returns The VNavConstraint not to exceed appropriate to the current phase of flight, or undefined if one does not exist.
     */
    getNextRestrictionForFlightPhase(planIndex: number, activeLateralLeg: number): VNavConstraint | undefined;
    /**
     * Gets the first VNAV Constraint Altitude.
     * @param planIndex The vertical flight plan index.
     * @returns The first VNAV constraint altitude in the plan.
     */
    getFirstDescentConstraintAltitude(planIndex: number): number | undefined;
    /**
     * Activates a vertical direct to a constraint index.
     * @param planIndex The vertical flight plan index.
     * @param constraintGlobalLegIndex The global leg index of the constraint to go direct to.
     */
    activateVerticalDirect(planIndex: number, constraintGlobalLegIndex: number): void;
    /**
     * Request an out-of-cycle path computation for a specified vertical flight plan.
     * @param planIndex The vertical flight plan index.
     * @returns Whether or not the computation was completed successfully.
     */
    requestPathCompute(planIndex: number): boolean;
}

/**
 * Handles the calculation of the VNAV flight path for VNAV Implemetations that use only the bottom altitude of each constraint.
 */
declare class BottomTargetPathCalculator implements VNavPathCalculator {
    private readonly bus;
    private readonly flightPlanner;
    private readonly primaryPlanIndex;
    /** The Vertical Flight Plans managed by this Path Calculator */
    private verticalFlightPlans;
    /** The default or user set FPA for this path calculator */
    flightPathAngle: number;
    /** The maximum FPA allowed for path calculator */
    maxFlightPathAngle: number;
    /** The aircraft's current altitude in meters. */
    private currentAltitude;
    /** @inheritdoc */
    readonly planBuilt: ReadonlySubEvent<this, number>;
    /** @inheritdoc */
    readonly vnavCalculated: ReadonlySubEvent<this, number>;
    private flightPlanIterator;
    /**
     * Creates an instance of the VNavPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param defaultFpa The default FPA for this path calculator.
     * @param defaultMaxFpa The default maximum FPA value for this path calculator.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, primaryPlanIndex: number, defaultFpa: number, defaultMaxFpa: number);
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex: number): VerticalFlightPlan;
    /** @inheritdoc */
    createVerticalPlan(planIndex: number): VerticalFlightPlan;
    /** @inheritdoc */
    setCurrentAlongLegDistance(planIndex: number, distance: number): void;
    /** @inheritdoc */
    getTargetConstraintIndex(planIndex: number, globalLegIndex: number): number;
    /** @inheritdoc */
    getTargetConstraint(planIndex: number, globalLegIndex: number): VNavConstraint | undefined;
    /** @inheritdoc */
    getTargetAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getFlightPhase(planIndex: number): VerticalFlightPhase;
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getCurrentConstraintDetails(planIndex: number, globalLegIndex: number): AltitudeConstraintDetails;
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex: number, activeLateralLeg: number): VNavConstraint | undefined;
    /** @inheritdoc */
    activateVerticalDirect(planIndex: number, constraintGlobalLegIndex: number): void;
    /**
     * Sets an FPA on the current constraint when an event is received from the VNAV Profile Window via the bus.
     * @param fpa The FPA to set the constraint to manually.
     */
    private setFpaHandler;
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    private onPlanChanged;
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    private onPlanCalculated;
    /**
     * Resets the VNAV plan segments, legs, and constraints based on the new plan.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param verticalDirectIndex The vertical direct index, if any
     */
    private buildVerticalPath;
    /**
     * Computes the VNAV descent path.
     * @param verticalPlan The Vertical Flight Plan
     * @param lateralPlan The Lateral Flight Plan
     */
    private computeVnavPath;
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param verticalPlan The Vertical Flight Plan
     * @param lateralPlan The Lateral Flight Plan
     */
    private fillLegAndConstraintDistances;
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    private computeFlightPathAngles;
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex: number): number | undefined;
    /**
     * Gets the constraint for a leg altitude restriction.
     * @param leg The leg to get the constraint for.
     * @returns The altitude constraint.
     */
    private getConstraintAltitude;
    /**
     * Checks whether any previously invalid constraints in the flight plan have become valid.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     * @returns Whether any previously invalid constraints in the flight plan have become valid.
     */
    private needRevalidateConstraints;
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    private static isConstraintHigherThanPriorConstraint;
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    private static doesConstraintRequireInvalidFpa;
    /**
     * Creates a new empty constraint.
     * @param index The leg index of the constraint.
     * @param targetAltitude The altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    private createConstraint;
    /**
     * Creates a new VNAV plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    private createLeg;
    /**
     * Sends an event when a vertical plan has been built or rebuilt.
     * @param planIndex The index of the plan that was built.
     */
    private notifyBuilt;
    /**
     * Sends an event when a vertical plan has been calculated.
     * @param planIndex The index of the plan that was calculated.
     */
    private notifyCalculated;
    /** @inheritdoc */
    requestPathCompute(planIndex: number): boolean;
}

/**
 * Handles the calculation of a Glide Path.
 */
declare class GlidePathCalculator {
    private readonly bus;
    private readonly flightPlanner;
    private readonly primaryPlanIndex;
    private mapLegIndex;
    private fafLegIndex;
    private readonly planePos;
    glidepathFpa: number;
    private flightPlanIterator;
    /**
     * Creates an instance of the GlidePathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary plan index to use for calculating GlidePath.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, primaryPlanIndex: number);
    private onPlanChanged;
    private onPlanCalculated;
    /**
     * Gets the current Glidepath distance in meters.
     * @param index The global index of the active leg.
     * @param distanceAlongLeg The aircraft's current distance along the active leg, in meters.
     * @returns The current Glidepath distance in meters.
     */
    getGlidepathDistance(index: number, distanceAlongLeg: number): number;
    /**
     * Gets the Glidepath desired altitude in meters.
     * @param distance The current Glidepath distance in meters.
     * @returns The current Glidepath desired altitude in meters.
     */
    getDesiredGlidepathAltitude(distance: number): number;
    /**
     * Gets the Glidepath runway altitude in meters.
     * @returns The Glidepath runway altitude in meters.
     */
    getRunwayAltitude(): number;
    /**
     * Calculates the Glidepath flight path angle using the destination elevation
     * and FAF altitude restriction.
     * @param plan The plan to calculate from.
     */
    private calcGlidepathFpa;
}

/**
 * Options for a SmoothingPathCalculator.
 */
declare type SmoothingPathCalculatorOptions = {
    /** The default flight path angle, in degrees, for descent paths. Increasingly positive values indicate steeper descents. */
    defaultFpa: number;
    /**
     * The minimum allowed flight path angle, in degrees, for descent paths. Increasingly positive values indicate
     * steeper descents. Paths that require angles less than the minimum value will be assigned the default flight path
     * angle instead to create a step-down descent. Vertical direct-to paths are exempt from the minimum FPA requirement.
     */
    minFpa: number;
    /**
     * The maximum allowed flight path angle, in degrees, for descent paths. Increasingly positive values indicate
     * steeper descents. Paths that require angles greater than the maximum value will have their FPAs clamped to the
     * maximum value, even if this would create a discontinuity in the vertical profile.
     */
    maxFpa: number;
    /** Whether to force the first constraint in the approach to an AT constraint. */
    forceFirstApproachAtConstraint: boolean;
    /** The offset of a lateral direct-to leg from its direct-to target leg. */
    directToLegOffset: number;
    /**
     * A function which checks whether a lateral flight plan leg is eligible for VNAV. VNAV descent paths will not be
     * calculated through VNAV-ineligible legs.
     */
    isLegEligible: (lateralLeg: LegDefinition) => boolean;
    /**
     * A function which checks whether an altitude constraint defined for a lateral flight plan leg should be used for
     * VNAV.
     * @param lateralPlan The lateral flight plan that hosts the altitude constraint.
     * @param lateralLeg The lateral flight plan leg that hosts the altitude constraint.
     * @param globalLegIndex The global index of the lateral flight plan leg that hosts the altitude constraint.
     * @param segment The lateral flight plan segment containing the flight plan leg that hosts the altitude constraint.
     * @param segmentLegIndex The index of the lateral flight plan leg that hosts the altitude constraint in its
     * containing segment.
     * @returns Whether the altitude constraint defined for the specified lateral flight plan leg should be used for
     * VNAV.
     */
    shouldUseConstraint: (lateralPlan: FlightPlan, lateralLeg: LegDefinition, globalLegIndex: number, segment: FlightPlanSegment, segmentLegIndex: number) => boolean;
    /**
     * A function which checks whether a climb constraint should be invalidated. Invalidated constraints will not appear
     * in the vertical flight plan.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param firstDescentConstraintIndex The index of the first descent constraint in the vertical flight plan, if one
     * exists.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * constraints of the same category (climb or missed approach) are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * constraints of the same category (climb or missed approach) are included.
     * @returns Whether the specified climb constraint should be invalidated.
     */
    invalidateClimbConstraint: (constraint: VNavConstraint, index: number, constraints: readonly VNavConstraint[], firstDescentConstraintIndex: number, priorMinAltitude: number, priorMaxAltitude: number) => boolean;
    /**
     * A function which checks whether a descent constraint should be invalidated. Invalidated constraints will not
     * appear in the vertical flight plan.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param requiredFpa The minimum flight path angle, in degrees, required to meet the maximum altitude of the
     * constraint to check, assuming a descent starting from the constraint defining the most recent prior minimum
     * altitude. Positive values indicate a descending path. If there is no required FPA because there is no defined
     * prior minimum altitude or maximum altitude for the constraint to check, or if the constraint to check is higher
     * than the prior minimum altitude, then this value will equal zero.
     * @param maxFpa The maximum allowed flight path angle, in degrees. Positive values indicate a descending path.
     * @returns Whether the specified descent constraint should be invalidated.
     */
    invalidateDescentConstraint: (constraint: VNavConstraint, index: number, constraints: readonly VNavConstraint[], priorMinAltitude: number, priorMaxAltitude: number, requiredFpa: number, maxFpa: number) => boolean;
};
/**
 * Handles the calculation of the VNAV flight path for Path Smoothing VNAV Implementations.
 */
declare class SmoothingPathCalculator implements VNavPathCalculator {
    protected readonly bus: EventBus;
    protected readonly flightPlanner: FlightPlanner;
    protected readonly primaryPlanIndex: number;
    protected static readonly DEFAULT_DEFAULT_FPA = 3;
    protected static readonly DEFAULT_MIN_FPA = 1.5;
    protected static readonly DEFAULT_MAX_FPA = 6;
    protected static readonly DEFAULT_DIRECT_TO_LEG_OFFSET = 3;
    /** The Vertical Flight Plans managed by this Path Calculator */
    protected readonly verticalFlightPlans: (VerticalFlightPlan | undefined)[];
    /** The default flight path angle, in degrees, for descent paths. Increasingly positive values indicate steeper descents. */
    flightPathAngle: number;
    /**
     * The minimum allowed flight path angle, in degrees, for descent paths. Increasingly positive values indicate
     * steeper descents. Paths that require angles less than the minimum value will be assigned the default flight path
     * angle instead to create a step-down descent. Vertical direct-to paths are exempt from the minimum FPA requirement.
     */
    minFlightPathAngle: number;
    /**
     * The maximum allowed flight path angle, in degrees, for descent paths. Increasingly positive values indicate
     * steeper descents. Paths that require angles greater than the maximum value will have their FPAs clamped to the
     * maximum value, even if this would create a discontinuity in the vertical profile.
     */
    maxFlightPathAngle: number;
    /** @inheritdoc */
    readonly planBuilt: ReadonlySubEvent<this, number>;
    /** @inheritdoc */
    readonly vnavCalculated: ReadonlySubEvent<this, number>;
    protected readonly forceFirstApproachAtConstraint: boolean;
    protected readonly directToLegOffset: number;
    protected isLegEligibleFunc: (lateralLeg: LegDefinition) => boolean;
    protected shouldUseConstraintFunc: (lateralPlan: FlightPlan, lateralLeg: LegDefinition, globalLegIndex: number, segment: FlightPlanSegment, segmentLegIndex: number) => boolean;
    protected invalidateClimbConstraintFunc: (constraint: VNavConstraint, index: number, constraints: readonly VNavConstraint[], firstDescentConstraintIndex: number, priorMinAltitude: number, priorMaxAltitude: number) => boolean;
    protected invalidateDescentConstraintFunc: (constraint: VNavConstraint, index: number, constraints: readonly VNavConstraint[], priorMinAltitude: number, priorMaxAltitude: number, requiredFpa: number, maxFpa: number) => boolean;
    protected readonly legAltitudes: [number, number];
    protected readonly applyPathValuesResult: [number | undefined, number];
    /**
     * Creates an instance of SmoothingPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param options Options for the calculator. Options that are not explicitly provided default to the following:
     * * `defaultFpa`: 3 degrees.
     * * `minFpa`: 1.5 degrees.
     * * `maxFpa`: 6 degrees.
     * * `excludeFirstLegConstraint`: `false`.
     * * `forceFirstApproachAtConstraint`: `false`.
     * * `directToLegOffset`: `3`.
     * * `isLegEligible`: a function which designates a leg as eligible if and only if it is not a discontinuity leg or
     * a manual termination leg that ends in a discontinuity.
     * * `shouldUseConstraint`: a function which always returns `true`.
     * * `invalidateClimbConstraint`: a function which does not invalidate any climb constraint.
     * * `invalidateDescentConstraint`: a function which invalidates a descent constraint if and only if it requires an
     * ascending path or a flight path angle greater than the maximum in order to meet it from the preceding constraint.
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, primaryPlanIndex: number, options?: Partial<SmoothingPathCalculatorOptions>);
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex: number): VerticalFlightPlan;
    /** @inheritdoc */
    createVerticalPlan(planIndex: number): VerticalFlightPlan;
    /** @inheritdoc */
    requestPathCompute(planIndex: number): boolean;
    /**
     * Gets the index of the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The index of the VNAV constraint defining the target VNAV altitude for a flight plan leg, or `-1` if one
     * could not be found.
     */
    getTargetConstraintIndex(planIndex: number, globalLegIndex: number): number;
    /**
     * Gets the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The VNAV constraint defining the target VNAV altitude for a flight plan leg, or `undefined` if one could
     * not be found.
     */
    getTargetConstraint(planIndex: number, globalLegIndex: number): VNavConstraint | undefined;
    /** @inheritdoc */
    getTargetAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getFlightPhase(planIndex: number): VerticalFlightPhase;
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getCurrentConstraintDetails(planIndex: number, globalLegIndex: number): AltitudeConstraintDetails;
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex: number, globalLegIndex: number): number | undefined;
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex: number, activeLateralLeg: number): VNavConstraint | undefined;
    /** @inheritdoc */
    activateVerticalDirect(planIndex: number, constraintGlobalLegIndex: number, fpa?: number): void;
    /**
     * Cancels the existing VNAV direct-to for a vertical flight plan.
     * @param planIndex The index of the vertical flight plan for which to cancel the VNAV direct-to.
     */
    cancelVerticalDirect(planIndex: number): void;
    /**
     * Sets this calculator's default flight path angle.
     * @param fpa The new default flight path angle, in degrees. Increasingly positive values indicate steeper descents.
     */
    protected setDefaultFpa(fpa: number): void;
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    protected onPlanChanged(planIndex: number, legChangeEvent?: FlightPlanLegEvent, segmentChangeEvent?: FlightPlanSegmentEvent): void;
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    protected onPlanCalculated(event: FlightPlanCalculatedEvent): void;
    /**
     * Sends an event notifying subscribers that a vertical flight plan was built or rebuilt.
     * @param planIndex The index of the plan that was built.
     */
    protected notifyBuilt(planIndex: number): void;
    /**
     * Sends an event notifying subscribers that a vertical flight plan was calculated.
     * @param planIndex The index of the plan that was calculated.
     */
    protected notifyCalculated(planIndex: number): void;
    /**
     * Builds a vertical flight plan from a lateral flight plan and sends an event notifying subscribers that the plan
     * was built.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    protected buildVerticalFlightPlanAndNotify(lateralPlan: FlightPlan, verticalPlan: VerticalFlightPlan): void;
    /**
     * Builds a vertical flight plan from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    protected buildVerticalFlightPlan(lateralPlan: FlightPlan, verticalPlan: VerticalFlightPlan): void;
    /**
     * Resets the Vertical Flight Plan, populates the vertical segments and legs, finds and builds the vertical constraints.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    protected buildVerticalLegsAndConstraints(lateralPlan: FlightPlan, verticalPlan: VerticalFlightPlan): void;
    /**
     * Builds a VNAV constraint for a lateral flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the lateral flight plan leg for which to build the constraint.
     * @param lateralLeg The lateral flight plan leg for which to build the constraint.
     * @param constraintAltitudes The constraint altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @param name The name of the new constraint.
     * @returns A new VNAV constraint for the specified lateral flight plan leg.
     */
    protected buildConstraint(verticalPlan: VerticalFlightPlan, globalLegIndex: number, lateralLeg: LegDefinition, constraintAltitudes: [number, number], name: string): VNavConstraint;
    /**
     * Computes the vertical path for a flight plan and if successful, sends an event notifying subscribers that the plan
     * was calculated.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     * @returns Whether a path was successfully computed.
     */
    protected computePathAndNotify(lateralPlan: FlightPlan, verticalPlan: VerticalFlightPlan): boolean;
    /**
     * Computes the vertical path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     * @returns Whether a path was successfully computed.
     */
    protected computePath(lateralPlan: FlightPlan, verticalPlan: VerticalFlightPlan): boolean;
    /**
     * Computes the descent path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    protected computeDescentPath(lateralPlan: FlightPlan, verticalPlan: VerticalFlightPlan): void;
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    protected fillLegDistances(lateralPlan: FlightPlan, verticalPlan: VerticalFlightPlan): void;
    /**
     * Finds and removes invalid constraints from the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    protected findAndRemoveInvalidConstraints(verticalPlan: VerticalFlightPlan): void;
    /**
     * Finds previously invalidated constraints and re-inserts them into the vertical flight plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     */
    protected reinsertInvalidConstraints(verticalPlan: VerticalFlightPlan, lateralPlan: FlightPlan): void;
    /**
     * Fills the VNAV plan constraint distances.
     * @param verticalPlan The Vertical Flight Plan.
     */
    protected populateConstraints(verticalPlan: VerticalFlightPlan): void;
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    protected computeFlightPathAngles(verticalPlan: VerticalFlightPlan): boolean;
    /**
     * Attempts to extend and terminate a constant-FPA path from an existing target constraint at another constraint,
     * applying flight path angles and target altitudes to each constraint along the path. The target constraint defines
     * the FPA of the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param terminatingConstraintIndex The index of the constraint at which to terminate the path.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param terminatingConstraintIsTarget Whether to designate the terminating constraint as a target constraint if the
     * path is not terminated early. If the path is terminated early, this argument is ignored and the constraint at
     * which the path was terminated early is always designated as a target constraint.
     * @returns The index of the constraint at which the constant-FPA path was actually terminated.
     */
    protected terminateSmoothedPath(verticalPlan: VerticalFlightPlan, targetConstraintIndex: number, terminatingConstraintIndex: number, maxAltitude: number, terminatingConstraintIsTarget: boolean): number;
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex: number): number | undefined;
    /**
     * Gets the constraint altitudes for a lateral flight plan leg.
     * @param leg A lateral flight plan leg.
     * @param out The tuple to which to write the altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @returns The constraint altitudes, in meters, for the specified flight plan leg, as
     * `[minimum_altitude, maximum_altitude]`, or `undefined` if the leg does not define any altitude constraints.
     */
    protected static getConstraintAltitudes(leg: LegDefinition, out: [number, number]): [number, number] | undefined;
    /**
     * Forces a constraint to an AT constraint.
     * @param constraint The constraint to force to an AT constraint.
     */
    protected static forceAtConstraint(constraint: VNavConstraint): void;
    /**
     * Gets the global index of a flight plan's lateral direct-to target leg.
     * @param lateralPlan A flight plan.
     * @returns The global index of the flight plan's lateral direct-to target leg, or `undefined` if the plan does not
     * have an existing lateral direct-to.
     */
    protected static getDirectToTargetLegIndex(lateralPlan: FlightPlan): number | undefined;
    /**
     * Checks if there is a lateral direct-to leg in the flight plan and if so, flags the corresponding vertical flight
     * plan leg as such and marks the first descent constraint
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param directToLegOffset The offset of the lateral direct-to leg from the direct-to target leg.
     */
    protected static handleDirectToLegInVerticalPlan(lateralPlan: FlightPlan, verticalPlan: VerticalFlightPlan, directToLegOffset: number): void;
    /**
     * Checks whether a leg constraint is part of the missed approach.
     * @param lateralSegment The lateral flight plan segment to which the constraint's leg belongs.
     * @param lateralLeg The lateral flight plan leg to which the constraint belongs.
     * @returns Whether the leg constraint is part of the missed approach.
     */
    protected static isConstraintInMissedApproach(lateralSegment: FlightPlanSegment, lateralLeg: LegDefinition): boolean;
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    protected static isConstraintHigherThanPriorConstraint(previousConstrant: VNavConstraint, currentConstraint: VNavConstraint): boolean;
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    protected static doesConstraintRequireInvalidFpa(previousConstrant: VNavConstraint, currentConstraint: VNavConstraint, verticalPlan: VerticalFlightPlan, maxFpa: number): boolean;
    /**
     * The default function which checks whether a lateral flight plan leg is eligible for VNAV.
     * @param lateralLeg A lateral flight plan leg.
     * @returns Whether the specified leg is eligible for VNAV.
     */
    static isLegVnavEligible(lateralLeg: LegDefinition): boolean;
    /**
     * The default function which checks whether a climb constraint should be invalidated. This function always returns
     * `false`.
     * @returns Whether the specified climb constraint should be invalidated (always `false`).
     */
    static invalidateClimbConstraint(): boolean;
    /**
     * The default function which checks whether a descent constraint should be invalidated.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param requiredFpa The minimum flight path angle, in degrees, required to meet the maximum altitude of the
     * constraint to check, assuming a descent starting from the constraint defining the most recent prior minimum
     * altitude. Positive values indicate a descending path. If there is no required FPA because there is no defined
     * prior minimum altitude or maximum altitude for the constraint to check, or if the constraint to check is higher
     * than the prior minimum altitude, then this value will equal zero.
     * @param maxFpa The maximum allowed flight path angle, in degrees. Positive values indicate a descending path.
     * @returns Whether the specified descent constraint should be invalidated.
     */
    static invalidateDescentConstraint(constraint: VNavConstraint, index: number, constraints: readonly VNavConstraint[], priorMinAltitude: number, priorMaxAltitude: number, requiredFpa: number, maxFpa: number): boolean;
    /**
     * Finds the maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to a
     * given constraint, among all constraints prior to and including (in flight plan order) the given constraint. If a
     * vertical direct constraint is among the candidates, its minimum altitude is used if it does not define a maximum
     * altitude.
     * @param verticalPlan The vertical flight plan.
     * @param constraintIndex The index of the constraint for which to find the closest prior maximum altitude.
     * @param firstDescentConstraintIndex The index of the first descent constraint.
     * @returns The maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to the
     * specified constraint, among all constraints prior to and including (in flight plan order) the specified
     * constraint, or `Infinity` if there is no such altitude.
     */
    protected static findPriorMaxAltitude(verticalPlan: VerticalFlightPlan, constraintIndex: number, firstDescentConstraintIndex: number): number;
    /**
     * Applies flight path angle and target altitude values to a sequence of constraints connected to a target constraint
     * by a constant-FPA path extending backwards from the target constraint. The target constraint defines the FPA of
     * the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param endConstraintIndex The index of the constraint at which the constant-FPA path ends, exclusive.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param out The tuple to which to write the result of the operation.
     * @returns `[index, distance]`, where `index` is the index of the constraint at which the path was terminated due to
     * violation of the maximum target altitude, or `undefined` if no constraint violated the maximum altitude, and
     * `distance` is the total distance of the path, in meters.
     */
    protected static applyPathValuesToSmoothedConstraints(verticalPlan: VerticalFlightPlan, targetConstraintIndex: number, endConstraintIndex: number, maxAltitude: number, out: [number | undefined, number]): [number | undefined, number];
}

/**
 * Sim var names for LNAV-related data.
 */
declare enum LNavDataVars {
    /** The current nominal desired track, in degrees true. */
    DTKTrue = "L:WT_LNavData_DTK_True",
    /** The current nominal desired track, in degrees magnetic. */
    DTKMagnetic = "L:WT_LNavData_DTK_Mag",
    /**
     * The current nominal crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    XTK = "L:WT_LNavData_XTK",
    /** The current CDI scale. */
    CDIScale = "L:WT_LNavData_CDI_Scale",
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */
    WaypointBearingTrue = "L:WT_LNavData_Waypoint_Bearing_True",
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees magnetic. */
    WaypointBearingMagnetic = "L:WT_LNavData_Waypoint_Bearing_Mag",
    /** The nominal distance remaining to the next waypoint currently tracked by LNAV. */
    WaypointDistance = "L:WT_LNavData_Waypoint_Distance",
    /** The nominal distance remaining to the destination. */
    DestinationDistance = "L:WT_LNavData_Destination_Distance"
}
/**
 * Events derived from LNAV-related data sim vars.
 */
interface LNavDataSimVarEvents {
    /** The current nominal desired track, in degrees true. */
    lnavdata_dtk_true: number;
    /** The current nominal desired track, in degrees magnetic. */
    lnavdata_dtk_mag: number;
    /**
     * The current nominal crosstrack error, in nautical miles. Negative values indicate deviation to the left, as viewed
     * when facing in the direction of the track. Positive values indicate deviation to the right.
     */
    lnavdata_xtk: number;
    /** The current CDI scale, in nautical miles. */
    lnavdata_cdi_scale: number;
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */
    lnavdata_waypoint_bearing_true: number;
    /** The nominal bearing to the next waypoint tracked by LNAV, in degrees magnetic. */
    lnavdata_waypoint_bearing_mag: number;
    /** The nominal distance remaining to the next waypoint currently tracked by LNAV, in nautical miles. */
    lnavdata_waypoint_distance: number;
    /** The nominal distance remaining to the destination, in nautical miles. */
    lnavdata_destination_distance: number;
}
/**
 * Events related to LNAV data.
 */
interface LNavDataEvents extends LNavDataSimVarEvents {
    /** The nominal ident of the next waypoint tracked by LNAV. */
    lnavdata_waypoint_ident: string;
}
/**
 * A publisher for LNAV-related data sim var events.
 */
declare class LNavDataSimVarPublisher extends SimVarPublisher<LNavDataSimVarEvents> {
    private static simvars;
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus: EventBus);
}

/**
 * Events related to VNAV data.
 */
interface VNavDataEvents {
    /** Whether or not a loaded and active GPS Approach can support vertical guidance (GP). */
    approach_supports_gp: boolean;
    /** Whether VNAV path details should be displayed. */
    vnav_path_display: boolean;
    /** The active leg vnav calculated target altitude in meters. */
    vnav_active_leg_alt: number;
    /** Whether or not vertical guidance (GP) is currently available for display and guidance. */
    gp_available: boolean;
    /** The full scale deflection of the vertical GSI due to GPS glidepath deviation, in feet. */
    gp_gsi_scaling: number;
}
/** A publisher for VNAV-related data events */
declare class VNavDataEventPublisher extends BasePublisher<VNavDataEvents> {
    /**
     * Create a publisher for VNAV-related data.
     * @param bus The EventBus to publish to.
     */
    constructor(bus: EventBus);
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent<K extends keyof VNavDataEvents>(event: K, value: VNavDataEvents[K]): void;
}

/**
 * Sim var names for VNAV data.
 */
declare enum VNavVars {
    /** The vertical deviation in feet. */
    VerticalDeviation = "L:WTAP_VNav_Vertical_Deviation",
    /** The VNAV target altitude in feet. */
    TargetAltitude = "L:WTAP_VNav_Target_Altitude",
    /** The VNAV path mode. */
    PathMode = "L:WTAP_VNav_Path_Mode",
    /** The VNAV State. */
    VNAVState = "L:WTAP_VNav_State",
    /** Whether a VNAV Path Exists for the current leg. */
    PathAvailable = "L:WTAP_VNav_Path_Available",
    /** The VNAV current altitude capture type. */
    CaptureType = "L:WTAP_VNav_Alt_Capture_Type",
    /** The distance to the next TOD in meters, or -1 if one does not exist. */
    TODDistance = "L:WTAP_VNav_Distance_To_TOD",
    /** The distance to the next BOD in meters, or -1 if one does not exist. */
    BODDistance = "L:WTAP_VNav_Distance_To_BOD",
    /** The index of the leg for the next TOD. */
    TODLegIndex = "L:WTAP_VNav_TOD_Leg_Index",
    /** The distance from the end of the TOD leg that the TOD is, in meters. */
    TODDistanceInLeg = "L:WTAP_VNav_TOD_Distance_In_Leg",
    /** The index of the leg for the next BOD. */
    BODLegIndex = "L:WTAP_VNav_BOD_Leg_Index",
    /** The distance to the next TOC in meters, or -1 if one does not exist. */
    TOCDistance = "L:WTAP_VNav_Distance_To_TOC",
    /** The distance to the next BOC in meters, or -1 if one does not exist. */
    BOCDistance = "L:WTAP_VNav_Distance_To_BOC",
    /** The index of the leg for the next TOC. */
    TOCLegIndex = "L:WTAP_VNav_TOC_Leg_Index",
    /** The distance from the end of the TOC leg that the TOC is, in meters. */
    TOCDistanceInLeg = "L:WTAP_VNav_TOC_Distance_In_Leg",
    /** The index of the leg for the next BOC. */
    BOCLegIndex = "L:WTAP_VNav_BOC_Leg_Index",
    /** The index of the leg for the next constraint. */
    CurrentConstraintLegIndex = "L:WTAP_VNav_Constraint_Leg_Index",
    /** The current constraint altitude, in feet. */
    CurrentConstraintAltitude = "L:WTAP_VNav_Constraint_Altitude",
    /** The next constraint altitude, in feet. */
    NextConstraintAltitude = "L:WTAP_VNav_Next_Constraint_Altitude",
    /** The current required flight path angle, in degrees. */
    FPA = "L:WTAP_VNav_FPA",
    /** The required VS to the current constraint, in FPM. */
    RequiredVS = "L:WTAP_VNAV_Required_VS",
    /** The VNAV approach guidance mode. */
    GPApproachMode = "L:WTAP_GP_Approach_Mode",
    /** The current LPV vertical deviation in feet. */
    GPVerticalDeviation = "L:WTAP_GP_Vertical_Deviation",
    /** The current remaining LPV distance in meters. */
    GPDistance = "L:WTAP_GP_Distance",
    /** The current LPV FPA, in degrees. */
    GPFpa = "L:WTAP_GP_FPA",
    /** The required VS to the current constraint, in FPM. */
    GPRequiredVS = "L:WTAP_GP_Required_VS",
    /** The approach glidepath service level. */
    GPServiceLevel = "L:WTAP_GP_Service_Level"
}
/**
 * Events derived from VNAV sim vars.
 */
interface VNavSimVarEvents {
    /**
     * The vertical deviation, in feet, of the calculated VNAV path from the airplane's indicated altitude. Positive
     * values indicate the path lies above the airplane.
     */
    vnav_vertical_deviation: number;
    /** The target altitude, in feet, of the currently active VNAV constraint. */
    vnav_target_altitude: number;
    /** The VNAV path mode. */
    vnav_path_mode: VNavPathMode;
    /** Whether a VNAV Path Exists for the current leg. */
    vnav_path_available: boolean;
    /** The VNAV state. */
    vnav_state: VNavState;
    /** The VNAV current alt capture type. */
    vnav_altitude_capture_type: VNavAltCaptureType;
    /** The distance along the flight path from the airplane's present position to the current VNAV TOD, in meters. */
    vnav_tod_distance: number;
    /** The distance from the current VNAV TOD to the end of its containing leg, in meters. */
    vnav_tod_leg_distance: number;
    /** The distance along the flight path from the airplane's present position to the next VNAV BOD, in meters. */
    vnav_bod_distance: number;
    /**
     * The global index of the flight plan leg that contains the TOD associated with the next VNAV BOD, or -1 if there is
     * no such TOD. The TOD is defined as the point along the flight path at which the aircraft will intercept the VNAV
     * profile continuing to the next BOD if it continues to fly level at its current altitude.
     */
    vnav_tod_global_leg_index: number;
    /**
     * The global index of the flight plan leg that contains the next VNAV BOD, or -1 if there is no BOD. The next BOD
     * is defined as the next point in the flight path including or after the active leg where the VNAV profile
     * transitions from a descent to a level-off, discontinuity, or the end of the flight path. The BOD is always located
     * at the end of its containing leg.
     */
    vnav_bod_global_leg_index: number;
    /** The distance along the flight path from the airplane's present position to the current VNAV TOC, in meters. */
    vnav_toc_distance: number;
    /** The distance along the flight path from the current VNAV TOC to the end of its containing leg, in meters. */
    vnav_toc_leg_distance: number;
    /** The distance along the flight path from the airplane's present position to the next VNAV BOC, in meters. */
    vnav_boc_distance: number;
    /**
     * The global index of the flight plan leg that contains the current VNAV TOC, or -1 if there is no such TOC.
     */
    vnav_toc_global_leg_index: number;
    /**
     * The global index of the flight plan leg that contains the next VNAV BOC, or -1 if there is no such BOC. The BOC
     * is always located at the beginning of its containing leg.
     */
    vnav_boc_global_leg_index: number;
    /** The global index of the leg that contains the current VNAV constraint. */
    vnav_constraint_global_leg_index: number;
    /** The VNAV current constraint altitude in feet. */
    vnav_constraint_altitude: number;
    /** The VNAV next constraint altitude in feet. */
    vnav_next_constraint_altitude: number;
    /**
     * The flight path angle, in degrees, for the currently active VNAV path segment. Positive angles represent
     * descending paths.
     */
    vnav_fpa: number;
    /**
     * The vertical speed, in feet per minute, required for the airplane to meet the next VNAV altitude constraint if it
     * starts climbing/descending from its current altitude immediately.
     */
    vnav_required_vs: number;
    /** The VNAV approach guidance mode. */
    gp_approach_mode: ApproachGuidanceMode;
    /** The current glidepath vertical deviation, in feet. */
    gp_vertical_deviation: number;
    /** The current distance to the glidepath endpoint, in feet. */
    gp_distance: number;
    /** The current glidepath FPA. */
    gp_fpa: number;
    /** The vertical speed, in feet per minute, required for the airplane to reach the glidepath target. */
    gp_required_vs: number;
    /** The approach glidepath service level. */
    gp_service_level: number;
}
/**
 * Events published by VNAV.
 */
interface VNavEvents extends VNavSimVarEvents {
    /** VNAV path calculations were updated for the specified vertical flight plan. */
    vnav_path_calculated: number;
    /** The current availability of VNAV from the director. */
    vnav_availability: VNavAvailability;
    /** The current VNAV target altitude restriction feet and type. */
    vnav_altitude_constraint_details: Readonly<AltitudeConstraintDetails>;
}
/** A publisher for VNAV sim var events. */
declare class VNavSimVarPublisher extends SimVarPublisher<VNavEvents> {
    private static simvars;
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus: EventBus);
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent<K extends keyof VNavEvents>(event: K, value: VNavEvents[K]): void;
}

/** The data needed to set a VNAV direct-to. */
interface SetVnavDirectToData {
    /** The index of the flight plan for which to set the VNAV direct-to. */
    planIndex: number;
    /**
     * The global index of the flight plan leg containing the VNAV direct-to target constraint. Using a negative index
     * will cancel any existing VNAV direct-to.
     */
    globalLegIndex: number;
    /**
     * The flight path angle, in degrees, of the VNAV direct-to. If not defined, the default VNAV FPA will be applied.
     * Ignored if `globalLegIndex` is negative.
     */
    fpa?: number;
}
/**
 * VNav Control Events.
 */
interface VNavControlEvents {
    /**
     * Sets the default FPA of VNAV descent paths, in degrees. Increasingly positive values indicate increasingly steep
     * descent paths.
     */
    vnav_set_default_fpa: number;
    /** Event to set the FPA of the current VNAV path segment. */
    vnav_set_current_fpa: number;
    /** Event to set the vnav direct to leg. */
    vnav_set_vnav_direct_to: SetVnavDirectToData;
    /** Sets whether VNAV is enabled. */
    vnav_set_state: boolean;
}
/** A publisher for VNav Control Events */
declare class VNavControlEventPublisher extends BasePublisher<VNavControlEvents> {
    /**
     * Create a publisher for VNAV-related data.
     * @param bus The EventBus to publish to.
     */
    constructor(bus: EventBus);
    /**
     * Publish a VNav Control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent<K extends keyof VNavControlEvents>(event: K, value: VNavControlEvents[K]): void;
}

/** The supported data types for a user setting. */
declare type UserSettingValue = boolean | number | string;
/**
 * A definition for a user setting.
 */
interface UserSettingDefinition<T extends UserSettingValue> {
    /** The name of this setting. */
    readonly name: string;
    /** The default value of this setting. */
    readonly defaultValue: T;
}
/**
 * A user setting.
 */
interface UserSetting<T extends UserSettingValue> extends MutableSubscribable<T> {
    /** This setting's definition. */
    readonly definition: UserSettingDefinition<T>;
    /** This setting's current value. */
    value: T;
    /** Resets this setting to its default value. */
    resetToDefault(): void;
}
/**
 * A record which maps user setting names to user setting value types.
 */
declare type UserSettingRecord = Record<any, UserSettingValue>;
/**
 * Filters a record of user settings to just those settings whose values extend a certain type.
 */
declare type UserSettingValueFilter<T extends UserSettingRecord, V> = {
    [Property in keyof T as (T[Property] extends V ? Property : never)]: T[Property];
};
/**
 * A user setting type derived from a user setting record. If the provided key does not exist in the record, a type of
 * `undefined` is returned. If the provided key is optional in the record, a union type of `UserSetting<T> | undefined`
 * is returned, where `T` is the value type mapped to the key in the record.
 */
declare type UserSettingFromRecord<R extends UserSettingRecord, K extends string> = K extends keyof R ? R[K] extends NonNullable<R[K]> ? UserSetting<R[K]> : UserSetting<NonNullable<R[K]>> | undefined : undefined;
/**
 * An entry that maps one set of setting definitions to another.
 */
declare type UserSettingMap<Aliased, Original> = {
    [Property in keyof Aliased]?: keyof Original;
};
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
interface UserSettingManager<T extends UserSettingRecord> {
    /**
     * Attempts to get a setting from this manager.
     * @param name The name of the setting to get.
     * @returns The requested setting, or `undefined` if no such setting exists.
     */
    tryGetSetting<K extends string>(name: K): UserSetting<NonNullable<T[K]>> | undefined;
    /**
     * Gets a setting from this manager.
     * @param name The name of the setting to get.
     * @returns The requested setting.
     * @throws Error if no setting with the specified name exists.
     */
    getSetting<K extends keyof T & string>(name: K): UserSetting<NonNullable<T[K]>>;
    /**
     * Gets a consumer which notifies handlers when the value of a setting changes.
     * @param name The name of a setting.
     * @returns a consumer which notifies handlers when the value of the setting changes.
     * @throws Error if no setting with the specified name exists.
     */
    whenSettingChanged<K extends keyof T & string>(name: K): Consumer<NonNullable<T[K]>>;
    /**
     * Gets an array of all settings of this manager.
     * @returns an array of all settings of this manager.
     */
    getAllSettings(): UserSetting<UserSettingValue>[];
    /**
     * Maps a subset of this manager's settings to ones with aliased names, and creates a new setting manager which
     * supports accessing the settings using their aliases.
     * @param map A map defining the aliases of a subset of this manager's settings, with aliased setting names as keys
     * and original setting names as values.
     * @returns A new setting manager which supports accessing a subset of this manager's settings using aliased names.
     */
    mapTo<M extends UserSettingRecord>(map: UserSettingMap<M, T>): UserSettingManager<M & T>;
}
/**
 * An entry for a user setting in UserSettingManager.
 */
declare type UserSettingManagerEntry<T extends UserSettingValue> = {
    /** A user setting. */
    setting: SyncableUserSetting<T>;
    /** The event topic used to sync the setting. */
    syncTopic: `usersetting_sync_${string}`;
    /** The timestamp of the most recent sync event. */
    syncTime: number;
    /** The unique ID attached to this entry's setting's initialization sync event. */
    initUid: number;
    /** The initialization subscription for the setting. */
    initSub: Subscription;
};
/**
 * Data provided for a setting sync event.
 */
declare type UserSettingManagerInitData<T extends UserSettingValue> = {
    /** The initialized value of the setting. */
    value: T;
    /** The timestamp of this initialization event. */
    syncTime: number;
    /** A unique ID attached to this initialization event. */
    uid: number;
};
/**
 * Data provided for a setting sync event.
 */
declare type UserSettingManagerSyncData<T extends UserSettingValue> = {
    /** The synced value of the setting. */
    value: T;
    /** The timestamp of this sync event. */
    syncTime: number;
    /**
     * The unique ID of the initialization event to which this sync event is responding. Only defined if this sync
     * event is an initialization response.
     */
    initUid?: number;
};
/**
 * Events used to sync user setting values across instruments.
 */
interface UserSettingManagerSyncEvents {
    /** A user setting value initialized event. */
    [setting_init: `usersetting_init_${string}`]: UserSettingManagerInitData<UserSettingValue>;
    /** A user setting value sync event. */
    [setting_sync: `usersetting_sync_${string}`]: UserSettingManagerSyncData<UserSettingValue>;
}
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
declare class DefaultUserSettingManager<T extends UserSettingRecord> implements UserSettingManager<T> {
    protected readonly bus: EventBus;
    protected readonly settings: Map<string, UserSettingManagerEntry<T[keyof T]>>;
    protected readonly publisher: Publisher<T>;
    protected readonly subscriber: EventSubscriber<T>;
    protected readonly syncPublisher: Publisher<UserSettingManagerSyncEvents>;
    protected readonly syncSubscriber: EventSubscriber<UserSettingManagerSyncEvents>;
    private keepLocal;
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings.
     * @param keepLocal If present and true, values will be kept local to the instrument on which they're set.
     */
    constructor(bus: EventBus, settingDefs: readonly UserSettingDefinition<T[keyof T]>[], keepLocal?: boolean);
    /** @inheritdoc */
    tryGetSetting<K extends string>(name: K): UserSetting<NonNullable<T[K]>> | undefined;
    /** @inheritdoc */
    getSetting<K extends keyof T & string>(name: K): UserSetting<NonNullable<T[K]>>;
    /** @inheritdoc */
    getAllSettings(): UserSetting<UserSettingValue>[];
    /** @inheritdoc */
    whenSettingChanged<K extends keyof T & string>(name: K): Consumer<NonNullable<T[K]>>;
    /** @inheritdoc */
    mapTo<M extends UserSettingRecord>(map: UserSettingMap<M, T>): MappedUserSettingManager<M, T>;
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    protected onSettingValueChanged<K extends keyof T>(entry: UserSettingManagerEntry<T[K]>, value: T[K]): void;
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    protected onSettingValueSynced<K extends keyof T>(entry: UserSettingManagerEntry<T[K]>, data: UserSettingManagerSyncData<T[K]>): void;
    /**
     * Syncs a setting using data received from a sync event.
     * @param entry The entry for the setting to sync.
     * @param data The sync event data.
     */
    protected syncSettingFromEvent<K extends keyof T>(entry: UserSettingManagerEntry<T[K]>, data: UserSettingManagerSyncData<T[K]>): void;
}
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
declare class MappedUserSettingManager<T extends UserSettingRecord, O extends UserSettingRecord> implements UserSettingManager<T & O> {
    private readonly parent;
    private readonly map;
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent: UserSettingManager<O>, map: UserSettingMap<T, O>);
    /** @inheritdoc */
    tryGetSetting<K extends string>(name: K): UserSetting<NonNullable<(T & O)[K]>> | undefined;
    /** @inheritdoc */
    getSetting<K extends keyof T & string>(name: K): UserSetting<NonNullable<(T & O)[K]>>;
    /** @inheritdoc */
    whenSettingChanged<K extends keyof T & string>(name: K): Consumer<NonNullable<(T & O)[K]>>;
    /** @inheritdoc */
    getAllSettings(): UserSetting<UserSettingValue>[];
    /** @inheritdoc */
    mapTo<M extends UserSettingRecord>(map: UserSettingMap<M, T & O>): MappedUserSettingManager<M, T & O>;
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
declare class SyncableUserSetting<T extends UserSettingValue> extends AbstractSubscribable<T> implements UserSetting<T> {
    readonly definition: UserSettingDefinition<T>;
    private readonly valueChangedCallback;
    readonly isMutableSubscribable = true;
    private _value;
    /** This setting's current value. */
    get value(): T;
    set value(v: T);
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition: UserSettingDefinition<T>, valueChangedCallback: (value: T) => void);
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value: T): void;
    /** @inheritdoc */
    get(): T;
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value: T): void;
    /** @inheritdoc */
    resetToDefault(): void;
}

/**
 * An aliased user setting manager which can dynamically (re)define the settings from which its aliased settings are
 * sourced.
 */
declare class AliasedUserSettingManager<T extends UserSettingRecord> implements UserSettingManager<T> {
    private readonly bus;
    private readonly aliasedSettings;
    private manager?;
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings. The definitions should
     * define the settings' aliased names.
     */
    constructor(bus: EventBus, settingDefs: readonly UserSettingDefinition<T[keyof T & string]>[]);
    /**
     * Defines the mappings from this manager's aliased settings to their source settings. Once the mappings are defined,
     * each aliased setting will take the value of its source setting, and setting the value of the aliased setting will
     * also set the value of the source setting. If a source setting cannot be defined for an aliased setting, the
     * aliased setting's value will be fixed to its default value and cannot be changed.
     * @param masterManager The manager hosting the settings from which this manager's aliased settings will be sourced.
     * @param map The mappings for this manager's aliased settings, as a set of key-value pairs where the keys are the
     * aliased setting names and the values are the source setting names. For any aliased setting whose name does not
     * appear as a key in the mapping, its source setting is assumed to have the same name.
     */
    useAliases<O extends UserSettingRecord>(masterManager: UserSettingManager<O>, map: UserSettingMap<T, O>): void;
    /** @inheritdoc */
    tryGetSetting<K extends string>(name: K): UserSetting<NonNullable<T[K]>> | undefined;
    /** @inheritdoc */
    getSetting<K extends keyof T & string>(name: K): UserSetting<NonNullable<T[K]>>;
    /** @inheritdoc */
    whenSettingChanged<K extends keyof T & string>(name: K): Consumer<NonNullable<T[K]>>;
    /** @inheritdoc */
    getAllSettings(): UserSetting<UserSettingValue>[];
    /** @inheritdoc */
    mapTo<M extends Record<any, UserSettingValue>>(map: UserSettingMap<M, T>): UserSettingManager<M & T>;
}

/**
 * A manager for user settings that are saved and persistent across flight sessions. The manager facilitates saving
 * and loading setting values to and from multiple keyed save slots and also supports auto-saving. Uses Data Store to
 * store saved setting values.
 */
declare class UserSettingSaveManager {
    private static readonly DATASTORE_PREFIX;
    private readonly entries;
    private readonly autoSaveKeys;
    private isAlive;
    /**
     * Constructor.
     * @param settings This manager's managed settings.
     * @param bus The event bus.
     */
    constructor(settings: UserSetting<UserSettingValue>[], bus: EventBus);
    /**
     * A callback which is called when a setting's value changes.
     * @param autoSaveDataStoreKeys The data store keys to which the setting's value should be automatically saved.
     * @param value The new value of the setting.
     */
    private onSettingChanged;
    /**
     * Loads the saved values of this manager's settings.
     * @param key The key from which to load the values.
     * @throws Error if this manager has been destroyed.
     */
    load(key: string): void;
    /**
     * Saves the current values of this manager's settings.
     * @param key The key to which to save the values.
     * @throws Error if this manager has been destroyed.
     */
    save(key: string): void;
    /**
     * Starts automatically saving this manager's settings when their values change.
     * @param key The key to which to save the values.
     * @throws Error if this manager has been destroyed.
     */
    startAutoSave(key: string): void;
    /**
     * Stops automatically saving this manager's settings when their values change.
     * @param key The key to which to stop saving the values.
     * @throws Error if this manager has been destroyed.
     */
    stopAutoSave(key: string): void;
    /**
     * Destroys this manager. Once this manager is destroyed, all active autosaves will be stopped, and attempting to
     * save, load, or start another autosave from this manager will cause an error to be thrown.
     */
    destroy(): void;
    /**
     * Gets a data store key for a specific setting and save key.
     * @param setting A user setting.
     * @param saveKey The save key.
     * @returns the data store key for the setting and save key.
     */
    private static getDataStoreKey;
}

/**
 * Events related to autopilot altitude selection.
 */
interface AltitudeSelectEvents {
    /** Whether the autopilot selected altitude has been initialized to a value. */
    alt_select_is_initialized: boolean;
}
/**
 * Metric Altitude Select Setting.
 */
declare type MetricAltitudeSelectSetting = {
    /** Whether the altimeter is set to Metric */
    'altMetric': boolean;
};
/**
 * A type describing a settings manager that at least has the metric altimeter setting.
 */
declare type MetricAltitudeSettingsManager = UserSettingManager<MetricAltitudeSelectSetting>;
/**
 * Configuration options for AltitudeSelectManager.
 */
declare type AltitudeSelectManagerOptions = {
    /** The altitude hold slot index to use. Defaults to 1. */
    altitudeHoldSlotIndex?: 1 | 2 | 3;
    /** Whether to support metric mode. */
    supportMetric: boolean;
    /** The minimum value of the selected altitude setting. */
    minValue: NumberUnitInterface<UnitFamily.Distance>;
    /** The maximum value of the selected altitude setting. */
    maxValue: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The minimum value of the selected altitude setting in metric mode. If undefined, it will be set equal to the
     * minimum value in non-metric mode.
     */
    minValueMetric?: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The maximum value of the selected altitude setting in metric mode. If undefined, it will be set equal to the
     * maximum value in non-metric mode.
     */
    maxValueMetric?: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The threshold for an altitude select change key input value above which the input is interpreted as a large
     * increment.
     */
    inputIncrLargeThreshold: number;
    /** The value to increase/decrease the selected altitude setting on a small increment. */
    incrSmall: NumberUnitInterface<UnitFamily.Distance>;
    /** The value to increase/decrease the selected altitude setting on a large increment.  */
    incrLarge: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The value to increase/decrease the selected altitude setting on a small increment in metric mode. If undefined,
     * it will be set equal to the small increment value in non-metric mode.
     */
    incrSmallMetric?: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * The value to increase/decrease the selected altitude setting on a large increment in metric mode. If undefined,
     * it will be set equal to the large increment value in non-metric mode.
     */
    incrLargeMetric?: NumberUnitInterface<UnitFamily.Distance>;
    /**
     * Whether to lock the selected altitude setting to multiples of the appropriate increment value on a small or large
     * increment. Defaults to `true`.
     */
    lockAltToStepOnIncr?: boolean;
    /**
     * Whether to lock the selected altitude setting to multiples of the appropriate increment value on a small or large
     * increment in metric mode. If undefined, it will be set equal to the lock flag in non-metric mode.
     */
    lockAltToStepOnIncrMetric?: boolean;
    /**
     * The required number of consecutive small-increment inputs received to trigger input acceleration. While
     * acceleration is active, small-increment inputs will be converted to large increments. A threshold less than or
     * equal to zero effectively disables input acceleration. Defaults to 0.
     */
    accelInputCountThreshold?: number;
    /** Whether to reset input acceleration if the direction of increment changes. Defaults to `false`. */
    accelResetOnDirectionChange?: boolean;
    /**
     * Whether to initialize the selected altitude setting only on the first detected input. If `false`, the selected
     * altitude will be initialized as soon as the manager is fully initialized. Defaults to `false`.
     */
    initOnInput?: boolean;
    /**
     * Whether to initialize the selected altitude setting to the indicated altitude. If `false`, the selected altitude
     * will be initialized to `0`. Defaults to `false`.
     */
    initToIndicatedAlt?: boolean;
    /**
     * Whether to treat all intercepted SET key events as if they were INC or DEC events. Defaults to `true`.
     */
    transformSetToIncDec?: boolean;
};
/**
 * Controls the value of the autopilot selected altitude setting in response to key events.
 */
declare class AltitudeSelectManager {
    private readonly bus;
    private static readonly CONSECUTIVE_INPUT_PERIOD;
    private keyEventManager?;
    private readonly publisher;
    private readonly altitudeHoldSlotIndex;
    private readonly altitudeHoldSlotSimVar;
    private readonly minValue;
    private readonly maxValue;
    private readonly minValueMetric;
    private readonly maxValueMetric;
    private readonly inputIncrLargeThreshold;
    private readonly incrSmall;
    private readonly incrLarge;
    private readonly incrSmallMetric;
    private readonly incrLargeMetric;
    private readonly lockAltToStepOnIncr;
    private readonly lockAltToStepOnIncrMetric;
    private readonly accelInputCountThreshold;
    private readonly accelResetOnDirectionChange;
    private readonly initToIndicatedAlt;
    private readonly transformSetToIncDec;
    private readonly altimeterMetricSetting;
    private readonly stops;
    private isEnabled;
    private isInitialized;
    private isPaused;
    private isLocked;
    private lockDebounceTimer;
    private consecIncrSmallCount;
    private lastIncrSmallDirection;
    private lastIncrSmallInputTime;
    private readonly selectedAltitudeChangedHandler;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param settingsManager The user settings manager controlling metric altitude preselector setting.
     * @param options Configuration options for this manager.
     * @param stops Additional altitude stops, in feet, to respect when the selected altitude is incremented or
     * decremented.
     */
    constructor(bus: EventBus, settingsManager: MetricAltitudeSettingsManager, options: AltitudeSelectManagerOptions, stops?: Iterable<number> | SubscribableSet<number>);
    /**
     * Sets whether this manager is enabled. When this manager is disabled, all key events to change the selected
     * altitude setting are processed "as-is".
     * @param isEnabled Whether this manager is enabled.
     */
    setEnabled(isEnabled: boolean): void;
    /**
     * Resumes this manager. When resumed, this manager will respond to key events that manipulate selected altitude.
     */
    resume(): void;
    /**
     * Pauses this manager. When paused, this manager will not respond to key events that manipulate selected altitude.
     * If this manager is disabled, it will still pass through key events while paused.
     */
    pause(): void;
    /**
     * Resets the selected altitude to a specific value and optionally sets the initialized state of the selected
     * altitude to uninitialized.
     * @param altitude The altitude, in feet, to which to reset the selected altitude.
     * @param resetInitialized Whether to reset the initialized state of the selected altitude to uninitialized. Defaults
     * to `false`.
     */
    reset(altitude: number, resetInitialized?: boolean): void;
    /**
     * Responds to key intercepted events.
     * @param data The event data.
     * @param data.key The key that was intercepted.
     * @param data.value0 The value of the intercepted key event.
     * @param data.value1 The index of the intercepted key event.
     */
    private onKeyIntercepted;
    /**
     * Handles a key event.
     * @param key The key.
     * @param value The value of the key event.
     */
    private handleKeyEvent;
    /**
     * Sets the selected altitude to a specific value.
     * @param altitudeFeet The altitude to set, in feet.
     */
    private setSelectedAltitude;
    /**
     * Increments or decrements the selected altitude setting. The amount the setting is changed depends on whether the
     * PFD altimeter metric mode is enabled. The value of the setting after the change is guaranteed to be a round number
     * in the appropriate units (nearest 100 feet or 50 meters).
     * @param startValue The value from which to change, in feet.
     * @param direction The direction of the change: `1` for increment, `-1` for decrement.
     * @param useLargeIncrement Whether to change the altitude by the large increment (1000 feet/500 meters) instead of
     * the small increment (100 feet/50 meters). False by default.
     */
    private changeSelectedAltitude;
    /**
     * Processes a key event "as-is".
     * @param key The key that was pressed.
     * @param index The index of the key event.
     * @param value The value of the key event.
     */
    private passThroughKeyEvent;
}

/**
 * Virtual throttle lever events.
 */
interface VirtualThrottleLeverEvents {
    /** The position of an indexed virtual throttle lever. Ranges from -1 to +1. */
    [v_throttle_lever_pos: IndexedEventType<'v_throttle_lever_pos'>]: number;
}
/**
 * A manager for virtual throttle levers. Intercepts key events that control engine throttle settings and uses them
 * to move virtual throttle levers instead. The positions of the virtual throttle levers are published on the event
 * bus.
 */
declare class ThrottleLeverManager {
    private readonly bus;
    private readonly throttleLeverHandler?;
    private static readonly THROTTLE_COUNT;
    private static readonly RAW_MAX;
    private static readonly RAW_STEP;
    private readonly publisher;
    private keyEventManager?;
    private readonly throttleLevers;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param onInitCallback A callback function to be executed once this manager is initialized.
     * @param throttleLeverHandler A callback function which handles requested changes to throttle lever position. The
     * function should take three arguments: the index of the throttle lever, the current lever position (-1 to +1), and
     * the requested new lever position (-1 to +1), and return the position the lever should be set to. If not defined,
     * all requested changes to throttle lever position will be processed as-is.
     */
    constructor(bus: EventBus, onInitCallback?: () => void, throttleLeverHandler?: ((index: number, currentPos: number, newPos: number, keyEvent: string | undefined) => number) | undefined);
    /**
     * Sets the position of a throttle lever.
     * @param index The index of the throttle lever to set, from 1 to 4, inclusive.
     * @param pos The position to set, in the range -1 to +1.
     * @returns The throttle lever position at the end of the operation, in the range -1 to +1.
     * @throws Error if `index` is out of bounds.
     */
    setThrottleLeverPos(index: number, pos: number): number;
    /**
     * Changes the position of a throttle lever.
     * @param index The index of the throttle lever to change, from 1 to 4, inclusive.
     * @param delta The amount by which to change the lever position. The full lever range is expressed as -1 to +1.
     * @returns The throttle lever position at the end of the operation, in the range -1 to +1.
     * @throws Error if `index` is out of bounds.
     */
    changeThrottleLeverPos(index: number, delta: number): number;
    /**
     * Sets the raw position of a throttle lever.
     * @param index The index of the throttle lever to set, from 1 to 4, inclusive.
     * @param pos The raw position to set, in the range -16384 to +16384.
     * @returns The raw throttle lever position at the end of the operation, in the range -16384 to +16384.
     * @throws Error if `index` is out of bounds.
     */
    setThrottleLeverPosRaw(index: number, pos: number): number;
    /**
     * Changes the raw position of a throttle lever.
     * @param index The index of the throttle lever to change, from 1 to 4, inclusive.
     * @param delta The amount by which to change the raw lever position. The full lever range is expressed as -16384 to
     * +16384.
     * @returns The raw throttle lever position at the end of the operation, in the range -16384 to +16384.
     * @throws Error if `index` is out of bounds.
     */
    changeThrottleLeverPosRaw(index: number, delta: number): number;
    /**
     * Responds to key intercept events.
     * @param data The event data.
     * @param data.key The key that was intercepted.
     * @param data.value0 The value of the intercepted key event.
     */
    private onKeyIntercepted;
    /**
     * Sets a raw throttle lever position.
     * @param rawPosition The raw position to set.
     * @param index The index of the throttle lever to set. If undefined, the positions of all throttle levers will be
     * set.
     * @param keyEvent The key event responsible for this change, or `undefined` if this change was not triggered by a
     * key event.
     */
    private setRawThrottleLeverPosition;
    /**
     * Changes a raw throttle lever position.
     * @param delta The amount by which to change the raw lever position.
     * @param index The index of the throttle lever to change. If undefined, the positions of all throttle levers will be
     * changed.
     * @param keyEvent The key event responsible for this change, or `undefined` if this change was not triggered by a
     * key event.
     */
    private changeRawThrottleLeverPosition;
    /**
     * Publishes a virtual throttle lever position to the event bus.
     * @param lever The lever whose position to publish.
     */
    private publishThrottleLeverPosition;
}

/** A PID controller. */
declare class PidController {
    private kP;
    private kI;
    private kD;
    private maxOut;
    private minOut;
    private maxI;
    private minI;
    /** The previously sampled error. */
    private previousError;
    /** The previously generated output. */
    private previousOutput;
    /** The currently accumulated integral. */
    private integral;
    /**
     * Creates a new PidController.
     * @param kP The proportional gain of the controller.
     * @param kI The integral gain of the controller.
     * @param kD The differential gain of the controller.
     * @param maxOut The maximum output of the controller.
     * @param minOut The minumum output of the controller.
     * @param maxI The maximum integral gain.
     * @param minI The minimum integral gain.
     */
    constructor(kP: number, kI: number, kD: number, maxOut: number, minOut: number, maxI?: number, minI?: number);
    /**
     * Gets the output of the PID controller at a given time.
     * @param deltaTime The difference in time between the previous sample and this sample.
     * @param error The amount of error seen between the desired output and the current output.
     * @returns The PID output.
     */
    getOutput(deltaTime: number, error: number): number;
    /** Resets the controller. */
    reset(): void;
    /**
     * Clamps a number to maximum and minimum values.
     * @param value The value to clamp.
     * @param max The maximum value.
     * @param min The minumum value.
     * @returns The clamped value.
     */
    static clamp(value: number, max: number, min: number): number;
}

/**
 * An index for a throttle controlled by an autothrottle system.
 */
declare type AutothrottleThrottleIndex = 1 | 2 | 3 | 4;
/**
 * Autothrottle target modes.
 */
declare enum AutothrottleTargetMode {
    /** No target. */
    None = "None",
    /** Autothrottle targets a specific airspeed. */
    Speed = "Speed",
    /** Autothrottle targets a specific engine power setting. */
    Power = "Power",
    /** Autothrottle targets a specific throttle lever position. */
    ThrottlePos = "ThrottlePos"
}
/**
 * Autothrottle-related events.
 */
interface AutothrottleEvents {
    /** Whether the autothrottle is active. */
    at_master_is_active: boolean;
    /** Whether the autothrottle's overspeed protection is active. */
    at_overspeed_prot_is_active: boolean;
    /** Whether the autothrottle's underspeed protection is active. */
    at_underspeed_prot_is_active: boolean;
    /** Whether the autothrottle's overpower protection is active. */
    at_overpower_prot_is_active: boolean;
    /** Autothrottle target mode. */
    at_target_mode: AutothrottleTargetMode;
    /** Autothrottle selected indicated airspeed, in knots. */
    at_selected_ias: number;
    /** Autothrottle selected mach number. */
    at_selected_mach: number;
    /** Whether autothrottle is targeting selected mach number instead of indicated airspeed. */
    at_selected_speed_is_mach: boolean;
    /** Autothrottle selected engine power. */
    at_selected_power: number;
    /** Autothrottle selected normalized throttle lever position. */
    at_selected_throttle_pos: number;
    /** The maximum indicated airspeed, in knots, allowed by the autothrottle. */
    at_max_ias: number;
    /** The maximum mach number allowed by the autothrottle. */
    at_max_mach: number;
    /** The minimum indicated airspeed, in knots, allowed by the autothrottle. */
    at_min_ias: number;
    /** The minimum mach number allowed by the autothrottle. */
    at_min_mach: number;
    /** The maximum engine power allowed by the autothrottle. */
    at_max_power: number;
    /** The maximum normalized throttle lever position allowed by the autothrottle. */
    at_max_throttle_pos: number;
    /** The minimum normalized throttle lever position allowed by the autothrottle. */
    at_min_throttle_pos: number;
    /** Whether the autothrottle servo for engine throttle 1 is active. */
    at_servo_1_is_active: boolean;
    /** Whether the autothrottle servo for engine throttle 2 is active. */
    at_servo_2_is_active: boolean;
    /** Whether the autothrottle servo for engine throttle 3 is active. */
    at_servo_3_is_active: boolean;
    /** Whether the autothrottle servo for engine throttle 4 is active. */
    at_servo_4_is_active: boolean;
}

/**
 * Information describing a throttle controlled by an autothrottle system.
 */
declare type AutothrottleThrottleInfo = {
    /** The index of the engine controlled by the throttle. */
    index: AutothrottleThrottleIndex;
    /** Whether the throttle is a virtual throttle. */
    isVirtual: boolean;
    /** The idle position of the throttle, where `-1` is full reverse, `0` is neutral, and `1` is full forward. */
    idlePosition: number;
    /** The maximum thrust position of the throttle, where `-1` is full reverse, `0` is neutral, and `1` is full forward. */
    maxThrustPosition: number;
};
/**
 * PID controller parameters for an autothrottle.
 */
declare type AutothrottlePidParams = {
    /** Proportional gain. */
    kP: number;
    /** Integral gain. */
    kI: number;
    /** Differential gain. */
    kD: number;
    /** Maximum output. */
    maxOut: number;
    /** Minimum output. */
    minOut: number;
    /** Maximum allowed integral term. Defaults to positive infinity. */
    maxI?: number;
    /** Minimum allowed integral term. Defaults to negative infinity. */
    minI?: number;
};
/**
 * Options used to initialize an autothrottle.
 */
declare type AutothrottleOptions = {
    /**
     * The rate at which the autothrottle's servos moves throttle levers, in units of normalized position per second.
     * One normalized throttle position is equal to the distance traversed by the throttle from the idle position to
     * the max thrust position.
     */
    servoSpeed: number;
    /**
     * The smoothing time constant, in seconds, to use to smooth airspeed data. A value of zero is equivalent to no
     * smoothing.
     */
    speedSmoothingConstant: number;
    /**
     * The lookahead time, in seconds, to use for airspeed data. If less than or equal to zero, the autothrottle will
     * use the current (smoothed) airspeed. If greater than zero, the autothrottle will use the (smoothed) airspeed trend
     * projected into the future by amount of time equal to the lookahead.
     */
    speedLookahead: number | Subscribable<number>;
    /**
     * The smoothing time constant, in seconds, to use to smooth engine power data. A value of zero is equivalent to no
     * smoothing.
     */
    powerSmoothingConstant: number;
    /**
     * The lookahead time, in seconds, to use for engine power data. If less than or equal to zero, the autothrottle will
     * use the current (smoothed) engine power. If greater than zero, the autothrottle will use the (smoothed) engine
     * power trend projected into the future by amount of time equal to the lookahead.
     */
    powerLookahead: number | Subscribable<number>;
    /**
     * Parameters for the target speed PID controller. The input of the PID is indicated airspeed error, in knots. The
     * output of the PID is an engine power adjustment.
     */
    speedTargetPid: AutothrottlePidParams;
    /**
     * Parameters for the target power PID controller. The input of the PID is engine power error. The output of the PID
     * is a throttle position adjustment speed, in units of normalized position per second.
     */
    powerTargetPid: AutothrottlePidParams;
    /**
     * The smoothing time constant, in seconds, to use to smooth power targets commanded by the speed controller. A value
     * of zero is equivalent to no smoothing.
     */
    powerTargetSmoothingConstant: number;
    /**
     * The amount of hysteresis to apply to throttle position adjustment speeds commanded by the autothrottle's power
     * controller, in units of normalized position per second. The autothrottle will ignore position adjustment speed
     * commands of magnitude less than or equal to this value if it would reverse the direction of the most recent
     * command that was carried out.
     */
    hysteresis: number;
    /**
     * Parameters for the overspeed protection PID controller. Defaults to the same parameters as the target speed PID
     * controller.
     */
    overspeedPid?: AutothrottlePidParams;
    /**
     * Parameters for the underspeed protection PID controller. Defaults to the same parameters as the target speed PID
     * controller.
     */
    underspeedPid?: AutothrottlePidParams;
    /**
     * Parameters for the overpower protection PID controller. Defaults to the same parameters as the target power PID
     * controller.
     */
    overpowerPid?: AutothrottlePidParams;
};
/**
 * A command issued by an autothrottle speed controller.
 */
declare type SpeedCommand = {
    /** The engine power commanded by the selected speed controller. */
    selectedSpeedPowerTarget: number | undefined;
    /** The engine power commanded by the overspeed protection controller. */
    overspeedProtPowerTarget: number | undefined;
    /** The engine power commanded by the underspeed protection controller. */
    underspeedProtPowerTarget: number | undefined;
    /** Whether the airplane is currently in overspeed. */
    isOverspeed: boolean;
    /** Whether the airplane is current in underspeed. */
    isUnderspeed: boolean;
};
/**
 * A command issued by an autothrottle power controller.
 */
declare type PowerCommand = {
    /** The commanded throttle position adjustment speed. */
    speed: number | undefined;
    /** The commanded throttle position. */
    targetPos: number | undefined;
    /** Whether overspeed protection is engaged. */
    isOverspeedProtEngaged: boolean;
    /** Whether underspeed protection is engaged. */
    isUnderspeedProtEngaged: boolean;
    /** Whether overpower protection is engaged. */
    isOverpowerProtEngaged: boolean;
};
/**
 * An abstract implementation of an autothrottle system.
 *
 * The system contains a global speed controller and one power controller for each engine throttle. The speed
 * controller commands a synced engine power target for all throttles based on over/underspeed protection and the
 * selected speed target, if active. Each power controller commands a position for its individual throttle based on
 * overpower protection and power target, either from the speed controller or the selected power target, if active.
 */
declare abstract class AbstractAutothrottle {
    private readonly bus;
    protected static readonly ALL_THROTTLE_INDEXES: readonly [1, 2, 3, 4];
    protected readonly publisher: Publisher<AutothrottleEvents>;
    protected readonly airspeedIndex: Subscribable<number>;
    protected airspeedSimVar: string;
    protected readonly throttles: AutothrottleThrottle[];
    protected readonly isOverspeedProtActive: Subject<boolean>;
    protected readonly isUnderspeedProtActive: Subject<boolean>;
    protected readonly isOverpowerProtActive: Subject<boolean>;
    protected readonly targetMode: Subject<AutothrottleTargetMode>;
    protected readonly selectedSpeedIsMach: Subject<boolean>;
    protected readonly selectedIas: Subject<number>;
    protected readonly selectedMach: Subject<number>;
    protected readonly selectedPower: Subject<number>;
    protected readonly selectedThrottlePos: Subject<number>;
    protected readonly maxIas: Subject<number>;
    protected readonly minIas: Subject<number>;
    protected readonly maxMach: Subject<number>;
    protected readonly minMach: Subject<number>;
    protected readonly maxPower: Subject<number>;
    protected readonly maxThrottlePos: Subject<number>;
    protected readonly minThrottlePos: Subject<number>;
    protected readonly machToKiasSmoother: ExpSmoother;
    protected readonly iasLookahead: Subscribable<number>;
    protected readonly iasSmoother: ExpSmoother;
    protected readonly lookaheadIasSmoother: ExpSmoother;
    protected lastIasLookahead: number;
    protected lastSmoothedIas: number | undefined;
    protected readonly powerLookahead: Subscribable<number>;
    protected readonly selectedSpeedPid: PidController;
    protected readonly overspeedPid: PidController;
    protected readonly underspeedPid: PidController;
    protected readonly selectedPowerPids: Record<AutothrottleThrottleIndex, PidController>;
    protected readonly overpowerPids: Record<AutothrottleThrottleIndex, PidController>;
    protected readonly selectedSpeedPowerTargetSmoother: ExpSmoother;
    protected readonly overspeedProtPowerTargetSmoother: ExpSmoother;
    protected readonly underspeedProtPowerTargetSmoother: ExpSmoother;
    protected readonly hysteresis: number;
    protected readonly hysteresisRecord: Record<AutothrottleThrottleIndex, number>;
    private readonly realTime;
    private updateTimer;
    private lastUpdateTime;
    private readonly updateHandler;
    protected readonly speedCommand: SpeedCommand;
    protected readonly powerCommand: PowerCommand;
    protected isAlive: boolean;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param airspeedIndex The index of the sim airspeed indicator from which this autothrottle should source airspeed
     * data.
     * @param throttleInfos Information on the throttles controlled by this autothrottle. Each entry in the array should
     * describe a single unique throttle. Order does not matter.
     * @param options Options with which to initialize this autothrottle.
     * @param throttleLeverManager The throttle lever manager to use to request position changes for virtual throttle
     * levers. If not defined, position changes for virtual throttle levers will be requested using key events
     * (specifically the `THROTTLE[N]_SET` event).
     */
    constructor(bus: EventBus, airspeedIndex: number | Subscribable<number>, throttleInfos: readonly Readonly<AutothrottleThrottleInfo>[], options: AutothrottleOptions, throttleLeverManager?: ThrottleLeverManager);
    /**
     * Creates a throttle controlled by this autothrottle system.
     * @param bus The event bus.
     * @param info Information describing the throttle to create.
     * @param servoSpeed The speed delivered by the servo controlling the throttle, in units of normalized position per
     * second.
     * @param powerSmoothingConstant The smoothing time constant, in seconds, to use to smooth engine power data.
     * @param powerLookahead The lookahead time, in seconds, to use for engine power data.
     * @param throttleLeverManager The throttle lever manager to use to request position changes for the throttle's
     * lever.
     * @returns A new throttle controlled by this autothrottle system.
     */
    protected abstract createThrottle(bus: EventBus, info: AutothrottleThrottleInfo, servoSpeed: number, powerSmoothingConstant: number, powerLookahead: Subscribable<number>, throttleLeverManager: ThrottleLeverManager | undefined): AutothrottleThrottle;
    /**
     * Sets whether this autothrottle's overspeed protection is active.
     * @param val Whether overspeed protection is active.
     */
    setOverspeedProtActive(val: boolean): void;
    /**
     * Sets whether this autothrottle's underspeed protection is active.
     * @param val Whether underspeed protection is active.
     */
    setUnderspeedProtActive(val: boolean): void;
    /**
     * Sets whether this autothrottle's overpower protection is active.
     * @param val Whether overpower protection is active.
     */
    setOverpowerProtActive(val: boolean): void;
    /**
     * Sets this autothrottle's target mode.
     * @param mode A target mode.
     */
    setTargetMode(mode: AutothrottleTargetMode): void;
    /**
     * Sets whether this autothrottle's selected speed target is a mach number.
     * @param val Whether the selected speed target is a mach number.
     */
    setSelectedSpeedIsMach(val: boolean): void;
    /**
     * Sets this autothrottle's selected indicated airspeed target, in knots.
     * @param ias An indicated airspeed, in knots.
     */
    setSelectedIas(ias: number): void;
    /**
     * Sets this autothrottle's selected mach number target.
     * @param mach A mach number.
     */
    setSelectedMach(mach: number): void;
    /**
     * Sets this autothrottle's selected engine power target.
     * @param power An engine power value.
     */
    setSelectedPower(power: number): void;
    /**
     * Sets this autothrottle's selected normalized throttle lever position target.
     * @param pos A normalized throttle lever position.
     */
    setSelectedThrottlePos(pos: number): void;
    /**
     * Sets this autothrottle's maximum allowed indicated airspeed, in knots.
     * @param ias An indicated airspeed, in knots.
     */
    setMaxIas(ias: number): void;
    /**
     * Sets this autothrottle's minimum allowed indicated airspeed, in knots.
     * @param ias An indicated airspeed, in knots.
     */
    setMinIas(ias: number): void;
    /**
     * Sets this autothrottle's maximum allowed mach number.
     * @param mach A mach number.
     */
    setMaxMach(mach: number): void;
    /**
     * Sets this autothrottle's minimum allowed mach number.
     * @param mach A mach number.
     */
    setMinMach(mach: number): void;
    /**
     * Sets this autothrottle's maximum allowed engine power.
     * @param power An engine power value.
     */
    setMaxPower(power: number): void;
    /**
     * Sets this autothrottle's maximum allowed normalized throttle lever position.
     * @param pos A normalized throttle lever position.
     */
    setMaxThrottlePos(pos: number): void;
    /**
     * Sets this autothrottle's minimum allowed normalized throttle lever position.
     * @param pos A normalized throttle lever position.
     */
    setMinThrottlePos(pos: number): void;
    /**
     * Sets whether one of this autothrottle's throttle servos are active.
     * @param index The index of the throttle servo to activate/deactivate.
     * @param active Whether the servo should be activated.
     */
    setServoActive(index: AutothrottleThrottleIndex, active: boolean): void;
    /**
     * Turns this autothrottle on with a specified update frequency. If this autothrottle is already running, then it
     * will be turned off before turning on again with the specified frequency.
     * @param frequency The frequency, in hertz, at which this autothrottle will update.
     * @throws Error if this autothrottle has been destroyed.
     */
    start(frequency: number): void;
    /**
     * Turns this autothrottle off.
     * @throws Error if this autothrottle has been destroyed.
     */
    stop(): void;
    /**
     * Updates this autothrottle.
     */
    protected update(): void;
    /**
     * Calculates the engine power for all throttles commanded by this autothrottle's speed controller. The speed
     * controller incorporates the speed target and over-/under-speed protection if active.
     * @param dt The elapsed time since the last update.
     * @param out The object to which to write the results.
     * @returns The engine power for all throttles commanded by this autothrottle's speed controller.
     */
    protected calculateSpeedTargetPower(dt: number, out: SpeedCommand): SpeedCommand;
    /**
     * Calculates the throttle position for a specific throttle commanded by this autothrottle's power controller. The
     * power controller incorporates the power target if active and overpower protection.
     * @param throttle The throttle for which to calculate commanded throttle position.
     * @param speedCommand The engine power commanded by this autothrottle's speed controller.
     * @param isOverpowerProtActive Whether overpower protection is active.
     * @param isPowerTargetActive Whether power target is active.
     * @param isThrottlePosTargetActive Whether throttle lever position target is active.
     * @param dt The elapsed time since the last update.
     * @param out The object to which to write the results.
     * @returns The throttle position for the specified throttle commanded by this autothrottle's power controller.
     */
    protected calculatePowerTargetThrottlePos(throttle: AutothrottleThrottle, speedCommand: SpeedCommand, isOverpowerProtActive: boolean, isPowerTargetActive: boolean, isThrottlePosTargetActive: boolean, dt: number, out: PowerCommand): PowerCommand;
    /**
     * Destroys this autothrottle.
     */
    destroy(): void;
    /**
     * Creates a PID controller using a given set of parameters.
     * @param params A set of PID parameters.
     * @returns A new PID controller created using the specified parameters.
     */
    protected static createPidFromParams(params: AutothrottlePidParams): PidController;
}
/**
 * A throttle controlled by an autothrottle system.
 */
declare abstract class AutothrottleThrottle {
    readonly servoSpeed: number;
    private readonly powerLookahead;
    private static readonly RAW_AXIS_MAX;
    /** The index of the engine controlled by the throttle. */
    readonly index: AutothrottleThrottleIndex;
    /** The idle position of this throttle. */
    readonly idlePosition: number;
    /** The maximum thrust position of this throttle. */
    readonly maxThrustPosition: number;
    private _position;
    /** The current position of this throttle. */
    get position(): number;
    private readonly normRange;
    /**
     * The position of this throttle, normalized such that `0` is the idle position and `1` is the maximum thrust
     * position.
     */
    get normPosition(): number;
    private _power;
    /** The power delivered by this throttle's engine. */
    get power(): number;
    private _effectivePower;
    /** The effective power delivered by this throttle's engine, after smoothing and lookahead have been applied. */
    get effectivePower(): number;
    private readonly _isServoActive;
    /** Whether the autothrottle servo for this throttle is active. */
    get isServoActive(): boolean;
    set isServoActive(val: boolean);
    protected keyEventManager?: KeyEventManager;
    private readonly throttlePosSimVar?;
    private readonly virtualPos?;
    private readonly getPosition;
    private readonly throttleSetKVar;
    private readonly throttleLeverManager?;
    private readonly powerSmoother;
    private readonly lookaheadPowerSmoother;
    private lastPowerLookahead;
    private lastSmoothedPower;
    /**
     * Constructor.
     * @param bus The event bus.
     * @param info Information describing this throttle.
     * @param servoSpeed The speed delivered by the servo controlling this throttle, in units of normalized position per
     * second.
     * @param powerSmoothingConstant The smoothing time constant, in seconds, to use to smooth engine power data.
     * @param powerLookahead The lookahead time, in seconds, to use for engine power data.
     * @param throttleLeverManager The throttle lever manager to use to request position changes for this throttle's
     * lever. If not defined, position changes for the lever will be requested using key events (specifically the
     * `THROTTLE[N]_SET` event).
     */
    constructor(bus: EventBus, info: AutothrottleThrottleInfo, servoSpeed: number, powerSmoothingConstant: number, powerLookahead: Subscribable<number>, throttleLeverManager?: ThrottleLeverManager);
    /**
     * Initializes the key event manager used by this throttle.
     * @param bus The event bus.
     */
    private initKeyManager;
    /**
     * Updates this throttle's current position and delivered power properties.
     * @param dt The elapsed time since the last update, in seconds.
     */
    update(dt: number): void;
    /**
     * Gets the power delivered by this throttle's engine.
     * @returns The power delivered by this throttle's engine.
     */
    protected abstract getPower(): number;
    /**
     * Drives this throttle toward a target normalized position over a period of time.
     * @param targetNormPos The target normalized position. Will be clamped to the range `[0, 1]`.
     * @param dt The amount of time over which to drive the throttle, in seconds.
     */
    drive(targetNormPos: number, dt: number): void;
    /**
     * Resets this throttle's power smoothing.
     */
    resetPowerSmoothing(): void;
    /**
     * Destroys this throttle.
     */
    destroy(): void;
}

/**
 * An autothrottle system for turbine jet engines.
 */
declare class JetAutothrottle extends AbstractAutothrottle {
    /** @inheritdoc */
    protected createThrottle(bus: EventBus, info: AutothrottleThrottleInfo, servoSpeed: number, powerSmoothingConstant: number, powerLookahead: Subscribable<number>, throttleLeverManager: ThrottleLeverManager | undefined): AutothrottleThrottle;
}

/**
 * An autothrottle system for turboprop engines.
 */
declare class TurbopropAutothrottle extends AbstractAutothrottle {
    /** @inheritdoc */
    protected createThrottle(bus: EventBus, info: AutothrottleThrottleInfo, servoSpeed: number, powerSmoothingConstant: number, powerLookahead: Subscribable<number>, throttleLeverManager: ThrottleLeverManager | undefined): AutothrottleThrottle;
}

/**
 * Transports an alert state to the CAS via the event bus.
 */
declare class CasAlertTransporter {
    private readonly bus;
    private readonly uuid;
    private readonly priority;
    private readonly suffix?;
    private static updateEntries?;
    private static previousTimestamp;
    private currentValue;
    private readonly subs;
    private readonly updateEntries;
    private isAlive;
    private isPaused;
    /**
     * Creates an instance of a CasAlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     */
    private constructor();
    /**
     * Sets whether or not the alert is active.
     * @param active Whether or not the alert is active.
     * @throws Error if this transporter has been destroyed.
     */
    set(active: boolean): void;
    /**
     * Binds an alert state to a subscribable value.
     * @param toWatch The subscribable value to watch.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bind<T>(toWatch: Subscribable<T>, predicate: (value: T) => boolean): this;
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindUpdate(predicate: (deltaTime: number) => boolean): this;
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @param state The optional state to pass into the predicate.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindStateUpdate<T>(predicate: (deltaTime: number, state: T) => boolean, state: T): this;
    /**
     * Resumes this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also resumed. On resumption, the values of bound subscribables are evaluated
     * immediately, while the values of bound update loops will be evaluated during the next update cycle.
     * @returns This transporter, after it has been resumed.
     * @throws Error if this transporter has been destroyed.
     */
    resume(): this;
    /**
     * Pauses this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also paused.
     * @returns This transporter, after it has been paused.
     * @throws Error if this transporter has been destroyed.
     */
    pause(): this;
    /**
     * Destroys this transporter. This will destroy any subscribables or update loops used to bind the state of this
     * transporter's alert. Once this transporter has been destroyed, it cannot be used to change the state of its alert,
     * bind the state of its alert, or be paused or resumed.
     */
    destroy(): void;
    /**
     * Creates an instance of an AlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     * @returns The created AlertTransporter.
     */
    static create(bus: EventBus, uuid: string, priority: AnnunciationType, suffix?: string): CasAlertTransporter;
    /**
     * Initializes the update functions.
     */
    private initUpdateFuncs;
}

/**
 * A bus-based system for publishing and managing CAS notifications.
 */

/** The defining information required to register an alert. */
declare type CasAlertDefinition = {
    /** A unique identifier for the alert. */
    uuid: string;
    /** The message text displayed on the CAS when the alert is active. */
    message: string;
    /** A list of inhibit states during with this alert should be inhibited. */
    inhibitedBy?: string[];
    /** A list of possible suffixes, in the order they're to be displayed when active. */
    suffixes?: string[];
    /** An optional debounce time, in milliseconds. */
    debounceTime?: number;
};
/** The data relevant to a single active CAS alert message. */
declare type CasActiveMessage = {
    /** The UUID of this message's alert. */
    uuid: string;
    /** The text to be displayed for this message, excluding suffixes. */
    message: string;
    /** The current priority of this message. */
    priority: AnnunciationType;
    /** Whether this message has been acknowledged. */
    acknowledged: boolean;
    /** Whether this message's alert is currently inhibited. */
    inhibited: boolean;
    /** Whether this message's alert is currently suppressed. Used for Boeing CAN/RCL */
    suppressed: boolean;
    /** The last time this message's alert was activated. */
    lastActive: number;
    /** This message's currently active suffixes. */
    suffixes?: string[];
    /** This message's currently acknowledged suffixes. */
    acknowledgedSuffixes?: string[];
};
/** A compound type identifying a specific allert and suffix combination. */
declare type CasAlertKey = {
    /** The UUID of the alert. */
    uuid: string;
    /** Optionally, a suffix for the alert. */
    suffix?: string;
};
/** Events for CAS notification management. */
interface CasEvents {
    /**
     * Register a new alert.  Anything that can send a `cas_register_alert` message _must_ subscribe for and
     * respond to `cas_publish_registration` and `cas_publish_all_registration` requests.  This can be handled
     * manually or through the use of a `CasRegistrationManager`.
     */
    'cas_register_alert': CasAlertDefinition;
    /** Activate an alert at a given priority. */
    'cas_activate_alert': {
        /** The alert key that's going active. */
        key: CasAlertKey;
        /** The priority the new alert will have. */
        priority: AnnunciationType;
    };
    /** Deactivate an alert. */
    'cas_deactivate_alert': {
        /** The alert key that's going inactive. */
        key: CasAlertKey;
        /** The priority of the alert that's going inactive. */
        priority: AnnunciationType;
    };
    /** Sets whether newly activated alerts are initialized as acknowledged. */
    'cas_set_initial_acknowledge': boolean;
    /** Broadcast an master acknowledge event. */
    'cas_master_acknowledge': AnnunciationType.Caution | AnnunciationType.Warning;
    /** Enable a CAS inhibit state. */
    'cas_activate_inhibit_state': string;
    /** Disable a CAS inhibit state. */
    'cas_deactivate_inhibit_state': string;
    /**
     * Request a republish of a single CAS registation.  Anything that can send a `cas_register_alert` message
     * _must_ be capable of responding to this.
     */
    'cas_publish_registration': string;
    /**
     * Request a republish of a all CAS registrations.  Anything that can send a `cas_register_alert` message
     * _must_ be capable of responding to this.
     */
    'cas_publish_all_registrations': boolean;
    /**
     * Requests the CAS system to suppress all annunciations with the provided type/priority.
     */
    'cas_suppress_priority': AnnunciationType;
    /**
     * Requests the CAS system to unsuppress all annunciations with the provided type/priority.
     */
    'cas_unsuppress_priority': AnnunciationType;
}
/**
 * Event data describing a CAS alert.
 */
declare type CasAlertEventData = {
    /** The unique identifier for the alert. */
    uuid: string;
    /** The suffix of the alert. */
    suffix?: string;
    /** The priority of the alert. */
    priority: AnnunciationType;
    /** Whether the alert is acknowledged. */
    acknowledged: boolean;
};
/**
 * Events related to {@link CasSystem} state.
 */
interface CasStateEvents {
    /** Whether the master warning alert is active. */
    cas_master_warning_active: boolean;
    /** Whether the master caution alert is active. */
    cas_master_caution_active: boolean;
    /** A CAS alert that was previously hidden has been displayed in a message. */
    cas_alert_displayed: Readonly<CasAlertEventData>;
    /** A displayed CAS alert that was previously unacknowledged has been acknowledged. */
    cas_alert_acknowledged: Readonly<CasAlertEventData>;
    /** A CAS alert that was previously displayed in a message has been hidden. */
    cas_alert_hidden: Readonly<CasAlertEventData>;
}
/**
 * A system for CAS management.
 *
 * Every avionics system must have exactly one instance of CasSystem configured as the primary system. This is the one
 * that is responsible for triggering sim-level master caution/warning alerts and intercepting and handling master
 * acknowledge events.
 *
 * Each JS instrument should have at most one instance of CasSystem. Multiple instances of CasSystem on a single
 * instrument will cause duplicated events to be published to the topics defined by {@link CasStateEvents}.
 */
declare class CasSystem {
    private readonly bus;
    private readonly casSubscriber;
    private readonly casPublisher;
    private readonly casStatePublisher;
    private registeredAlerts;
    private activeInhibitStates;
    private scheduledSuffixedAlerts;
    private scheduledUnsuffixedAlerts;
    private previousScheduleCheckTime;
    private isPrimary;
    private initialAcknowledge;
    private masterWarningActive;
    private masterCautionActive;
    /** A compound map containing every active CAS message at every message priority. */
    private allMessages;
    /** An array of CAS messages filtered to only show the highest priority for any given UUID and suffix. */
    private displayedCasMessages;
    private prevDisplayedCasMessages;
    /** The displayable CAS messages sorted by the standard sort order of priority, state, and age. */
    private _casActiveMessageSubject;
    readonly casActiveMessageSubject: SubscribableArray<CasActiveMessage>;
    /**
     * Create a CasSystem.
     * @param bus The event bus.
     * @param primary Whether or not this is the system responsible for managing alerts at the sim level.
     */
    constructor(bus: EventBus, primary?: boolean);
    /**
     * Suppress all messages of a given type.
     * @param priority The type of messages which shall be suppressed.
     */
    private suppressType;
    /**
     * Unsuppress all messages of a given type.
     * @param priority The type of messages which shall be suppressed.
     */
    private unsuppressAllSuppressed;
    /**
     * Create a new message from an alert key at a given priority.
     * @param alertKey The alert key.
     * @param priority The priority.
     * @returns A new CasActiveMessage or undefined if the key was invalid.
     */
    private createNewMessage;
    /**
     * Schedule an alert to go active at the end of its debounce time.
     * @param alertKey The UUID and optional suffix of the alert to handle.
     * @param priority The priority of the alert to fire.
     */
    private scheduleAlert;
    /**
     * Check the scheduled alerts to see if there's anything that needs to fire.
     * @param timestamp The current sim time.
     */
    private checkScheduledAlerts;
    /**
     * Handle an alert going active.
     * @param alertKey The UUID and optional suffix of the alert to handle.
     * @param priority The priority of the alert to fire.
     */
    private activateAlert;
    /**
     * Handle an alert going inactive.
     * @param alertKey The UUID and optional suffix of the alert to handle.
     * @param priority The priority of the alert to clear.
     */
    private deactivateAlert;
    /**
     * Handle a master warning or caution acknowledgement.
     * @param type The type of alert to acknowledge.
     */
    protected handleAcknowledgement(type: AnnunciationType): void;
    /**
     * Handle the setting of a new inhibit state.
     * @param state The name of the inhibited state to set.
     * @param active Whether the state is active or not.
     */
    private handleInhibitState;
    /**
     * Set both sets of simvars relevant to a master caution or warning status.
     * @param type The type of the status to set
     * @param active Whether or not the status is active
     */
    private setMasterStatus;
    /**
     * Get the full registered definition of an alert based on its key.
     * @param alertKey The key of the alert definition to retrieve.
     * @returns The full alert definition, or undefined if not found.
     */
    private getAlertDefinition;
    /**
     * Check whether a provided alert key is valid according to the alert's suffix definition.
     * @param alertKey The key of the alert to check.
     * @returns A boolean indicating whether the key is valid.
     */
    private checkValidAlertKey;
    /**
     * See if there is still an active, unacked annunciation of the given type.
     * @param type The annunciation type to check for.
     * @returns True if there is an active, unacked annunciation of the given type, false otherwise.
     */
    protected checkForActiveType(type: AnnunciationType): boolean;
    /**
     * Reprocess all active alerts to generate a list consisting only of those which are displayable.
     * At the same time, keep track of whether or not the master warning or caution lights should be
     * active and, if the primary CasSystem, set them appropriately when done.
     */
    private refreshDisplayedAlerts;
    /**
     * Finds alerts displayed in a query message array that are not displayed in a reference message array and publishes
     * them.
     * @param referenceMessages The reference message array.
     * @param queryMessages The query message array.
     * @param topic The event bus topic to publish to.
     */
    private diffAlerts;
    /**
     * Copies a CAS message.
     * @param source The source message to copy from.
     * @param target The target message to copy to. If not defined, a new message object will be created.
     * @returns The message copy.
     */
    private static copyMessage;
    /**
     * Performs a deep copy of a CAS message array.
     * @param source The source array to copy from.
     * @param target The target array to copy to. If not defined, a new array will be created.
     * @returns The array copy.
     */
    private static copyMessageArray;
}

/**
 * This is a convenience tool for publishing and republishing CAS alert registrations.  Code
 * that wants to implement its own alert publishing system can use the CasRegistrationManager
 * to avoid having to subscribe to and handle requests on the bus for republication of alert
 * registrations.
 */
declare class CasRegistrationManager {
    private publisher;
    private registrations;
    /**
     * Create a CasRegistrationManager
     * @param bus The event bus
     */
    constructor(bus: EventBus);
    /**
     * Register an alert for management.
     * @param definition The CasAlertDefinition for this alert.
     */
    register(definition: CasAlertDefinition): void;
    /**
     * Handle publishing information for a single alert.
     * @param uuid The UUID of the registation to publish.
     */
    private publishRegistration;
    /**
     * Publish all current registrations.
     */
    private publishAllRegistrations;
}

/**
 * An adapter to convert legacy panel.xml annunciations into the new CasSystem.
 */
declare class CasSystemLegacyAdapter {
    private logicHost;
    private pub;
    private regManager;
    /** The panel.xml-defined annunciations. */
    private legacyAnnunciations;
    /** A map of logic elements for non-suffixed events. */
    private nonSuffixLogic;
    /** A map of logic elements for suffixed events, mapped by suffix. */
    private suffixLogic;
    /** Alert definitions and priorities based on the legacy configuration for feeding into the new system. */
    private annunciations;
    /**
     * Create a CasSystemLegacyAdapter
     * @param bus The event bus.
     * @param logicHost A CompositeLogicXMLHost for running the events.
     * @param annunciationDefs An array of system annunciations to monitor.
     */
    constructor(bus: EventBus, logicHost: CompositeLogicXMLHost, annunciationDefs: Annunciation[]);
    /** Register all the alerts and begin monitoring. */
    start(): void;
}

/**
 * FADEC-related events.
 */
declare type FadecEvents = {
    /** Whether FADEC is active. */
    fadec_active: boolean;
    /** The name of the currently active FADEC mode. */
    [fadec_mode: IndexedEventType<'fadec_mode'>]: string;
};

/**
 * A control mode used by a jet FADEC.
 */
interface JetFadecMode {
    /** The name of this mode. */
    readonly name: string;
    /**
     * Checks whether the FADEC should enter this mode for a specified engine.
     * @param index The index of the engine.
     * @param throttleLeverPos The virtual position of the throttle lever, in the range of -1 to +1.
     * @param throttle The current engine throttle setting, in the range of -1 to +1.
     * @param thrust The current net thrust delivered by the engine, in pounds.
     * @param n1 The current N1 value of the engine, in percent.
     * @param n1Corrected The current corrected N1 value of the engine, in percent.
     * @returns Whether the FADEC should enter this mode for the specified engine.
     */
    accept(index: number, throttleLeverPos: number, throttle: number, thrust: number, n1: number, n1Corrected: number): boolean;
    /**
     * Computes the desired engine throttle setting.
     * @param index The index of the engine.
     * @param throttleLeverPos The virtual position of the throttle lever, in the range of -1 to +1.
     * @param throttle The current engine throttle setting, in the range of -1 to +1.
     * @param thrust The current net thrust delivered by the engine, in pounds.
     * @param n1 The current N1 value of the engine, in percent.
     * @param n1Corrected The current corrected N1 value of the engine, in percent.
     * @param dt The elapsed time since the last FADEC update, in milliseconds.
     * @returns The desired engine throttle setting, in the range of -1 to +1.
     */
    computeDesiredThrottle(index: number, throttleLeverPos: number, throttle: number, thrust: number, n1: number, n1Corrected: number, dt: number): number;
    /**
     * Gets the visible position of the throttle lever for a specified engine.
     * @param index The index of the engine.
     * @param throttleLeverPos The virtual position of the throttle lever, in the range of -1 to +1.
     * @returns The visible position of the throttle lever, in the range of -1 to +1.
     */
    getVisibleThrottlePos(index: number, throttleLeverPos: number): number;
}
/**
 * Information for a throttle controlled by a jet FADEC.
 */
declare type JetFadecThrottleInfo = {
    /** The index of the engine controlled by the throttle. */
    index: number;
    /** The event bus topic that emits the throttle's virtual lever position. */
    leverPosTopic: string;
    /** The name of the SimVar controlling the throttle's visible lever position. */
    visiblePosSimVar: string;
};
/**
 * The state of an engine controlled by a jet FADEC.
 */
declare type JetFadecEngineState = {
    /** The current engine throttle lever position, in the range of -1 to +1. */
    throttleLeverPos: number;
    /** The current engine throttle setting, in the range of -1 to +1. */
    throttle: number;
    /** The current net thrust delivered by the engine, in pounds. */
    thrust: number;
    /** The current N1 value of the engine, in percent. */
    n1: number;
    /** The current corrected N1 value of the engine, in percent. */
    n1Corrected: number;
};
/**
 * Information for a throttle controlled by a jet FADEC, for internal use.
 */
declare type JetFadecThrottleInfoInternal = JetFadecThrottleInfo & {
    /** The name of the throttle's associated engine throttle SimVar. */
    throttleSimVar: string;
    /** The name of the throttle's associated engine thrust SimVar. */
    thrustSimVar: string;
    /** The name of the throttle's associated uncorrected N1 SimVar. */
    n1SimVar: string;
    /** The name of the throttle's associated corrected N1 SimVar. */
    correctedN1SimVar: string;
    /** The event bus topic for the throttle's associated FADEC mode. */
    fadecModeTopic: IndexedEventType<'fadec_mode'>;
};
/**
 * A FADEC for turbojets. Controls engine throttle based on throttle lever position and other inputs.
 */
declare class JetFadec {
    protected readonly bus: EventBus;
    protected readonly modes: readonly JetFadecMode[];
    protected readonly publisher: Publisher<FadecEvents>;
    protected readonly throttleInfos: readonly JetFadecThrottleInfoInternal[];
    protected readonly throttleLeverPositionValues: readonly ConsumerValue<number>[];
    private readonly updateHandler;
    private readonly realTimeSub;
    private updateTimer;
    private lastUpdateTime;
    protected readonly engineStates: Record<number, JetFadecEngineState>;
    protected readonly lastModes: (JetFadecMode | null)[];
    /**
     * Constructor.
     * @param bus The event bus.
     * @param modes The modes supported by this FADEC, ordered from highest to lowest priority.
     * @param throttleInfos An array containing information pertaining to the throttles controlled by this FADEC. The
     * order of modes in the array determines their priority during mode selection. On every update cycle, the FADEC
     * iterates through the modes array in order, calling `accept()` on each mode until a value of `true` is returned.
     * Therefore, modes positioned earlier in the array have a higher priority for selection.
     */
    constructor(bus: EventBus, modes: readonly JetFadecMode[], throttleInfos: readonly JetFadecThrottleInfo[]);
    /**
     * Turns this FADEC on. If this FADEC is already running, then it will be turned off before turning on again with
     * the specified frequency.
     * @param frequency The frequency, in hertz, at which this FADEC will update.
     */
    start(frequency: number): void;
    /**
     * Turns this FADEC off.
     */
    stop(): void;
    /**
     * Updates this FADEC.
     */
    private update;
    /**
     * A method called when this FADEC is updated.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    protected onUpdate(dt: number): void;
    /**
     * Updates the states for this FADEC's engines.
     */
    protected updateEngineStates(): void;
    /**
     * Updates this FADEC's engine throttles.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    protected updateThrottles(dt: number): void;
    /**
     * Updates a throttle.
     * @param index The index of the throttle in this FADEC's throttle list.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    protected updateThrottle(index: number, dt: number): void;
    /**
     * Sets a FADEC mode for a throttle.
     * @param index The index of the throttle in this FADEC's throttle list.
     * @param mode The mode to set.
     */
    protected setMode(index: number, mode: JetFadecMode | null): void;
}

/**
 * Validates an input string into a value of a type
 */
interface Validator<T> {
    parse(input: string): Promise<T | null> | (T | null);
}
/**
 * {@link Validator} for parsing raw string values
 */
declare const RawValidator: Validator<string | null>;
/**
 * Formats a value of a type
 */
interface Formatter<T> {
    /**
     * The string to show when a value is `null`
     */
    nullValueString: string;
    /**
     * Formats a value of a type into a string
     *
     * @param value the value to format
     */
    format(value: T): string;
}
/**
 * {@link Formatter} for displaying raw string values
 */
declare const RawFormatter: Formatter<string | number | null>;

/**
 * Base options for an FMC renderer
 */
interface FmcRendererOptions {
    /**
     * Width of screen in pixels
     */
    screenPXWidth: number;
    /**
     * Height of screen in pixels
     */
    screenPXHeight: number;
    /**
     * Width of screen in number of characters
     */
    screenCellWidth: number;
    /**
     * Height of screen in number of lines
     */
    screenCellHeight: number;
}

/** Type for FMC column rendering data */
declare type FmcRenderTemplateColumn = string | FmcComponent;
/** Type for FMC row output data */
declare type FmcOutputRow = string[];
/** Type for FMC output data */
declare type FmcOutputTemplate = FmcOutputRow[];
/** Type for FMC row rendering data */
declare type FmcRenderTemplateRow = FmcRenderTemplateColumn[];
/** Type for FMC rendering data */
declare type FmcRenderTemplate = FmcRenderTemplateRow[];
/** Text direction for FMC cells */
declare type FmcDirection = 'left' | 'center' | 'right';
/** Structure for storing parsed column information */
interface FmcColumnInformation {
    /** The content of the column */
    content: string;
    /** The attached styles for the column */
    styles: string;
}
/**
 * An FMC renderer
 */
interface FmcRenderer {
    /**
     * Options for this renderer
     */
    readonly options: FmcRendererOptions;
    /**
     * Edits part of the row output
     *
     * @param output the output to insert
     * @param rowIndex the row index to insert at
     *
     * @throws if `rowIndex` is too high
     */
    editOutputTemplate(output: FmcOutputTemplate, rowIndex: number): void;
}

/**
 * A generic FMC page class. Only meant to be extended from in specific implementations
 */

/**
 * FMC Page factory, used to instantiate pages.
 *
 * FMC Pages should be instantiated with the required data and objects (FMS instances, avionics-specific utilities, event busses)
 * in instances of subclasses of this type.
 */
declare abstract class FmcPageFactory<T extends AbstractFmcPage> {
    /**
     * Creates a page of the specified subtype of {@link AbstractFmcPage}
     *
     * @param pageCtor the page constructor
     * @param bus the event bus
     * @param screen the FMC screen instance
     * @param renderCallback the render callback to give to the page
     */
    abstract createPage(pageCtor: new (...args: any[]) => T, bus: EventBus, screen: FmcScreen<T, any>, renderCallback: FmcRenderCallback): T;
}

/**
 * Options for {@link FmcScratchpad}
 */
interface FmcScratchpadOptions {
    /** Cell width of the scratchpad on the screen */
    cellWidth: number;
    /** Style to apply to the text. Defaults to `white`. */
    style?: string;
    /** Text to show for the DELETE state. Defaults to "DELETE". */
    deleteText?: string;
    /** Defines surrounding text [left, right] around the contents. Defaults to none. */
    surroundingText?: [string, string];
    /** Whether error text is centered. Defaults to false. */
    errorTextCentered?: boolean;
}
/**
 * Scratchpad for an FMC screen
 */
declare class FmcScratchpad {
    private readonly bus;
    private readonly renderCallback;
    private readonly options;
    contents: Subject<string>;
    errorContents: Subject<string>;
    renderedText: Subject<string>;
    isInDelete: Subject<boolean>;
    /**
     * Ctor
     * @param bus the event bus
     * @param options the options
     * @param renderCallback the render callback
     */
    constructor(bus: EventBus, options: Partial<FmcScratchpadOptions>, renderCallback: FmcRenderCallback);
    /**
     * Appends a string on the scratchpad
     * @param char the string to append
     */
    typeContents(char: string): void;
    /**
     * Deletes the last character on the scratchpad
     */
    backspace(): void;
    /**
     * Clears the scratchpad
     */
    clear(): void;
    /**
     * Clears the scratchpad error
     */
    clearError(): void;
    /**
     * Sets the scratchpad in DELETE mode (or not)
     *
     * @param value optional value to force, otherwise the value is set to `true`
     */
    delete(value?: boolean): void;
    /**
     * Renders the scratchpad and sets the subject
     */
    private renderText;
}

/**
 * An FMC line select key
 */
interface LineSelectKeyEvent {
    /** The LSK row */
    row: number;
    /** The LSK column */
    col: number;
    /** The scratchpad contents at the time of pressing the LSK */
    scratchpadContents: string;
    /** Whether the CLEAR/DELETE key (if applicable) was activated */
    isDelete: boolean;
}
/**
 * Paging events for an FMC screen
 */
interface FmcPagingEvents<E> {
    /** Page left / previous page */
    pageLeft?: keyof E & string;
    /** Page right / next page */
    pageRight?: keyof E & string;
    /** Page up / slew up */
    pageUp?: keyof E & string;
    /** Page down / slew down */
    pageDown?: keyof E & string;
}

/**
 * Options for an FMC screen
 */
interface FmcScreenOptions {
    /** Screen dimensions */
    screenDimensions: {
        /** Screen character cell width */
        cellWidth: number;
        /** Screen character row height */
        cellHeight: number;
    };
    /**
     * Whether to enable the scratchpad. Defaults to `true`.
     */
    enableScratchpad?: boolean;
    /**
     * A prefix for fmc events.
     * Currently used for multiple FMCs on one instrument scenarios.
     */
    eventPrefix?: string;
}
/**
 * An FMC screen.
 *
 * This is the main object used to encapsulate an FMC screen and its rendering.
 *
 * Type parameter `T` should be a subclass of the {@link AbstractFmcPage} that is universally used by pages in this implementation.
 * This is done so that different avionics can have different types for different kinds of events and any data that pages might need to be
 * instantiated with.
 */
declare class FmcScreen<P extends AbstractFmcPage = AbstractFmcPage, E = Record<string, unknown>> {
    protected readonly bus: EventBus;
    private readonly pageFactory;
    private readonly renderer;
    readonly scratchpad: FmcScratchpad;
    private readonly router;
    private readonly pageInstanceCache;
    readonly options: Required<FmcScreenOptions>;
    protected currentlyDisplayedPage: P | null;
    /**
     * Ctor
     * @param bus the event bus
     * @param pageFactory the page factory to be used for creating FMC pages for this screen
     * @param options the screen options
     * @param renderer the renderer to use for this screen
     * @param scratchpad the scratchpad to use for this screen
     */
    constructor(bus: EventBus, pageFactory: FmcPageFactory<P>, options: FmcScreenOptions, renderer: FmcRenderer, scratchpad: FmcScratchpad);
    /**
     * Gets the current route
     *
     * @returns a string subject
     */
    get currentRoute(): Subject<string>;
    /**
     * Gets the current subpage index for the current displayed page
     *
     * @returns a number
     */
    get currentSubpageIndex(): Subject<number>;
    /**
     * Gets the current number of subpages for the current displayed page
     *
     * @returns a number
     */
    get currentSubpageCount(): Subject<number>;
    /**
     * Navigates to a given route and displays the associated page, if available
     *
     * @param route the route
     * @param params the parameters to pass to the page
     */
    navigateTo(route: string, params?: Record<string, unknown>): void;
    /**
     * Clears the scratchpad, if applicable
     */
    clearScratchpad(): void;
    /**
     * Declares a route for a page class
     *
     * @param route the route to set
     * @param page the page to associate with it
     * @param routeEvent the event to associate with it
     */
    addPageRoute(route: string, page: PageConstructor<P>, routeEvent?: keyof E & string): void;
    /**
     * Adds a list of LSK events bound to certain positions on the rendering grid
     *
     * @param array the LSK events and their positions
     */
    addLskEvents(array: ([event: keyof E & string, row: number, col: number][])): void;
    /**
     * Adds paging events bound the page slewing
     *
     * @param events the events to bind
     */
    addPagingEvents(events: FmcPagingEvents<E>): void;
    /**
     * Returns a consumer for an event prefixed for this particular screen.
     * @param event The event to subscribe to.
     * @returns A consumer for an event prefixed for this particular screen.
     * */
    onPrefixedEvent(event: keyof E & string): Consumer<unknown>;
    /**
     * Instantiates a page for this screen
     *
     * @param page the page constructor
     *
     * @returns the created page
     */
    private instantiatePage;
    protected acceptPageOutput(output: FmcOutputTemplate, template: FmcRenderTemplate, atRowIndex: number): void;
    /**
     * Handles a line select key recieved by the FMC, before passing it on to pages
     *
     * @param row the row of the LSK
     * @param col the side of the lSK (0 or 1)
     */
    private handleLineSelectKey;
    /**
     * Called when an LSK event is not handled by any code. Does nothing unless overridden.
     *
     * @param selectKeyEvent the LSK event
     */
    protected onLineSelectKeyUnhandled(selectKeyEvent: LineSelectKeyEvent): void;
    /**
     * Called when an LSK error is thrown. Sets `this.scratchpad.errorContents` (if error is a string; otherwise throws) by default.
     *
     * @param error the LSK error
     */
    protected onLineSelectKeyError(error: any): void;
    /**
     * Handles a paging key recieved by the FMC
     *
     * @param event the paging key event
     */
    private handlePagingKey;
}

/**
 * For a given T, if it extends U | null, U, otherwise T
 */
declare type NeverNull<T> = T extends (infer U | null) ? U : T;
/**
 * A structure representing a source of named data that can be modified
 */
declare class DataInterface<T, U = T> {
    readonly input: Subscribable<T> | Consumer<T>;
    modify: (value: U) => void;
    /**
     * Constructs a new `ModifiableDataSource`
     *
     * @param input  an input for data
     * @param modify a callback when the data needs to be modified
     */
    constructor(input: Subscribable<T> | Consumer<T>, modify: (value: U) => void);
    /** Creates a new DataInterface with a new modifier
     * @deprecated
     * @param modify the new modifier
     * @returns the new DataInterface
     */
    modifiable<V = T>(modify: (value: V) => void): DataInterface<T, V>;
    /**
     * Creates a {@link DataInterface} from a {@link MutableSubscribable}
     * @param sub the {@link MutableSubscribable} to bind to
     * @returns the {@link DataInterface}
     */
    static fromMutSubscribable<T>(sub: MutableSubscribable<T>): DataInterface<T>;
    /**
     * Creates a {@link DataInterface} from a {@link Consumer}
     * @param consumer the {@link Consumer} to bind to (get)
     * @param modifier the modifier to use when the value is modified (set)
     * @returns the {@link DataInterface}
     */
    static fromConsumer<T>(consumer: Consumer<T>, modifier: (value: T) => void): DataInterface<T>;
}
/**
 * Class that manages a handler for a subscribable.
 *
 * The {@link pause} method is used to uncouple the handler when the binding must be disposed of
 */
declare class Binding<T> implements Subscription {
    protected input: Subscribable<T> | Consumer<T>;
    protected valueHandler: (value: T) => any;
    protected readonly sub: Subscription;
    /** Whether this binding is paused. */
    get isPaused(): boolean;
    /** @inheritDoc */
    get isAlive(): boolean;
    canInitialNotify: boolean;
    /**
     * Constructs a `Binding`
     *
     * @param input   a {@link DataSource} for the binding
     * @param valueHandler a handler for when the value changes from the `DataSource`
     * */
    constructor(input: Subscribable<T> | Consumer<T>, valueHandler: (value: T) => any);
    /**
     * Stops the binding and cancels the handler.
     * @returns This binding, after it has been paused.
     */
    pause(): this;
    /**
     * Restarts the binding and re-instates the handler.
     * @returns This binding, after it has been resumed.
     */
    resume(): this;
    /**
     * Destroys this binding.
     */
    destroy(): void;
}
/**
 * A binding between a data source, a new value handler and a source of changes to make to that value
 */
declare class TwoWayBinding<T, U = T> extends Binding<T> {
    protected valueHandler: (value: T) => void;
    protected valueEditor: Consumer<U> | Subscribable<U> | SubEvent<any, U>;
    protected readonly editSub: Subscription;
    /**
     * Constructs a new `TwoWayBinding`
     *
     * @param dataSource   a {@link DataInterface} for the binding
     * @param valueHandler a handler for when the value changes from the `DataSource`
     * @param valueEditor  a consumer for receiving new values to set using the source
     */
    constructor(dataSource: DataInterface<T, U>, valueHandler: (value: T) => void, valueEditor: Consumer<U> | Subscribable<U> | SubEvent<any, U>);
    /** @inheritDoc */
    pause(): this;
    /** @inheritDoc */
    resume(): this;
    /** @inheritDoc */
    destroy(): void;
}

/**
 * A render callback given to an FMC page
 */
declare type FmcRenderCallback = (output: FmcOutputTemplate, render: FmcRenderTemplate, atRowIndex: number) => void;
/**
 * Represents possible lifetimes for FmcPages
 */
declare enum FmcPageLifecyclePolicy {
    /**
     * Page is only created and initialized once, the first time it is navigated to, the reloaded and resumed.
     */
    Singleton = 0,
    /**
     * Page is re-created and re-initialized every time it is navigated to.
     */
    Transient = 1
}
/**
 * Base abstract class for FMC pages
 */
declare abstract class AbstractFmcPage {
    readonly bus: EventBus;
    readonly screen: FmcScreen<any, any>;
    /**
     * Configures the {@link FmcPageLifecyclePolicy} for this page
     */
    static lifecyclePolicy: FmcPageLifecyclePolicy;
    /**
     * Callback to fire when the page needs to render
     * @private
     */
    abstract readonly renderCallback: FmcRenderCallback;
    protected readonly memorizedComponents: [FmcComponent | null, FmcComponent | null, FmcComponent | null][];
    private readonly bindings;
    readonly params: Map<any, any>;
    protected clockConsumer: Consumer<number>;
    private isDirty;
    /**
     * Ctor
     * @param bus the event bus
     * @param screen the FMC screen instance
     */
    constructor(bus: EventBus, screen: FmcScreen<any, any>);
    /**
     * Handles when update/refresh of the FMCPage based on clock input
     * @param d is the Clock Value from the Event Bus
     */
    protected clockHandler: (d: number) => void;
    isInitialized: boolean;
    /**
     * Initializes the page.
     *
     * Use this for setting up subscriptions and such.
     */
    init(): void;
    /**
     * Init lifecycle hook
     */
    protected onInit(): void;
    /**
     * Pauses the page and calls appropriate event handlers
     */
    pause(): void;
    /**
     * Pause lifecycle hook
     */
    protected onPause(): void;
    /**
     * Resumes the page and calls appropriate event handlers
     */
    resume(): void;
    /**
     * Resume lifecycle hook
     */
    protected onResume(): void;
    /** Is called when the page button for the current page is pressed while already on that page. */
    onPageButtonPressed(): void;
    /**
     * Destroys the page and calls appropriate event handlers
     */
    destroy(): void;
    /**
     * Destroy lifecycle hook
     */
    protected onDestroy(): void;
    /**
     * Invalidates the render and sets the component into the dirty state
     */
    invalidate(): void;
    /**
     * Initial render function
     */
    initialRender(): void;
    abstract render(): FmcRenderTemplate[];
    private currentOutput;
    /**
     * Registers a binding on the page
     *
     * @param binding a {@link Binding}
     */
    addBinding(binding: Subscription | Binding<any>): void;
    /**
     * Handles a line select key recieved by the FMC, before passing it on to components
     *
     * @param event the LSK event
     */
    handleLineSelectKey(event: LineSelectKeyEvent): Promise<boolean | string>;
    /**
     * Handles a line select key recieved by the FMC, before passing it on to components
     *
     * @param event the LSK event
     */
    protected onHandleSelectKey(event: LineSelectKeyEvent): Promise<boolean | string>;
    /**
     * Handles a scrolling event recieved by the FMC, before passing it on to components
     *
     * @param event the scrolling event
     */
    handleScrolling(event: keyof FmcPagingEvents<this> & string): Promise<boolean | string>;
    /**
     * Handles a scrolling event recieved by the FMC, before passing it on to components
     *
     * @param event the scrolling event
     */
    protected onHandleScrolling(event: keyof FmcPagingEvents<this> & string): Promise<boolean | string>;
}
/**
 * Constructor type for FMC pages
 */
interface PageConstructor<T> {
    new (...args: any[]): T;
    /** Lifecycle policy of this page class */
    lifecyclePolicy: FmcPageLifecyclePolicy;
}

/**
 * Base options for initializing an {@link FmcComponent}
 */
interface FmcComponentOptions {
    /** Disables this component, not handling any lsk events.  */
    disabled?: boolean;
    /**
     * Handler for an LSK pressed where the component is.
     * This is the second priority in terms of handling, after the FmcPage and before the component class onLsk function.
     *
     * This should be used in either of those two cases:
     *
     * - the component does not take user input but has LSK interactivity
     * - the component takes user input, but it is not validated (instead of using an InputField)
     *
     * If the return value is:
     * - `true`   -> the handler is considered to have handled the call, and no further handlers will be called
     * - `false`  -> the handler is not considered to have handled the call, and the next handlers will be called
     * - `string` -> the value is shown in the scratchpad, and the handler is considered to have handled the call
     */
    onSelected?: (scratchpadContents: string) => Promise<boolean | string>;
    /**
     * Whether to clear the s-pad when `onSelected` returns a string or `true`. Defaults to `true`.
     */
    clearScratchpadOnSelectedHandled?: boolean;
    /**
     * Handler for an LSK pressed in DELETE mode
     *
     * If the return value is:
     * - `true`   -> the handler is considered to have handled the call, and no further handlers will be called
     * - `false`  -> the handler is not considered to have handled the call, and the next handlers will be called
     * - `string` -> the value is shown in the scratchpad, and the handler is considered to have handled the call
     */
    onDelete?: () => Promise<boolean | string>;
}
/**
 * A class for defining FMC components
 *
 * ## LSK events
 *
 * This class hierarchy deals with LSK presses in the following order:
 *
 * 1. {@link handleSelectKey} - this is called by the page when it receives an LSk associated with the component
 * 2. IF the DELETE flag is set - call {@link FmcComponentOptions.onDelete} if it's present + apply return value logic - otherwise continue
 * 3. ELSE - call {@link FmcComponentOptions.onSelected} if it's present and apply return value logic - continue otherwise
 * 4. call {@link onHandleSelectKey} - overridden by a subclass
 */
declare abstract class FmcComponent<O extends FmcComponentOptions = FmcComponentOptions> {
    protected readonly page: AbstractFmcPage;
    protected readonly options: O;
    /** @inheritDoc */
    protected constructor(page: AbstractFmcPage, options: O);
    /**
     * Invalidates the component and queues a re-render if one is not already queued
     */
    protected invalidate(): void;
    /**
     * Renders the FMC component into an FmcRenderTemplateRow
     */
    abstract render(): FmcRenderTemplate | string;
    /** @inheritDoc */
    handleSelectKey(event: LineSelectKeyEvent): Promise<boolean | string>;
    protected abstract onHandleSelectKey(event: LineSelectKeyEvent): Promise<boolean | string>;
    /**
     * Returns the component's options
     * @returns The options.
     */
    getOptions(): O;
}

/**
 * Display field options
 */
interface DisplayFieldOptions<T> extends FmcComponentOptions {
    /**
     * Formatter object
     */
    formatter: Formatter<T>;
    /** @inheritDoc */
    style?: string | ((value: T | null) => string);
    /** Text shown before the value (can be used for start indentation) */
    prefix?: string;
    /** Text shown after the value (can be used for end indentation) */
    suffix?: string;
}
/**
 * An {@link FmcComponent} for displaying values according to formats
 */
declare class DisplayField<T, S extends Subscribable<T> = Subscribable<T>> extends FmcComponent<DisplayFieldOptions<T>> {
    protected options: DisplayFieldOptions<T>;
    protected value: T | null;
    /**
     * Gets the raw value of this display field
     * @returns the value
     */
    protected get rawValue(): T | null;
    /** @inheritDoc */
    constructor(page: AbstractFmcPage, options: DisplayFieldOptions<T>);
    /**
     * Creates and registers a binding on the page, linking this field with a subscribable
     * @param subscribable the subscribable to bind to
     * @returns the created binding (usually not needed)
     */
    bind(subscribable: S): DisplayField<T>;
    /**
     * Takes an input value, displays it and stores it
     * @param value the new input value
     * @param shouldInvalidate whether or not to invalidate the page
     */
    takeValue(value: T | null, shouldInvalidate?: boolean): void;
    /** @inheritDoc */
    protected onHandleSelectKey(event: LineSelectKeyEvent): Promise<boolean | string>;
    /** @inheritDoc */
    render(): string;
}

/**
 * Input field options
 */
interface EditableFieldOptions<T> extends DisplayFieldOptions<T> {
}
/**
 * An {@link FmcComponent} for displaying and accepting new values according to a validator and formatter.
 *
 * ## deleteAllowed
 * This class deals with LSK presses that have the DELETE flag active using a default implementation
 * of {@link FmcComponentOptions.onDelete}, which checks `options.deleteAllowed` - if `true` or not set,the `onValidLskInput` subject
 * is set to `null` - if `false`, the "INVALID DELETE" scratchpad message is returned and handled by {@link FmcComponent.handleSelectKey}.
 *
 * ## onModified
 * This class also introduces another LSK handler, {@link EditableFieldOptions.onModified}, which is run after a value has been
 * validated (it is not called for invalid values) and applies return value logic. This runs after the flow
 * described for {@link FmcComponent}.
 */
declare abstract class EditableField<T, V = T> extends DisplayField<T> {
    protected page: AbstractFmcPage;
    protected readonly options: EditableFieldOptions<T>;
    protected readonly valueChanged: SubEvent<this, V>;
    /** @inheritDoc */
    constructor(page: AbstractFmcPage, options: EditableFieldOptions<T>);
    /**
     * Binds the input field to a mutable subscribable.
     * @param subscribable the mutable subscribable
     * @returns the instance of this {@link EditableField}
     */
    bind(subscribable: MutableSubscribable<any, T> | MappedSubscribable<T>): EditableField<T, V>;
    /**
     * Binds the input field to a Consumer.
     * @param consumer the consumer to bind to (get)
     * @param modifier the modifier to use when the value is modified (set)
     * @returns the instance of this {@link EditableField}
     */
    bindConsumer(consumer: Consumer<T>, modifier: (value: T) => void): EditableField<T, V>;
    /**
     * Binds the input field to a data interface.
     * @param source the data interface
     * @returns the instance of this {@link EditableField}
     */
    bindSource(source: DataInterface<T, any>): EditableField<T, V>;
    /** @inheritDoc */
    protected abstract onHandleSelectKey(event: LineSelectKeyEvent): Promise<boolean | string>;
}

/** Page Link options */
interface PageLinkFieldOptions extends FmcComponentOptions {
    /** The label to display. */
    label: string;
    /** The route to navigate to. */
    route: string;
}
/**
 * A field for displaying a link to navigate to another page
 */
declare class PageLinkField extends DisplayField<string> {
    /** @inheritDoc */
    protected constructor(page: AbstractFmcPage, options: PageLinkFieldOptions);
    /**
     * Creates an {@link PageLinkField}
     * @param page    the parent {@link FmcPage}
     * @param label  the label to display
     * @param route the route to navigate to (will disable link when empty)
     * @param disabled whether the link is disabled
     * @returns the {@link PageLinkField}
     */
    static createLink(page: AbstractFmcPage, label: string, route: string, disabled?: boolean): PageLinkField;
}

/**
 * Switch label options
 */
interface SwitchLabelOptions extends EditableFieldOptions<number> {
    /** String names of possible options, in order */
    optionStrings: readonly string[];
    /** Style class applied to the active option string only */
    activeStyle?: string;
    /** The position of the caret to display. Defaults to none. */
    caret?: 'none' | 'left' | 'right';
    /** The separator to show between the options, arrows are highlighted when next to active option */
    separator?: 'slash' | 'arrows';
}
/**
 * A field for displaying a switch label.
 */
declare class SwitchLabel extends EditableField<number, number> {
    protected page: AbstractFmcPage;
    protected options: SwitchLabelOptions;
    /** @inheritDoc */
    constructor(page: AbstractFmcPage, options?: Partial<SwitchLabelOptions>);
    /** @inheritDoc */
    render(): string;
    /** @inheritDoc */
    onHandleSelectKey(): Promise<boolean>;
}

/**
 * Input field options
 */
interface TextInputFieldOptions<T, V> extends EditableFieldOptions<T> {
    /**
     * Validator object
     */
    formatter: Formatter<T> & Validator<V>;
    /**
     * Whether CLR DEL lsk events push a null value
     */
    deleteAllowed?: boolean;
    /**
     * Whether the scratchpad is cleared when a new value is accepted. `true` by default.
     */
    clearScratchpadOnValueAccepted?: boolean;
    /**
     * Optional callback fired when the value is about to be modified. This is only called when a value is successfully validated.
     *
     * This should be used when there is no appropriate way of using a modifiable data source to accept modifications from this input field.
     *
     * An example of this is a complex process like inserting a flight plan leg, or something calling a distant modification
     * process with a very indirect relationship to the input data.
     *
     * If the return value is:
     * - `true`   -> the handler **is** considered to have handled the call, and any bound data is **not** modified.
     * - `false`  -> the handler is **not** considered to have handled the call itself, and any bound data **is** modified.
     * - `string` -> the value is shown in the scratchpad, and the handler is considered to have handled the call.
     * - error    -> the error is thrown and handled by `FmcScreen::handleLineSelectKey`
     */
    onModified?: (newValue: V) => Promise<boolean | string>;
}
/**
 * An {@link FmcComponent} for displaying and accepting new values according to a validator and formatter.
 *
 * ## deleteAllowed
 *
 * This class deals with LSK presses that have the DELETE flag active using a default implementation
 * of {@link FmcComponentOptions.onDelete}, which checks `options.deleteAllowed` - if `true` or not set,the `onValidLskInput` subject
 * is set to `null` - if `false`, the "INVALID DELETE" scratchpad message is returned and handled by {@link FmcComponent.handleSelectKey}.
 *
 * ## onModified
 *
 * This class also introduces another LSK handler, {@link InputFieldOptions.onModified}, which is run after a value has been
 * validated (it is not called for invalid values) and applies return value logic. This runs after the flow
 * described for {@link FmcComponent}.
 */
declare class TextInputField<T = string, V = T> extends EditableField<T, V> {
    readonly options: TextInputFieldOptions<T, V>;
    /** @inheritDoc */
    constructor(page: AbstractFmcPage, options: TextInputFieldOptions<T, V>);
    /**
     * Creates an {@link TextInputField} that uses a {@link RawValidator} and {@link RawFormatter}
     * @param page the parent {@link FmcPage}
     * @returns the {@link TextInputField}
     */
    static createRawTextInput(page: AbstractFmcPage): TextInputField<string | null>;
    /** @inheritDoc */
    protected onHandleSelectKey(event: LineSelectKeyEvent): Promise<boolean | string>;
}

/**
 * Toggle label options
 */
interface ToggleLabelOptions extends EditableFieldOptions<boolean> {
    /** The text to display for each value of the label. If `trueText` is not defined, it defaults to `falseText`. */
    text: readonly [falseText: string, trueText?: string];
    /** Style class applied to the label text when its value is `true`. */
    activeStyle?: string;
}
/**
 * A field for displaying a toggle label.
 */
declare class ToggleLabel extends EditableField<boolean, boolean> {
    protected options: ToggleLabelOptions;
    /** @inheritDoc */
    constructor(page: AbstractFmcPage, options?: Partial<ToggleLabelOptions>);
    /** @inheritDoc */
    render(): string;
    /** @inheritDoc */
    protected onHandleSelectKey(): Promise<boolean>;
}

/**
 * Utility class to drive list
 */
declare class FmcListUtility<T> {
    protected readonly page: AbstractFmcPage;
    protected readonly data: SubscribableArray<T>;
    protected readonly renderRow: (page: AbstractFmcPage, indexInDisplay: number, prevData?: T, data?: T, nextData?: T) => FmcRenderTemplateRow[];
    protected readonly size: number;
    protected readonly firstPageSize: number | undefined;
    /**
     * FMC List Utility Class
     * @param page                  The Fmc Page
     * @param data                  The row input data (SubscribableArray<T>)
     * @param renderRow             Function to call when the list needs to be re-rendered with new data
     * @param size                  row count of the list per page
     * @param firstPageSize         row count of the first page of the list
     */
    constructor(page: AbstractFmcPage, data: SubscribableArray<T>, renderRow: (page: AbstractFmcPage, indexInDisplay: number, prevData?: T, data?: T, nextData?: T) => FmcRenderTemplateRow[], size?: number, firstPageSize?: number | undefined);
    /**
     * Returns a rendered list page for a specified page
     * @param page The page number to render
     * @returns The FmcRenderTemplate
     */
    renderList(page: number): FmcRenderTemplateRow[];
    /**
     * Handles when the Select Key is pressed.
     * @param event The Select Key Event.
     * @returns Whether the event was handled by this component.
     */
    handleSelectKey(event: LineSelectKeyEvent): Promise<boolean>;
}

/**
 * A router for an FMC screen.
 *
 * This registers routes and handles setting the appropriate page and params.
 */
declare class FmcRouter<T extends AbstractFmcPage> {
    private readonly routes;
    currentRoute: Subject<string>;
    currentSubpageIndex: Subject<number>;
    currentSubpageCount: Subject<number>;
    /**
     * Adds a route to the router
     *
     * @param route the route string
     * @param page the target page constructor
     */
    addRoute(route: string, page: PageConstructor<T>): void;
    /**
     * Gets the associated page (or undefined) for a route
     *
     * @param routeString the route string
     *
     * @returns the associated page
     */
    getPageForRoute(routeString: string): PageConstructor<T> | undefined;
    /**
     * Gets the associated subpage index (after the hash) or 1 by default
     *
     * @param routeString the route string
     *
     * @returns the associated subpage index
     */
    getSubpageForRoute(routeString: string): number;
    /**
     * Moves to the previous subpage if there is one available
     *
     * @returns whether or not the subpage was changed
     */
    prevSubpage(): boolean;
    /**
     * Moves to the next subpage if there is one available
     *
     * @returns whether or not the subpage was changed
     */
    nextSubpage(): boolean;
    /**
     * Moves to the specified subpage if there is one available
     *
     * @param index Desired subpage index (1-based)
     *
     * @returns whether or not the subpage was changed
     */
    setSubpage(index: number): boolean;
}

/**
 * Options for {@link SimpleFmcRenderer}
 */
interface SimpleFmcRendererOptions extends FmcRendererOptions {
    /**
     * Update frequency. in hertz.
     */
    updateFrequency?: number;
}
/** FMC Renderer class */
declare class SimpleFmcRenderer implements FmcRenderer {
    readonly targetElement: HTMLDivElement;
    readonly options: SimpleFmcRendererOptions;
    private clockConsumer;
    private containerTemplate;
    private rowTemplate;
    private colTemplate;
    private currentOutput;
    private columnData;
    private prevColumnData;
    private containerRef;
    private hasChanges;
    private colElArr;
    private colElNodeArr;
    private rowElArr;
    /**
     * Ctor
     * @param eventBus The event bus.
     * @param targetElement The target element of the renderer.
     * @param options The options for the renderer.
     */
    constructor(eventBus: EventBus, targetElement: HTMLDivElement, options: SimpleFmcRendererOptions);
    /** Initializes the container we will render to. */
    private initializeContainer;
    /** Handles the clock update event. */
    private onClockUpdate;
    /**
     * Edits part of the row output
     * @param output the output to insert
     * @param rowIndex the row index to insert at
     * @throws if `rowIndex` is too high
     */
    editOutputTemplate(output: FmcOutputTemplate, rowIndex: number): void;
    /** Renders the current template */
    private renderToDom;
    /**
     * Parse row templates and build the column information.
     * @param template the template to parse
     * @param rowIndex the row index
     */
    private buildRowInfo;
    /**
     * Builds the data struct for the row's columns.
     * @param templateRowColumn template
     * @param rowIndex the row index
     * @param dir direction
     */
    private buildColumnInformation;
    /**
     * Parses content into intermediate information blocks
     * @param content the content to parse
     * @returns a list of information blocks
     */
    private parseContent;
    /**
     * Builds the template for the whole container.
     * @param defaultAlternatingLayout if the rows should alternate
     * @returns the container template
     */
    private createContainerTemplate;
    /**
     * Builds the template for a single row.
     * @returns the row template
     */
    private createRowTemplate;
    /**
     * Builds the template for a single column.
     * @returns the column template
     */
    private createColumnTemplate;
    /**
     * Builds the data structure representing the content and looks.
     * @returns the data structure
     */
    private createColumnInformation;
}

/**
 * A class for caching images.
 * Do your own instrument specific implementation with an init() method
 * that will add images to cache on instrument load to prefill the cache.
 * @class ImageCache
 */
declare abstract class ImageCache {
    private static cache;
    /**
     * Loads the image from the url and adds it to the cache.
     * @static
     * @param key The image key to access it later.
     * @param url The url to load the image from.
     */
    static addToCache(key: string, url: string): void;
    /**
     * Gets a cached image element.
     * @static
     * @param key The key of the cached image.
     * @returns The cached image element.
     */
    static get(key: string): HTMLImageElement;
}

/** Scroll utils */
declare class ScrollUtils {
    /**
     * Scrolls the container to make sure an element is in view.
     * @param el The element to scroll into view in the container.
     * @param container The container to scroll.
     * @param pinDirection The end of the container which the element should be pinned to.
     */
    static ensureInView(el: HTMLElement, container: HTMLElement, pinDirection?: 'none' | 'top' | 'bottom'): void;
    /**
     * Finds the offsetTop of an element relative to one of its ancestors.
     * @param element An element.
     * @param ancestor An ancestor of `element`.
     * @returns the offsetTop of the element relative to the ancestor.
     * @throws Error if the offsetTop could not be calculated.
     */
    private static findOffsetTopRelativeToAncestor;
    /**
     * Checks if an element is visible.
     * @param cTop The top coordinate of the scroll container.
     * @param cBottom The bottom coordinate of the scroll container.
     * @param eTop The top coordinate of the element.
     * @param eBottom The bottom coordinate of the element.
     * @returns A boolean.
     */
    private static isElementInViewport;
}

/**
 * A path stream which builds SVG path strings from its input path commands.
 */
declare class SvgPathStream implements PathStream {
    private static readonly vec2Cache;
    private svgPath;
    private precision;
    private formatter;
    private readonly firstPoint;
    private readonly prevPoint;
    /**
     * Constructor.
     * @param precision The precision of this stream. All coordinates will be rounded to this stream's precision when
     * building the SVG path string. A value of `0` indicates infinite precision. Defaults to `0`.
     */
    constructor(precision?: number);
    /**
     * Gets the SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     * @returns The SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     */
    getSvgPath(): string;
    /**
     * Gets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @returns The precision of this stream.
     */
    getPrecision(): number;
    /**
     * Sets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @param precision The precision of this stream. Negative numbers will be converted to their absolute values.
     */
    setPrecision(precision: number): void;
    /** @inheritdoc */
    beginPath(): void;
    /** @inheritdoc */
    moveTo(x: number, y: number): void;
    /** @inheritdoc */
    lineTo(x: number, y: number): void;
    /** @inheritdoc */
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;
    /** @inheritdoc */
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
    /** @inheritdoc */
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterClockwise?: boolean): void;
    /** @inheritdoc */
    closePath(): void;
    /**
     * Resets the state of this stream.
     */
    private reset;
}

/** A collection of handy SVG functions. */
declare class SVGUtils {
    /**
     * Creates an arc using an SVG path.
     * From https://stackoverflow.com/questions/5736398/how-to-calculate-the-svg-path-for-an-arc-of-a-circle
     * @param x Arc center x position.
     * @param y Arc center y position.
     * @param radius Arc radius.
     * @param startAngle Arc start angle.
     * @param endAngle Arc end angle.
     * @returns The d value for and SVG path element.
     */
    static describeArc(x: number, y: number, radius: number, startAngle: number, endAngle: number): string;
}

declare enum DmsDirection {
    NORTH = "N",
    SOUTH = "S",
    WEST = "W",
    EAST = "E"
}
/** Holds the parts  */
declare type DmsValues = {
    /** The direction N/S/E/W */
    direction: DmsDirection;
    /** The degrees component */
    degrees: number;
    /** The minutes component */
    minutes: number;
    /** The seconds component */
    seconds: number;
};
/**
 * A class to format latitude/longitude to DMS.
 * @class DmsFormatter
 */
declare class DmsFormatter {
    private readonly coordsParts;
    /**
     * Builds a DMS string out of the given latitude.
     * @param value The latitude.
     * @param spaceAfterDirection Whether to insert a space after the direction letter.
     * @param minuteApostrophe Whether to insert an apostrophe (') after the string.
     * @param precision Decimal precision for the minutes part.
     * @param padMinutesTo Padding applied to integer part of minutes.
     * @returns The DMS string.
     */
    getLatDmsStr(value: number, spaceAfterDirection?: boolean, minuteApostrophe?: boolean, precision?: number, padMinutesTo?: number): string;
    /**
     * Builds a DMS string out of the given longitude.
     * @param value The longitude.
     * @param minuteApostrophe Whether to insert an apostrophe (') after the string.
     * @param precision Decimal precision for the minutes part.
     * @param padMinutesTo Padding applied to integer part of minutes.
     * @returns The DMS string.
     */
    getLonDmsStr(value: number, minuteApostrophe?: boolean, precision?: number, padMinutesTo?: number): string;
    /**
     * Parses a latitude in to the dms parts.
     * @param value The latitude in degrees.
     * @returns The DMS parts.
     */
    parseLat(value: number): DmsValues;
    /**
     * Parses a longitude in to the dms parts.
     * @param value The longitude in degrees.
     * @returns The DMS parts.
     */
    parseLon(value: number): DmsValues;
    /**
     * Parses the latitude/longitude.
     * @private
     * @param value The value to parse.
     * @returns The DMS parts.
     */
    private parse;
}

/**
 * A utility class for creating degree-minute-second formatters for angle values.
 *
 * Each DMS formatter is a function which generates output strings from input angle values. The formatting behavior
 * of a formatter is defined by its format template.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Sign fragment. In EBNF notation, these take the form `['+', ['[', x, ']']], ('-' , ['[', y, ']'])`, where
 * `x` and `y` are arbitrary strings. Each sign fragment is replaced with a string representing the sign of the input.
 * The negative sign string is defined by `y`. If `y` is not defined, the negative sign string defaults to `'-'`
 * (dash). The positive sign string is defined by `x`. If the positive sign token does not appear in the fragment
 * definition, the positive sign string defaults to `''` (the empty string), otherwise it defaults to `'+'`.
 * * Numeric fragment. In EBNF notation, these take the form
 * `{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]`
 * where `x = 'D' | 'M' | 'S' | 'd' | 'm' | 's'`. Each numeric fragment is replaced with the numeric value of the
 * duration in degrees, minutes, or seconds, depending on which character is used for `x`. With uppercase letters, the
 * entire portion of the input value is used. With lowercase letters, only the portion of the input value that does not
 * divide evenly into the next smallest unit is used (for hours, which is the largest unit, there is no difference
 * between using `'H'` and `'h'`).
 *   * The number of `x` characters to the left of the decimal point (including all characters if no decimal point is
 * present) in the definition controls the number of leading zeroes with which the output will be padded.
 *   * If the optional `'?'` character is present, the output will drop all digits to the left of the decimal point if
 * all such digits are equal to 0.
 *   * The total number of `x` characters to the right of the decimal point in the definition controls the decimal
 * precision of the output. Trailing zeroes to the right of the decimal point will be added to the output to a number
 * of decimal places equal to the number of non-parenthetical `x` characters to the right of the decimal point in the
 * definition. If there are no `x` characters to the right of the decimal point in the definition, then the output will
 * have infinite decimal precision with no extraneous trailing zeroes.
 *   * Rounding behavior is always round down.
 *
 * @example <caption>Formatting to degrees-minutes-seconds</caption>
 * const formatter = DmsFormatter2.create('{d}°{mm}\'{ss}"', UnitType.DEGREE);
 * console.log(formatter(10));  // 10°00'00"
 * console.log(formatter(10.51)); // 10°30'36"
 *
 * @example <caption>Formatting to degrees-minutes-seconds with decimal precision</caption>
 * const formatter = DmsFormatter2.create('{d}°{mm}\'{ss.s(s)}"', UnitType.DEGREE);
 * console.log(formatter(10)); // 10°00'00.0"
 * console.log(formatter(10.09169)); // 10°05'30.08"
 *
 * @example <caption>Formatting to degrees-minutes</caption>
 * const formatter = DmsFormatter2.create('{d}°{mm.mm}\'', UnitType.DEGREE);
 * console.log(formatter(10.09169));  // 10°05.50'
 *
 * @example <caption>Formatting with signs</caption>
 * const formatter = DmsFormatter2.create('{-}{d}°{mm}\'', UnitType.DEGREE);
 * console.log(formatter(10));  // 10°00'
 * console.log(formatter(-10)); // -10°00'
 *
 * const formatterWithPositiveSign = DmsFormatter2.create('{+-}{d}°{mm}\'', UnitType.DEGREE);
 * console.log(formatterWithPositiveSign(10));  // +10°00'
 *
 * const formatterWithRealMinusSign = DmsFormatter2.create('{-[–]}{d}°{mm}\'', UnitType.DEGREE);
 * console.log(formatterWithRealMinusSign(10));  // –10°00'
 */
declare class DmsFormatter2 {
    private static readonly FORMAT_REGEXP;
    private static readonly SIGN_FRAGMENT_REGEX;
    private static readonly NUM_FRAGMENT_REGEXP;
    private static readonly NUM_FRAGMENT_UNIT_INFO;
    /**
     * Creates a function which formats angles, expressed as numeric values, to strings. The formatting behavior of
     * the function is defined by a specified format template. For more information on format templates and their syntax,
     * please refer to the {@link DmsFormatter2} class documentation.
     * @param format A template defining how the function formats angles.
     * @param unit The unit type in which the input angle values are expressed.
     * @param precision The precision of the formatter, in the unit type defined by the `unit` argument. Input values
     * will be rounded to the nearest multiple of this quantity. Precision values less than or equal to zero will be
     * taken to mean infinite precision (i.e. no rounding will take place).
     * @param nanString The string to output when the input angle is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats angles, expressed as numeric values, to strings.
     */
    static create(format: string, unit: Unit<UnitFamily.Angle>, precision: number, nanString?: string): (angle: number) => string;
    /**
     * Creates a function which formats angles, expressed as {@link NumberUnitInterface} objects, to strings. The
     * formatting behavior of the function is defined by a specified format template. For more information on format
     * templates and their syntax, please refer to the {@link DmsFormatter2} class documentation.
     * @param format A template defining how the function formats angles.
     * @param precision The precision of the formatter. Input values will be rounded to the nearest multiple of this
     * quantity. Precision values less than or equal to zero will be taken to mean infinite precision (i.e. no rounding
     * will take place).
     * @param nanString The string to output when the input angle is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats angles, expressed as {@link NumberUnitInterface} objects, to strings.
     */
    static createForNumberUnit(format: string, precision: NumberUnitInterface<UnitFamily.Angle>, nanString?: string): (angle: NumberUnitInterface<UnitFamily.Angle>) => string;
    /**
     * Creates an output string builder from a format template.
     * @param format A format template.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns An output string builder which conforms to the specified format template.
     */
    private static createBuilder;
    /**
     * Parses a format template fragment and returns a function which generates a string from an input angle according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns A function which generates a string from an input angle in milliseconds according to the rules defined
     * by the template fragment.
     */
    private static parseFragment;
}

/**
 * Options for creating a number formatter.
 */
declare type NumberFormatterOptions = {
    /** The precision to which to round the number. A value of 0 denotes no rounding. */
    precision: number;
    /** Rounding behavior. Always round down = `-1`. Always round up = `+1`. Normal rounding = `0`. */
    round: -1 | 0 | 1;
    /**
     * The maximum number of digits to enforce. Digits to the _right_ of the decimal point will be omitted (with proper
     * rounding behavior) as necessary until the total number of digits in the output is less than or equal to the value
     * of this option or until there are no more digits to omit. Digits to the _left_ of the decimal point are always
     * preserved, even if it means the number of digits in the output will exceed the value of this option.
     */
    maxDigits: number;
    /**
     * Whether to force trailing zeroes to the right of the decimal point. The number of trailing zeroes is determined
     * by the `precision` option. Specifically, trailing zeroes are added to the least significant decimal place required
     * to represent the value of `precision` (and therefore, any possible output rounded to `precision`) with no
     * rounding.
     */
    forceDecimalZeroes: boolean;
    /** The number of digits to which to pad with zeroes to the left of the decimal point. */
    pad: number;
    /** Whether to show commas. */
    showCommas: boolean;
    /** Whether to use a minus sign (`−`) in place of a dash (`-`) in front of negative numbers. */
    useMinusSign: boolean;
    /** Whether to force the display of a positive sign. */
    forceSign: boolean;
    /** The string to output for an input of NaN. */
    nanString: string;
    /** Whether to cache and reuse the previously generated string when possible. */
    cache: boolean;
};
/**
 * A utility class for creating number formatters.
 *
 * Each number formatter is a function which generates output strings from input numeric values. The formatting
 * behavior of a formatter is defined by its options. Please refer to the {@link NumberFormatterOptions} type
 * documentation for more information on each individual option.
 */
declare class NumberFormatter {
    static readonly DEFAULT_OPTIONS: Readonly<NumberFormatterOptions>;
    private static readonly roundFuncs;
    private static readonly TRAILING_ZERO_REGEX;
    private static readonly LEADING_ZERO_REGEX;
    private static readonly COMMAS_REGEX;
    /**
     * Formats a number to a string.
     * @param number The number to format.
     * @param opts Options describing how to format the number.
     * @returns The formatted string representation of the specified number.
     */
    private static formatNumber;
    /**
     * Creates a function which formats numeric values to strings. The formatting behavior of the function can be
     * customized using a number of options. Please refer to the {@link NumberFormatterOptions} type documentation for
     * more information on each individual option.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `precision = 0`
     * * `round = 0`
     * * `maxDigits = Infinity`
     * * `forceDecimalZeroes = true`
     * * `pad = 1`
     * * `showCommas = false`
     * * `useMinusSign = false`
     * * `forceSign = false`
     * * `nanString = 'NaN'`
     * * `cache = false`
     * @returns A function which formats numeric values to strings.
     */
    static create(options: Partial<NumberFormatterOptions>): (number: number) => string;
}

/**
 * A utility class for creating duration formatters.
 *
 * Each duration formatter is a function which generates output strings from input duration values. The formatting
 * behavior of a formatter is defined by its format template.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Sign fragment. In EBNF notation, these take the form `['+', ['[', x, ']']], ('-' , ['[', y, ']'])`, where
 * `x` and `y` are arbitrary strings. Each sign fragment is replaced with a string representing the sign of the input.
 * The negative sign string is defined by `y`. If `y` is not defined, the negative sign string defaults to `'-'`
 * (dash). The positive sign string is defined by `x`. If the positive sign token does not appear in the fragment
 * definition, the positive sign string defaults to `''` (the empty string), otherwise it defaults to `'+'`.
 * * Numeric fragment. In EBNF notation, these take the form
 * `{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]`
 * where `x = 'H' | 'M' | 'S' | 'h' | 'm' | 's'`. Each numeric fragment is replaced with the numeric value of the
 * duration in hours, minutes, or seconds, depending on which character is used for `x`. With uppercase letters, the
 * entire portion of the input value is used. With lowercase letters, only the portion of the input value that does not
 * divide evenly into the next smallest unit is used (for hours, which is the largest unit, there is no difference
 * between using `'H'` and `'h'`).
 *   * The number of `x` characters to the left of the decimal point (including all characters if no decimal point is
 * present) in the definition controls the number of leading zeroes with which the output will be padded.
 *   * If the optional `'?'` character is present, the output will drop all digits to the left of the decimal point if
 * all such digits are equal to 0.
 *   * The total number of `x` characters to the right of the decimal point in the definition controls the decimal
 * precision of the output. Trailing zeroes to the right of the decimal point will be added to the output to a number
 * of decimal places equal to the number of non-parenthetical `x` characters to the right of the decimal point in the
 * definition. If there are no `x` characters to the right of the decimal point in the definition, then the output will
 * have infinite decimal precision with no extraneous trailing zeroes.
 *   * Rounding behavior is always round down.
 *
 * @example <caption>Formatting to hours-minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss}', UnitType.SECOND);
 * console.log(formatter(3616));  // 1:00:16
 * console.log(formatter(36016.9)); // 10:00:16
 *
 * @example <caption>Formatting to hours-minutes-seconds with decimal precision</caption>
 * const formatter = DurationFormatter.create('{h}:{mm}:{ss.s(s)}', UnitType.SECOND);
 * console.log(formatter(3600)); // 1:00:00.0
 * console.log(formatter(3600.55)); // 1:00:00.55
 *
 * @example <caption>Formatting to minutes-seconds</caption>
 * const formatter = DurationFormatter.create('{MM}:{ss}', UnitType.SECOND);
 * console.log(formatter(600));  // 10:00
 * console.log(formatter(4200)); // 70:00
 *
 * @example <caption>Formatting with signs</caption>
 * const formatter = DurationFormatter.create('{-}{h}:{mm}', UnitType.SECOND);
 * console.log(formatter(3600));  // 1:00
 * console.log(formatter(-3600)); // -1:00
 *
 * const formatterWithPositiveSign = DurationFormatter.create('{+-}{h}:{mm}', UnitType.SECOND);
 * console.log(formatterWithPositiveSign(3600));  // +1:00
 *
 * const formatterWithRealMinusSign = DurationFormatter.create('{-[–]}{h}:{mm}', UnitType.SECOND);
 * console.log(formatterWithRealMinusSign(3600));  // –1:00
 */
declare class DurationFormatter {
    private static readonly FORMAT_REGEXP;
    private static readonly SIGN_FRAGMENT_REGEX;
    private static readonly NUM_FRAGMENT_REGEXP;
    private static readonly NUM_FRAGMENT_UNIT_INFO;
    private static readonly NUM_FRAGMENT_ROUND_FUNCS;
    /**
     * Creates a function which formats durations, expressed as numeric values, to strings. The formatting behavior of
     * the function is defined by a specified format template. For more information on format templates and their syntax,
     * please refer to the {@link DurationFormatter} class documentation.
     * @param format A template defining how the function formats durations.
     * @param unit The unit type in which the input duration values are expressed.
     * @param precision The precision of the formatter, in the unit type defined by the `unit` argument. Input values
     * will be rounded to the nearest multiple of this quantity. Precision values less than or equal to zero will be
     * taken to mean infinite precision (i.e. no rounding will take place).
     * @param nanString The string to output when the input duration is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats durations, expressed as numeric values, to strings.
     */
    static create(format: string, unit: Unit<UnitFamily.Duration>, precision: number, nanString?: string): (duration: number) => string;
    /**
     * Creates a function which formats durations, expressed as {@link NumberUnitInterface} objects, to strings. The
     * formatting behavior of the function is defined by a specified format template. For more information on format
     * templates and their syntax, please refer to the {@link DurationFormatter} class documentation.
     * @param format A template defining how the function formats durations.
     * @param precision The precision of the formatter. Input values will be rounded to the nearest multiple of this
     * quantity. Precision values less than or equal to zero will be taken to mean infinite precision (i.e. no rounding
     * will take place).
     * @param nanString The string to output when the input duration is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats durations, expressed as {@link NumberUnitInterface} objects, to strings.
     */
    static createForNumberUnit(format: string, precision: NumberUnitInterface<UnitFamily.Duration>, nanString?: string): (duration: NumberUnitInterface<UnitFamily.Duration>) => string;
    /**
     * Creates an output string builder from a format template.
     * @param format A format template.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns An output string builder which conforms to the specified format template.
     */
    private static createBuilder;
    /**
     * Parses a format template fragment and returns a function which generates a string from an input duration according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns A function which generates a string from an input duration in milliseconds according to the rules defined
     * by the template fragment.
     */
    private static parseFragment;
}

/**
 * Options for creating a time formatter.
 */
declare type DateTimeFormatterOptions = {
    /** Names for months, starting with January. */
    monthNames: [string, string, string, string, string, string, string, string, string, string, string, string];
    /** Abbreviated names for months, starting with January. */
    monthNamesShort: [string, string, string, string, string, string, string, string, string, string, string, string];
    /** Names for days of the week, starting with Sunday. */
    dayNames: [string, string, string, string, string, string, string];
    /** Abbreviated names for days of the week, starting with Sunday. */
    dayNamesShort: [string, string, string, string, string, string, string];
    /** The string to output for an input of NaN. */
    nanString: string;
};
/**
 * A utility class for creating time formatters.
 *
 * Each time formatter is a function which generates output strings from input time values, expressed as UNIX
 * timestamps in milliseconds. The formatting behavior of a formatter is defined by its format template and options.
 *
 * Please refer to the {@link DateTimeFormatterOptions} type documentation for more information on individual
 * formatting options.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Numeric fragment. In EBNF notation, these take the form `{x}` where `x = 'M' | 'd' | 'w' | 'H' | 'h' | 'm' | 's'`.
 * Each numeric fragment is replaced with a numeric representation of the month (`M`), day of month (`d`), day of week
 * (`w`), hour-24 (`H`), hour-12 (`h`), minute (`m`), or second (`s`) part of the input time. The number of `x`
 * characters in the definition controls the number of leading zeroes with which the output will be padded.
 * * Year fragment. In EBNF notation, these take the form `'YY' | 'YYYY'`. Each year fragment is replaced with either
 * the two-digit (`YY`) or unlimited-digit (`YYYY`) year of the input time.
 * * Month fragment. In EBNF notation, these take the form `('mon', ['.']) | ('MON', ['.']) | 'month' | 'MONTH'`. Each
 * month fragment is replaced with the name of the month of the input time. The case of the definition determines the
 * case of the output. `mon` will use abbreviated names. The presence of the optional `'.'` character will add a period
 * to the end of the abbreviated names.
 * * Day-of-week fragment. In EBNF notation, these take the form `('dy', ['.']) | ('DY', ['.']) | 'day' | 'DAY'`. Each
 * day-of-week fragment is replaced with the name of the day-of-week of the input time. The case of the definition
 * determines the case of the output. `dy` will use abbreviated names. The presence of the optional `'.'` character
 * will add a period to the end of the abbreviated names.
 * * AM/PM fragment. In EBNF notation, these take the form `'am' | 'a.m.' | 'AM' | 'A.M.'`. Each AM/PM fragment is
 * replaced with an AM/PM string depending on the time of day of the input. The case of the definition determines the
 * case of the output. Use of periods in the definition will add periods to the output.
 */
declare class DateTimeFormatter {
    private static readonly FORMAT_REGEXP;
    private static readonly FRAGMENT_REGEXP;
    private static readonly NUM_GETTERS;
    static readonly DEFAULT_OPTIONS: Readonly<DateTimeFormatterOptions>;
    /**
     * Creates a function which formats times, expressed as UNIX timestamps in milliseconds, to strings. The formatting
     * behavior of the function is defined by a specified format template and options. For more information on format
     * templates and their syntax, please refer to the {@link DateTimeFormatter} class documentation. For more
     * information on individual formatting options, please refer to the {@link DateTimeFormatterOptions} type
     * documentation.
     * @param format A template defining how the function formats durations.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']`
     * * `monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']`
     * * `dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']`
     * * `dayNamesShort = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']`
     * * `nanString = 'NaN'`
     * @returns A function which formats times, expressed as UNIX timestamps in milliseconds, to strings.
     */
    static create(format: string, options?: Partial<DateTimeFormatterOptions>): (time: number) => string;
    /**
     * Creates an output string builder from a format template and options.
     * @param format A format template.
     * @param options Formatting options.
     * @returns An output string builder which conforms to the specified format template and options.
     */
    private static createBuilder;
    /**
     * Parses a format template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the template fragment.
     */
    private static parseFragment;
    /**
     * Parses a numeric template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A numeric template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the numeric template fragment.
     */
    private static parseNumFragment;
    /**
     * Parses a year template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A year template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the year template fragment.
     */
    private static parseYearFragment;
    /**
     * Parses a month template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A month template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the month template fragment.
     */
    private static parseMonthFragment;
    /**
     * Parses a day-of-week template fragment and returns a function which generates a string from an input time
     * according to the rules defined by the fragment.
     * @param match A day-of-week template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the day-of-week template fragment.
     */
    private static parseDayFragment;
    /**
     * Parses an am/pm template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An am/pm template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the am/pm template fragment.
     */
    private static parseAMPMFragment;
}

/**
 * A utility class for creating radio frequency formatters.
 */
declare class RadioFrequencyFormatter {
    /**
     * Creates a function which formats NAV radio frequencies in hertz. The formatted string created by the function
     * displays the frequency in megahertz to two decimal places.
     * @param nanString The string to output for an input of `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats NAV radio frequencies in hertz.
     */
    static createNav(nanString?: string): (freqHz: number) => string;
    /**
     * Creates a function which formats COM radio frequencies in hertz. The formatted string created by the function
     * displays the frequency in megahertz to either two decimal places (with the third decimal place truncated) for
     * 25 kHz spacing, or three decimal places for 8.33 kHz spacing.
     * @param spacing The COM channel spacing mode to use.
     * @param nanString The string to output for an input of `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats COM radio frequencies in hertz.
     */
    static createCom(spacing: ComSpacing, nanString?: string): (freqHz: number) => string;
    /**
     * Creates a function which formats ADF radio frequencies in hertz. The formatted string created by the function
     * displays the frequency in kilohertz to one decimal place.
     * @param nanString The string to output for an input of `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats ADF radio frequencies in hertz.
     */
    static createAdf(nanString?: string): (freqHz: number) => string;
}

/**
 * The state of an avionics system.
 */
declare enum AvionicsSystemState {
    Off = "Off",
    Initializing = "Initializing",
    On = "On",
    Failed = "Failed"
}
/**
 * An event that contains an avionics system state change.
 */
interface AvionicsSystemStateEvent {
    /** The previous system state. */
    previous: AvionicsSystemState | undefined;
    /** The state that the system was changed to. */
    current: AvionicsSystemState | undefined;
}
/**
 * An interface that describes a basic avionics system.
 */
interface AvionicsSystem {
    /** The state of the avionics system. */
    readonly state: AvionicsSystemState | undefined;
    /** A callback to call to update the state of the avionics system. */
    onUpdate(): void;
    /** The index of the system, for multiply redundant systems. */
    readonly index: number;
}

/**
 * A simple timer for handling debounce.
 */
declare class DebounceTimer {
    private timer;
    /**
     * Checks whether an action is pending on this timer.
     * @returns Whether an action is pending on this timer.
     */
    isPending(): boolean;
    /**
     * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
     * scheduled on this timer during the delay.
     * @param action The action to schedule.
     * @param delay The debounce delay, in milliseconds.
     */
    schedule(action: () => void, delay: number): void;
    /**
     * Clears this timer of any pending actions. Actions that are cleared will not be executed.
     */
    clear(): void;
}

/** A type that pulls keys that have avionics state events from a supplied generic type. */
declare type StateEventsOnly<T> = {
    [K in keyof T as T[K] extends AvionicsSystemStateEvent ? K : never]: T[K];
};
/** The subset of electrical events that have boolean values.  */
declare type ElectricalBools = {
    [K in keyof ElectricalEvents]: ElectricalEvents[K] extends boolean ? ElectricalEvents[K] : never;
};
/**
 * An electrical system key to which system power can be connected.
 */
declare type SystemPowerKey = keyof ElectricalBools;
/**
 * A basic avionics system with a fixed initialization time and logic.
 */
declare abstract class BasicAvionicsSystem<T extends Record<string, any>> implements AvionicsSystem {
    readonly index: number;
    protected readonly bus: EventBus;
    protected readonly stateEvent: keyof StateEventsOnly<T> & string;
    protected _state: AvionicsSystemState | undefined;
    /** @inheritdoc */
    get state(): AvionicsSystemState | undefined;
    /** The time it takes in milliseconds for the system to initialize. */
    protected initializationTime: number;
    /** A timeout after which initialization will be complete. */
    protected readonly initializationTimer: DebounceTimer;
    /** Whether or not the system is powered. */
    protected isPowered: boolean | undefined;
    protected electricalPowerSub?: Subscription;
    protected electricalPowerLogic?: CompositeLogicXMLElement;
    protected readonly publisher: Publisher<T>;
    /** Whether power data consumed by this system is valid. */
    protected isPowerValid: boolean;
    /**
     * Creates an instance of a BasicAvionicsSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param stateEvent The key of the state update event to send on state update.
     */
    constructor(index: number, bus: EventBus, stateEvent: keyof StateEventsOnly<T> & string);
    /**
     * Connects this system's power state to an {@link ElectricalEvents} topic or electricity logic element.
     * @param source The source to which to connect this system's power state.
     */
    protected connectToPower(source: SystemPowerKey | CompositeLogicXMLElement): void;
    /**
     * Sets the state of the avionics system and publishes the change.
     * @param state The new state to change to.
     */
    protected setState(state: AvionicsSystemState): void;
    /**
     * Responds to changes in this system's state.
     * @param previousState The previous state.
     * @param currentState The current state.
     */
    protected onStateChanged(previousState: AvionicsSystemState | undefined, currentState: AvionicsSystemState): void;
    /**
     * A callback called when the connected power state of the avionics system changes.
     * @param isPowered Whether or not the system is powered.
     */
    protected onPowerChanged(isPowered: boolean): void;
    /** @inheritdoc */
    onUpdate(): void;
    /**
     * Updates this system's power state from an electricity logic element.
     */
    protected updatePowerFromLogic(): void;
}

/**
 * An easing function used by {@link Animator}.
 */
declare type AnimatorEasingFunc = (start: number, stop: number, progress: number) => number;
/**
 * An animator.
 */
declare class Animator {
    private static readonly DEFAULT_EASE_FUNC;
    private readonly _value;
    /** This animator's current value. */
    get value(): Subscribable<number>;
    private _isAnimating;
    private isAnimationLoopActive;
    private animationEaseFunc;
    private animationStart;
    private animationStop;
    private animationStartTime;
    private animationDuration;
    /**
     * Checks whether this animator has an animation in progress.
     * @returns Whether this animator has an animation in progress.
     */
    isAnimating(): boolean;
    /**
     * Starts an animation. The animation will proceed from this animator's current value to the target value over the
     * specified duration. If another animation is currently active, it will immediately be stopped and replaced by the
     * new animation.
     * @param target The target value.
     * @param duration The duration of the animation, in milliseconds.
     * @param easeFunc The easing function to apply to the animation. Defaults to a linear easing function.
     */
    start(target: number, duration: number, easeFunc?: AnimatorEasingFunc): void;
    private readonly animationLoop;
    /**
     * Immediately sets this animator's value. This will stop any animation currently in progress.
     * @param value The rotation to set, in degrees.
     */
    set(value: number): void;
    /**
     * Stops this animator's current in-progress animation, if any, and optionally sets this animator's value to the
     * animation's target value.
     * @param setAnimationTarget Whether to set this animator's value to the animation target value after stopping the
     * animation. Defaults to `false`.
     */
    stop(setAnimationTarget?: boolean): void;
}

/**
 * A controler for automated backlighting levels based upon the angle of the sun in the sky.
 */
declare class BacklightLevelController {
    private static readonly AUTO_MAX_SOLAR_ANGLE;
    private static readonly AUTO_MIN_SOLAR_ANGLE;
    private static readonly AUTO_MAX_SOLAR_ANGLE_SIN;
    private static readonly AUTO_MIN_SOLAR_ANGLE_SIN;
    private static readonly AUTO_SOLAR_ANGLE_RANGE_SIN;
    private static readonly AUTO_UPDATE_REALTIME_FREQ;
    private static readonly AUTO_UPDATE_SIMTIME_THRESHOLD;
    private static readonly EPOCH;
    private static readonly DAY;
    private static readonly DEFAULT_MIN_INTENSITY;
    private static readonly DEFAULT_MAX_INTENSITY;
    private static tempVec3;
    private readonly simTime;
    private readonly ppos;
    private needRecalcAuto;
    private lastSimTime;
    private _autoMaxIntensity;
    private _autoMinIntensity;
    private _autoIntensityRange;
    private paused;
    private readonly pposSub;
    private readonly updateSub;
    private readonly _intensity;
    readonly intensity: Subscribable<number>;
    /**
     * Creates an automatic backlight controller.
     * @param bus The event bus.
     * @param paused Whether the controller should be initially paused. Defaults to `false`.
     * @param minIntensity The maximum intensity commanded by the controller. Defaults to 0.
     * @param maxIntensity The minimum intensity commanded by the controller. Defaults to 1.
     */
    constructor(bus: EventBus, paused?: boolean, minIntensity?: number, maxIntensity?: number);
    /**
     * Get the max auto intensity value
     * @returns The maximum intensity applied by the auto backlight.
     */
    get autoMaxIntensity(): number;
    /**
     * Set the max auto intensity value.
     * @param max_intensity The maximum intensity applied by auto backlight.
     */
    set autoMaxIntensity(max_intensity: number);
    /**
     * Get the min auto intensity value
     * @returns THe minimum intensity applied by the auto backlight.
     */
    get autoMinIntensity(): number;
    /**
     * Set the min auto intensity value.
     * @param min_intensity The minimum intensity applied by the auto backlight.
     */
    set autoMinIntensity(min_intensity: number);
    /**
     * Pause or unpause real-time processing.
     * @param paused Whether to pause or not.
     */
    setPaused(paused: boolean): void;
    /**
     * A callback which is called when the user's location changes.
     * @param ppos The new plane position.
     */
    private onPPosChanged;
    /**
     * Updates this controller's commanded backlight intensity if necessary.
     */
    private onUpdate;
    /**
     * Updates this controller's commanded backlight intensity according to the auto setting algorithm.
     * @param simTime The current sim time.
     */
    private updateAutoBacklightIntensity;
    /**
     * Calculates the subsolar point (the point on Earth's surface directly below the Sun, where solar zenith angle = 0)
     * given a specific time.
     * @param time A UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The subsolar point at the specified time.
     */
    private static calculateSubSolarPoint;
}

/**
 * A utility class for creating easing functions. All generated easing functions are based on their CSS counterparts.
 */
declare class Easing {
    /**
     * Creates a linear easing function.
     * @returns A linear easing function.
     */
    static linear(): (progress: number) => number;
    /**
     * Creates a quadratic easing function.
     * @param end The end to which to apply easing.
     * @returns A quadratic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static quad(end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates a cubic easing function.
     * @param end The end to which to apply easing.
     * @returns A cubic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static cubic(end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates a quartic easing function.
     * @param end The end to which to apply easing.
     * @returns A quartic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static quart(end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates a quintic easing function.
     * @param end The end to which to apply easing.
     * @returns A quintic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static quint(end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates a polynomial easing function.
     * @param order The order of the polynomial.
     * @param end The end to which to apply easing.
     * @returns A polynomial easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static polynomial(order: number, end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates a sinusoid easing function.
     * @param end The end to which to apply easing.
     * @returns A sinusoid easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static sin(end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates a circular easing function.
     * @param end The end to which to apply easing.
     * @returns A circular easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static circ(end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates an exponential easing function.
     * @param end The end to which to apply easing.
     * @returns An exponential easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static exp(end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates a back easing function.
     * @param end The end to which to apply easing.
     * @returns A back easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static back(end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates an elastic easing function.
     * @param end The end to which to apply easing.
     * @returns An elastic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static elastic(end: 'in' | 'out' | 'both'): (progress: number) => number;
    /**
     * Creates a cubic bezier easing function. The function follows a cubic bezier curve with the endpoints fixed at
     * `(0, 0)` and `(1, 1)`.
     *
     * The function can optionally use a precomputed lookup table. Using a lookup table may increase performance and/or
     * precision of the created function at the cost of some precomputation time and memory needed to store the lookup
     * table.
     * @param c1x The x-coordinate of the first control point. Will be clamped to the range `[0, 1]`.
     * @param c1y The y-coordinate of the first control point.
     * @param c2x The x-coordinate of the second control point. Will be clamped to the range `[0, 1]`.
     * @param c2y The y-coordinate of the second control point.
     * @param precompute Whether to precompute a lookup table. Defaults to `false`.
     * @param minXResolution The minimum resolution of the function along the x-axis. Defaults to `0.1` if `precompute`
     * is `true`, or `1e-4` if `precompute` is `false`.
     * @param epsilon The threshold of acceptable linear interpolation error used during precomputation. Ignored if
     * `precompute` is false. Defaults to `1e-4`.
     * @param maxDepth The maximum allowed recursive depth of precomputation. The number of additional lookup table
     * breakpoints generated is bounded from above by `2 ^ (maxDepth) - 1`. Ignored if `precompute` is false. Defaults
     * to `10`.
     * @returns A cubic bezier easing function.
     */
    static bezier(c1x: number, c1y: number, c2x: number, c2y: number, precompute?: boolean, minXResolution?: number, epsilon?: number, maxDepth?: number): (progress: number) => number;
    /**
     * Precomputes lookup table breakpoints for a cubic bezier easing function.
     * @param c1x The x-coordinate of the first control point.
     * @param c1y The y-coordinate of the first control point.
     * @param c2x The x-coordinate of the second control point.
     * @param c2y The y-coordinate of the second control point.
     * @param lookup A lookup table to which to add breakpoints.
     * @param minXRes The desired minimum resolution along the x-axis.
     * @param epsilon The maximum acceptable linear interpolation error. Recursion will continue if the interpolated y
     * value differs from the exact y value by more than this amount.
     * @param maxDepth The maximum allowed recursion depth.
     * @param t0 The distance value at the current left endpoint.
     * @param x0 The x value at the current left endpoint.
     * @param y0 The y value at the current left endpoint.
     * @param t1 The distance value at the current right endpoint.
     * @param x1 The x value at the current right endpoint.
     * @param y1 The y value at the current right endpoint.
     * @param depth The current recursion depth.
     */
    private static precomputeBezier;
    /**
     * Computes a coordinate value along a bezier curve with P0 fixed at `(0, 0)` and P3 fixed at `(1, 1)`.
     * @param t The distance along the curve normalized to `[0, 1]`.
     * @param c1 The coordinate of the first control point.
     * @param c2 The coordinate of the second control point.
     * @returns The coordinate value along the specified bezier curve at the specified distance.
     */
    private static easingBezierFunc;
    /**
     * Converts an easing function to one which supports arbitrary start and stop endpoints.
     * @param ease An easing function.
     * @returns A new easing function which generates the same shape as the specified function while supporting arbitrary
     * start and stop endpoints.
     */
    static withEndpointParams(ease: (progress: number) => number): (start: number, stop: number, progress: number) => number;
    /**
     * Converts an easing function to one which uses specific start and stop endpoints.
     * @param ease An easing function.
     * @param start The start endpoint.
     * @param stop The stop endpoint.
     * @returns A new easing function which generates the same shape as the specified function while using the specified
     * start and stop endpoints.
     */
    static withEndpoints(ease: (progress: number) => number, start: number, stop: number): (progress: number) => number;
}

/** A class that linearly drives a SimVar value towards a given set point. */
declare class LinearServo {
    rate: number;
    /** The current time. */
    private currentTime?;
    /**
     * Creates an instance of a LinearServo.
     * @param rate The rate, in units per second, to drive the servo.
     */
    constructor(rate: number);
    /**
     * Drives the servo towards the set point.
     * @param currentValue The current value.
     * @param setValue The value to drive towards.
     * @returns The output value.
     */
    drive(currentValue: number, setValue: number): number;
    /**
     * Resets the servo to initial state
     */
    reset(): void;
}

/** An interface the acceleration settings of a knob. */
interface InputAccelerationSettings {
    /** The default increment value. */
    increment: number;
    /** The big increment value (default is increment*10) */
    bigIncrement: number;
}
/** A class to simulate knob acceleration on value inputs */
declare class InputAcceleration {
    private acceleration;
    private isPaused;
    private readonly maxAcceleration;
    private readonly accelDampeningPeriod;
    readonly options: InputAccelerationSettings;
    /**
     * Ctor
     * @param options the knob acceleration settings
     * @param initiallyPaused whether the knob acceleration is initially paused
     */
    constructor(options?: Partial<InputAccelerationSettings>, initiallyPaused?: boolean);
    /** Updates the acceleration. */
    private update;
    /**
     * Does a step and returns the increment value.
     * @returns the increment value
     */
    doStep(): number;
    /** Pauses the update loop */
    pause(): void;
    /** Resumes the update loop */
    resume(): void;
}

/**
 * Configuration object for flight plan predictor
 */
interface FlightPlanPredictorConfiguration {
    /**
     * Whether to generate predictions for missed approach legs
     */
    predictMissedApproachLegs: boolean;
    /**
     * Minimum ground speed to be considered for predictions
     */
    minimumPredictionsGroundSpeed: number;
    /**
     * NOOP - whether the start of the turn is considered to be the end of the leg
     */
    considerTurnAsLegTermination: boolean;
}

/**
 * Base information for leg predictions
 */
interface BaseLegPredictions {
    /**
     * Kind of predictions ('activeOrUpcoming' or 'passed')
     */
    kind: string;
    /**
     * Ident of the associated leg
     */
    ident: string;
    /**
     * Distance to the termination of the leg from PPOS
     */
    distance: number;
    /**
     * Estimated Time of Arrival of the leg, in UTC seconds from midnight
     */
    estimatedTimeOfArrival: number;
    /**
     * Estimated time Enroute of the leg, in seconds duration
     */
    estimatedTimeEnroute: number;
    /**
     * Fuel on board at leg termination, in pounds
     */
    fob: number | null;
}
/**
 * Contains predicted and achieved data for a passed flight plan leg
 */
interface PassedLegPredictions extends BaseLegPredictions {
    /** @inheritDoc */
    kind: 'passed';
    /**
     * Actual Time of Arrival of the leg, in UTC seconds from midnight
     */
    actualTimeOfArrival: number;
    /**
     * Actual time Enroute of the leg, in seconds duration
     */
    actualTimeEnroute: number;
    /**
     Actual fuel on board at leg termination, in metric tonnes
     */
    actualFob: number | null;
    /**
     * The altitude when crossing the leg, in feet
     */
    actualAltitude: number | null;
}
/**
 * Contains data predicted for an active or upcoming flight plan leg
 */
interface ActiveOrUpcomingLegPredictions extends BaseLegPredictions {
    /** @inheritDoc */
    kind: 'activeOrUpcoming';
}
/**
 * Leg predictions data, either passed or active/upcoming
 */
declare type LegPredictions = PassedLegPredictions | ActiveOrUpcomingLegPredictions;

/**
 * Creates leg-by-leg predictions for a flight plan, both in the future by estimating performance and in the past by
 * recording predicted data and actual achieved performance.
 */
declare class FlightPlanPredictor {
    private readonly bus;
    private readonly flightPlanner;
    private readonly planIndexSub;
    private readonly activeLegIndexSub;
    private readonly config;
    private readonly predictions;
    private readonly facilityPredictions;
    private readonly store;
    /**
     * Ctor
     *
     * @param bus               the event bus
     * @param flightPlanner     a flight planner
     * @param planIndexSub      a subscribable regarding the index of the flight plan we want to predict for
     * @param activeLegIndexSub a subscribable regarding the index of the displayed active leg, specific to the avionics suite
     * @param config            configuration object
     */
    constructor(bus: EventBus, flightPlanner: FlightPlanner, planIndexSub: Subscribable<number>, activeLegIndexSub: Subscribable<number>, config: FlightPlanPredictorConfiguration);
    /**
     * Whether the flight plan exists and has an active lateral leg index >= 1
     *
     * @returns boolean
     */
    get planAndPredictionsValid(): boolean;
    /**
     * Obtains the flight plan to predict
     *
     * @returns a flight plan
     */
    private get plan();
    /**
     * Returns the active leg index to be used
     *
     * @returns the index
     */
    private get activeLegIndex();
    /**
     * Checks if all legs in the plan are calculated
     * @returns true if all legs are calculated, false otherwise
     */
    private isAllLegsCalculated;
    /**
     * Updates the predictor
     */
    update(): void;
    /**
     * Clears out values from predictions
     *
     * @private
     */
    private clearOutValues;
    /**
     * Clears out entries that have become discontinuities
     */
    private clearOutDirtyValues;
    /**
     * Finds the index of the destination leg, in other words, the last non-missed-approach leg.
     *
     * @returns the index, or -1 if not applicable
     */
    private findDestinationLegIndex;
    /**
     * Iterator for existing predictions
     *
     * @param startAtIndex the index to start at
     *
     * @returns a generator
     *
     * @yields predictions
     */
    iteratePredictions(startAtIndex?: number): Generator<LegPredictions>;
    /**
     * Returns predictions for the destination airport.
     *
     * If the dest leg (defined as the last leg that is not part of the missed approach) is not a runway,
     * then the direct distance between the termination of that leg and the provided airport facility is added to
     * the result. Otherwise, the prediction to that leg is used.
     *
     * @param destinationFacility the airport facility to use in case a direct distance needs to be calculated
     *
     * @returns predictions for the destination airport, or null if they cannot be computed
     */
    getDestinationPrediction(destinationFacility: AirportFacility): ActiveOrUpcomingLegPredictions | null;
    /**
     * Returns predictions for an arbitrary facility.
     *
     * The distance used for predictions is the great circle distance between PPOS and the given facility.
     *
     * @param facility the facility to use
     *
     * @returns predictions for the facility
     */
    getPposToFacilityPredictions(facility: Facility): ActiveOrUpcomingLegPredictions;
    /**
     * Returns active or upcoming predictions for a given leg index
     *
     * @param index the leg index
     *
     * @returns the predictions object, or null if they cannot be computed
     */
    predictionsForLegIndex(index: number): LegPredictions | null;
    /**
     * Returns active or upcoming predictions for a given leg definition
     *
     * @param leg the leg
     *
     * @returns the predictions object, or null if they cannot be computed
     */
    predictionsForLeg(leg: LegDefinition): LegPredictions | null;
    /**
     * Applies active or upcoming predictions for a given distance, outputting the result in the {@link out} argument
     *
     * @param distance the distance
     * @param out      the object in which to output the predictions
     */
    applyPredictionsForDistance(distance: number, out: ActiveOrUpcomingLegPredictions): void;
    /**
     * Whether the leg at an index is predicted
     *
     * @param legIndex the target leg index
     *
     * @returns boolean
     */
    isLegIndexPredicted(legIndex: number): boolean;
    /**
     * Whether the leg is predicted
     *
     * @param leg the target leg
     *
     * @returns boolean
     */
    isLegPredicted(leg: LegDefinition): boolean;
    /**
     * Returns the previous index for which a prediction exists. **Note: this will force an update to happen.**
     *
     * @param legIndex the leg index to start at
     *
     * @returns the index, or -1 if none is found
     */
    findPreviousPredictedLegIndex(legIndex: number): number;
    /**
     * Returns the previous index for which a prediction exists. **Note: this will force an update to happen.**
     *
     * @param legIndex the leg index to start at
     *
     * @returns the index, or -1 if none is found
     */
    findNextPredictedLegIndex(legIndex: number): number;
    /**
     * Applies a reducer function to the predictions of active and upcoming legs
     *
     * @param initialValue initial accumulator value
     * @param reducer      reducer function
     * @param upTo         index to reduce to
     *
     * @returns reduced value
     */
    reducePredictions(initialValue: number, reducer: (accumulator: number, predictions: ActiveOrUpcomingLegPredictions) => number, upTo?: number): number;
    /**
     * Generator of all predictable legs in the plan
     *
     * The yielded tuple contains the following:
     * - 0: leg index in flight plan
     * - 1: leg definition object
     * - 2: previous leg definition object, including a previous discontinuity
     *
     * @param onlyAfterActive whether to start at the active leg
     *
     * @returns generator that skips appropriate legs
     *
     * @yields legs including and after the active leg that are not discontinuities (and not in missed approach, if config asks so)
     */
    private predictableLegs;
    /**
     * Stamps the actual values from the last estimated values
     *
     * @param targetObject the object to stamp the actual values on
     *
     * @private
     */
    private stampPassedLegValues;
    /**
     * Creates predictions for a passed leg
     *
     * @param targetObject the object to apply the predictions to
     * @param leg          the leg
     *
     * @throws if calculated is undefined
     */
    private updatePassedLeg;
    /**
     * Computes predictions for the active leg
     *
     * @param targetObject the object to apply the predictions to
     *
     * @throws if no active leg in flight plan
     */
    private updateActiveLeg;
    /**
     * Creates predictions for an upcoming leg
     *
     * @param targetObject        the object to apply the predictions to
     * @param leg                 the leg
     * @param accumulatedDistance accumulated distance in previous predictions before this leg
     */
    private updateUpcomingLeg;
    /**
     * Predicts performance over a distance
     *
     * @param targetObject        the object to apply the predictions to
     * @param distance            the distance flown
     */
    private predictForDistance;
    /**
     * Obtains current GS with a minimum of 150
     *
     * @returns knots
     */
    private currentGs;
    /**
     * Obtains current fuel weight
     *
     * @returns pounds
     */
    private currentFuelWeight;
}

/**
 * Utilities for {@link FlightPlanPredictor}
 */
declare class FlightPlanPredictorUtils {
    /**
     * noop
     */
    private constructor();
    /**
     * Predicts time to fly a distance at a ground speed
     *
     * @param gs       the GPS ground speed in knots
     * @param distance the distance in nautical miles
     *
     * @returns the predicted time in seconds duration
     */
    static predictTime(gs: number, distance: number): number;
    /**
     * Predicts fuel usage to fly a distance at a ground speed with a fuel flow and weight
     *
     * @param gs         the GPS ground speed in knots
     * @param distance   the distance in nautical miles
     * @param fuelFlow   the total fuel flow in gallons per hour
     * @param fuelWeight the fuel weight in pounds per gallon
     *
     * @returns the predicted fuel usage in pounds
     */
    static predictFuelUsage(gs: number, distance: number, fuelFlow: number, fuelWeight: number): number;
}

/** A collection of helper functions dealing with radios and frequencies. */
declare class RadioUtils {
    /**
     * Checks whether a frequency is a NAV frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a NAV frequency.
     */
    static isNavFrequency(freq: number): boolean;
    /**
     * Checks if frequency is a localizer frequency based on the number.
     * @param freq The frequency to check, in megahertz.
     * @returns True if frequency is between 108.1 and 111.95 MHz (inclusive) and the tenths place is odd.
     */
    static isLocalizerFrequency(freq: number): boolean;
    private static readonly COM_833_ENDINGS;
    /**
     * Checks whether a frequency is a 8.33 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 8.33 kHz-spacing COM frequency.
     */
    static isCom833Frequency(freq: number): boolean;
    /**
     * Checks whether a frequency is a 25 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 25 kHz-spacing COM frequency.
     */
    static isCom25Frequency(freq: number): boolean;
    /**
     * Checks whether a frequency is an ADF frequency.
     * @param freq The frequency to check, in kilohertz.
     * @returns Whether the specified frequency is an ADF frequency.
     */
    static isAdfFrequency(freq: number): boolean;
}

/**
 * A sound packet that can be played by {@link SoundServer}.
 */
declare type AuralAlertDefinition = {
    /** The ID of the alert. */
    uuid: string;
    /** The name of the queue to which the alert belongs. Only one alert from each queue can play simultaneously. */
    queue: string;
    /**
     * The priority of the alert within its queue. If two alerts in the same queue become active at the same time, the
     * alert with the higher priority will play first. However, alerts cannot interrupt other alerts that are already
     * playing, regardless of their relative priorities.
     */
    priority: number;
    /**
     * The sequence of sound atoms to play for the alert, as either a single ID or an array of IDs. Each atom is a single
     * sound file.
     */
    sequence: string | readonly string[];
    /**
     * Whether the alert's sound sequence should loop from the beginning when it is finished playing. If `true`, then the
     * alert effectively has an infinite duration, and once it starts playing it will never stop until forced to do so by
     * a deactivate, untrigger, or kill command.
     */
    continuous: boolean;
    /**
     * Whether the alert should be requeued after it finishes playing if it is still active. If `true`, then the alert
     * will play continuously while active as long as another alert of higher priority is not queued.
     */
    repeat: boolean;
    /**
     * The amount of time, in milliseconds, after the alert starts playing at which to forcibly stop the alert. It is
     * recommended to set this value to be at least several seconds longer than the expected length of the alert's
     * entire sequence. If the alert is continuous, the timeout is reset with each loop. Defaults to 10000 milliseconds.
     */
    timeout?: number;
};
/**
 * Events published by {@link AuralAlertSystem}.
 */
interface AuralAlertEvents {
    /** Requests all alerts to be registered again. */
    aural_alert_request_all_registrations: void;
}
/**
 * Data describing how to activate an alert.
 */
declare type AuralAlertActivation = {
    /** The ID of the alert to activate. */
    uuid: string;
    /**
     * The alias to use to activate or trigger the alert instead of the alert's registered ID. The alias must be unique.
     *
     * If an alias is defined, it will be used in place of the alert's registered ID when determining activation or
     * trigger state. Alerts activated or triggered with multiple aliases will play once per alias. In effect, using an
     * alias behaves as if a copy of the aliased alert were temporarily registered with the alias as its ID for as long
     * as the alias is activated/triggered.
     */
    alias?: string;
    /**
     * The suffix to append to the alert's ID to activate or trigger the alert. Suffixing an alert ID will generate a
     * suffixed ID in the form ``` `${uuid}::${suffix}` ```. The suffixed ID must be unique.
     *
     * If a suffix is defined, the suffixed ID will be used to determine activation/triggered state. An alert can be
     * activated or triggered with multiple suffixes. However, it will still only be played once regardless of how many
     * of its suffixes are active or triggered. An alert is considered deactivated or untriggered only when all of its
     * suffixes are deactivated or untriggered.
     *
     * If both an alias and a suffix are defined, the suffix will be appended to the _alias_ instead of the alert's
     * registered ID.
     */
    suffix?: string;
    /**
     * The sequence of sound atoms to play for the alert, as either a single ID or an array of IDs. Each atom is a single
     * sound file. If not defined, then the sequence defined when the alert was registered will be played.
     */
    sequence?: string | readonly string[];
    /**
     * Whether the alert's sound sequence should loop from the beginning when it is finished playing. If `true`, then the
     * alert effectively has an infinite duration, and once it starts playing it will never stop until forced to do so by
     * a deactivate, untrigger, or kill command. If not defined, then the alert will loop if and only if it was defined
     * to do so during registration.
     */
    continuous?: boolean;
    /**
     * Whether the alert should be requeued after it finishes playing if it is still active. If `true`, then the alert
     * will play continuously while active as long as another alert of higher priority is not queued. If not defined,
     * then the alert will repeat if and only if it was defined to do so during registration.
     */
    repeat?: boolean;
    /**
     * The amount of time, in milliseconds, after the alert starts playing at which to forcibly stop the alert. It is
     * recommended to set this value to be at least several seconds longer than the expected length of the alert's
     * entire sequence. If the alert is continuous, the timeout is reset with each loop. If not defined, then the timeout
     * defined when the alert was registered will be used.
     */
    timeout?: number;
};
/**
 * Events used to send commands to {@link AuralAlertSystem}.
 */
interface AuralAlertControlEvents {
    /**
     * Registers an aural alert. Alerts must be registered before they can be activated.
     */
    aural_alert_register: Readonly<AuralAlertDefinition>;
    /**
     * Activates an aural alert. The event data should be the unique ID of the alert or an activation data object that
     * contains the unique ID and optional override parameters. If no override parameters are provided, then the alert
     * will play as it was defined during registration.
     *
     * Once activated, the alert will be queued to play once all higher-priority alerts that are playing or queued have
     * finished playing. If the alert is already active, then this command has no effect.
     */
    aural_alert_activate: string | Readonly<AuralAlertActivation>;
    /**
     * Deactivates an aural alert. The event data should be an (optionally suffixed) alert ID. An alert is considered
     * deactivated only when all of its suffixes are deactivated (the un-suffixed ID also counts as a suffix).
     *
     * Deactivating an alert will clear any queued activated instances of the alert. If the activated alert is already
     * playing, it will finish playing but will not loop if it is continuous.
     */
    aural_alert_deactivate: string;
    /**
     * Triggers an aural alert. The event data should be the unique ID of the alert or an activation data object that
     * contains the unique ID and optional override parameters. If no override parameters are provided, then the alert
     * will play as it was defined during registration.
     *
     * Once triggered, the alert will be queued to play once all higher-priority alerts that are playing or queued have
     * finished playing. A triggered alert is not considered active. Triggering an alert while an existing triggered
     * instance is queued will replace the existing instance with the new instance. Triggered alerts automatically
     * revert to an untriggered state after they are finished playing.
     */
    aural_alert_trigger: string | Readonly<AuralAlertActivation>;
    /**
     * Untriggers an aural alert. The event data should be an (optionally suffixed) alert ID. An alert is considered
     * untriggered only when all of its suffixes are deactivated (the un-suffixed ID also counts as a suffix).
     *
     * Untriggering an alert will clear any queued triggered instances of the alert. If the triggered alert is already
     * playing, it will finish playing but will not loop if it is continuous.
     */
    aural_alert_untrigger: string;
    /**
     * Kills an aural alert. The event data should be an (optionally suffixed) alert ID.
     *
     * Killing an alert will deactivate and untrigger the alert. If the alert is already playing, it will be stopped at
     * the earliest opportunity.
     */
    aural_alert_kill: string;
    /** Deactivates all aural alerts. */
    aural_alert_deactivate_all: void;
    /** Untriggers all aural alerts. */
    aural_alert_untrigger_all: void;
    /** Kills all aural alerts. */
    aural_alert_kill_all: void;
}
/**
 * A system which manages and plays aural alerts using a priority queue system.
 *
 * The system collects registered alerts, and manages how they are played. Each alert belongs to a queue. Only one
 * alert from each queue can play simultaneously. Alerts are queued to be played when they become activated or triggered.
 * If two alerts are queued at the same time, the one with higher priority is played first. Alerts cannot interrupt an
 * already playing alert, regardless of their relative priorities.
 */
declare class AuralAlertSystem {
    private readonly bus;
    private static readonly ALERT_COMPARATOR;
    private readonly soundServerSub;
    private readonly controlSub;
    private readonly soundServerPublisher;
    private readonly publisher;
    private readonly registeredAlerts;
    private readonly queueToPacketKeyMap;
    private readonly packetKeyToQueueMap;
    private readonly queues;
    private readonly playing;
    private readonly activeAliasToUuid;
    private readonly triggeredAliasToUuid;
    private readonly activeSuffixedIdToId;
    private readonly idToActiveSuffixedIds;
    private readonly triggeredSuffixedIdToId;
    private readonly idToTriggeredSuffixedIds;
    private readonly activeAlerts;
    private readonly triggeredAlerts;
    private isSoundServerInit;
    private isAwake;
    /**
     * Creates a new AuralAlertSystem. The system is asleep when created.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Wakes this system. All active continuous alerts will be re-queued to play. While this system is awake, activation
     * of alerts will queue them to be played. Activation of any alerts that were already active when the system woke up
     * will not queue them to be played unless the alert was deactivated in the interim.
     */
    wake(): void;
    /**
     * Puts this system to sleep. Clears all triggered and queued alerts and stops all currently playing alerts at the
     * earliest opportunity. While this system is asleep, activating alerts will not queue them to be played and
     * triggering alerts has no effect.
     */
    sleep(): void;
    /**
     * Responds to when an alert is registered.
     * @param alert The definition of the registered alert.
     */
    private onAlertRegistered;
    /**
     * Creates an alert queue entry.
     * @param queueName The name of the queue to create.
     * @returns The new queue entry.
     */
    private createQueue;
    /**
     * Checks if an alias is unique. An alias is considered unique if and only if it does not match any registered
     * alert IDs and it does not match any active or triggered aliases assigned to other parent IDs.
     * @param uuid The parent ID of the alias.
     * @param alias The alias to check.
     * @returns Whether the specified alias is unique.
     */
    private isAliasUnique;
    /**
     * Checks if a suffixed ID is unique. A suffixed ID is considered unique if and only if it does not match any
     * registered alert IDs or aliases and it does not match any active or triggered suffixed IDs assigned to other
     * parent IDs.
     * @param id The parent ID of the suffix.
     * @param suffixedId The suffixed ID to check.
     * @returns Whether the specified suffixed ID is unique.
     */
    private isSuffixedIdUnique;
    /**
     * Activates an alert.
     * @param activation The ID of the alert to activate, or data describing the alert to activate.
     */
    private activateAlert;
    /**
     * Activates an alert suffix.
     * @param id The ID of the suffix's parent alert.
     * @param suffixedId The suffixed ID to activate.
     */
    private activateSuffix;
    /**
     * Triggers an alert.
     * @param activation The ID of the alert to trigger, or data describing the alert to trigger.
     */
    private triggerAlert;
    /**
     * Triggers an alert suffix.
     * @param id The ID of the suffix's parent alert.
     * @param suffixedId The suffixed ID to trigger.
     */
    private triggerSuffix;
    /**
     * Creates an alert to be queued.
     * @param definition The definition of the alert.
     * @param activation Data describing the alert to activate. If not defined, the alert will be activated according
     * to its definition.
     * @returns The queued alert.
     */
    private createQueuedAlert;
    /**
     * Queues an alert to be played.
     * @param alert The alert to queue.
     */
    private queueAlert;
    /**
     * Dequeues the next activated or triggered alert from a queue and starts playing it. If this system is asleep, then
     * the queue will be cleared instead and no alert will be played.
     * @param entry The queue entry.
     */
    private dequeueAlert;
    /**
     * Deactivates an alert. Deactivating an alert will prevent queued activated instances of it from playing. In
     * addition, if an activated instance of the alert is currently playing and is continuous, it will be prevented from
     * looping.
     * @param id The (optionally suffixed) ID of the alert to deactivate.
     */
    private deactivateAlert;
    /**
     * Deactivates an alert suffix.
     * @param suffixedId The suffixed ID to deactivate.
     * @returns The ID of the alert that was deactivated as a result of deactivating the suffix, or `undefined` if no
     * alert was deactivated.
     */
    private deactivateSuffix;
    /**
     * Untriggers an alert. Untriggering an alert will prevent queued triggered instances of it from playing. In
     * addition, if a triggered instance of the alert is currently playing and is continuous, it will be prevented from
     * looping.
     * @param uuid The (optionally suffixed) ID of the alert to untrigger.
     */
    private untriggerAlert;
    /**
     * Untriggers an alert suffix.
     * @param suffixedId The suffixed ID to untrigger.
     * @returns The ID of the alert that was untriggered as a result of deactivating the suffix, or `undefined` if no
     * alert was untriggered.
     */
    private untriggerSuffix;
    /**
     * Kills an alert. Killing an alert will deactivate and untrigger it. In addition, if the alert is currently playing,
     * it will be stopped at the earliest opportunity.
     * @param uuid The (optionally suffixed) ID of the alert to kill.
     */
    private killAlert;
    /**
     * Deactivates all alerts. This will stop all queued activated alerts from playing and prevent all currently playing
     * activated continuous alerts from looping.
     */
    private deactivateAllAlerts;
    /**
     * Untriggers all alerts. This will stop all queued triggered alerts from playing and prevent all currently playing
     * triggered continuous alerts from looping.
     */
    private untriggerAllAlerts;
    /**
     * Kills all alerts. This deactivates and untriggers all alerts, stopping all queued alerts from playing and stopping
     * all currently playing alerts at the earliest opportunity.
     */
    private killAllAlerts;
    /**
     * Responds to when a sound packet stops playing.
     * @param key The key of the stopped packet.
     */
    private onPacketEnded;
    /**
     * Creates a sound packet key for a queue.
     * @param queue The name of the queue.
     * @returns A sound packet key for the specified queue.
     */
    private static createPacketKey;
}

/**
 * A manager for registering aural alerts. Alerts can be registered with an {@link AuralAlertSystem} through the
 * manager, which also handles registration requests from the alert system.
 */
declare class AuralAlertRegistrationManager {
    private readonly publisher;
    private readonly registrations;
    private readonly requestSub;
    /**
     * Creates a new instance of AuralAlertRegistrationManager.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Registers an aural alert.
     * @param definition The definition of the alert to register.
     */
    register(definition: Readonly<AuralAlertDefinition>): void;
    /**
     * Publishes a registration event for an alert.
     * @param definition The definition of the alert to register.
     */
    private publishRegistration;
    /**
     * Publishes registration events for all currently registered alerts.
     */
    private publishAllRegistrations;
    /**
     * Destroys this manager.
     */
    destroy(): void;
}

/**
 * The base properties for an XML-defined aural alert.
 */
declare type XmlAuralAlertBaseDefinition = {
    /** The ID of the alert. */
    uuid: string;
    /** The queue to which the alert belongs. */
    queue: string;
    /** The priority of the alert within its queue. */
    priority: number;
    /** The sequence of sound atoms to play for the alert. */
    sequence: string[];
    /** Whether the alert is continuous. */
    continuous: boolean;
    /** Whether the alert should repeat while active. */
    repeat: boolean;
};
/**
 * An XML-defined aural alert whose state is bound to XML logic.
 */
declare type XmlAuralAlertLogicDefinition = XmlAuralAlertBaseDefinition & {
    /** The type of this alert definition. */
    type: 'logic';
    /**
     * The logic controlling state of the alert. If the logic returns 0, the alert is deactivated. If the logic returns
     * any other number, the alert is activated.
     */
    logic: CompositeLogicXMLElement;
};
/**
 * An XML-defined aural alert whose state is bound to whether a {@link CasSystem} alert is displayed.
 */
declare type XmlAuralAlertCasDefinition = XmlAuralAlertBaseDefinition & {
    /** The type of this aural alert definition. */
    type: 'cas';
    /** The ID of the CAS alert to which to bind the aural alert state. */
    casUuid: string;
    /** The priority of the CAS alert to which to bind the aural alert state. */
    casPriority: AnnunciationType;
    /** The suffix of the CAS alert to which to bind the aural alert state. */
    casSuffix?: string;
    /** Whether to activate the aural alert when the bound CAS alert is acknowledged. */
    casIncludeAcknowledged: boolean;
};
/**
 * An XML-defined aural alert.
 */
declare type XmlAuralAlertDefinition = XmlAuralAlertLogicDefinition | XmlAuralAlertCasDefinition;
/**
 * A parser of XML-defined aural alerts.
 */
interface XmlAuralAlertParser {
    /**
     * Parses alert definitions from an XML document.
     * @param root The root XML document element containing the alert definitions.
     */
    parse(root: Element): XmlAuralAlertDefinition[];
}
/**
 * A default implementation of {@link XmlAuralAlertParser}.
 */
declare class DefaultXmlAuralAlertParser implements XmlAuralAlertParser {
    private readonly baseInstrument;
    private readonly defaultQueue;
    /**
     * Creates a new instance of DefaultXmlAuralAlertParser.
     * @param baseInstrument The BaseInstrument.
     * @param defaultQueue The default queue to assign alerts if they do not explicitly define one themselves.
     */
    constructor(baseInstrument: BaseInstrument, defaultQueue: string);
    /** @inheritdoc */
    parse(root: Element): XmlAuralAlertDefinition[];
    /**
     * Parses a single alert definition.
     * @param baseInstrument The BaseInstrument.
     * @param element The element defining the alert.
     * @returns The definition specified by the element, or `undefined` if one could not be parsed.
     */
    private parseAlertDefinition;
    /**
     * Parses a sound atom sequence.
     * @param element The element defining the sequence.
     * @returns The sound atom sequence defined by the element, or `undefined` if one could not be parsed.
     */
    private parseSequence;
}
/**
 * Adapts XML-defined aural alerts to {@link AuralAlertSystem}. Handles the registration of the alerts and management
 * of alert state.
 */
declare class AuralAlertSystemXmlAdapter {
    private readonly bus;
    private readonly logicHost;
    private readonly casSystem;
    private readonly publisher;
    private readonly auralRegistrationManager?;
    private readonly alertDefinitions?;
    /**
     * Creates a new instance of AuralAlertSystemXmlAdapter.
     * @param bus The event bus.
     * @param logicHost The XML logic host used to run this adapter's XML logic.
     * @param casSystem The CAS system.
     * @param alertDefsRoot The root XML document element containing the aural alert definitions to use.
     * @param parser The parser to use to parse alert definitions from the XML document.
     */
    constructor(bus: EventBus, logicHost: CompositeLogicXMLHost, casSystem: CasSystem, alertDefsRoot: Element | null, parser: XmlAuralAlertParser);
    /**
     * Registers this adapter's alerts with {@link AuralAlertSystem} and starts automatically managing alert states.
     * This method should be called before
     */
    start(): void;
}

/**
 * Binds the state of an aural alert to the displayed state of a CAS alert and transports the aural alert state to
 * {@link AuralAlertSystem}.
 */
declare class CasAuralAlertTransporter {
    private readonly auralUuid;
    private readonly auralActivation;
    private readonly casUuid;
    private readonly casPriority;
    private readonly casSuffix;
    private readonly includeAcknowledged;
    private readonly publisher;
    private readonly subs;
    /**
     * Creates a new instance of CasAuralAlertTransporter.
     * @param bus The event bus.
     * @param auralUuid The ID of this transporter's aural alert.
     * @param auralActivation A function which generates activation data for this transporter's aural alert. If the
     * function returns `undefined` or is itself not defined, the aural alert will be activated using its default
     * registered parameters.
     * @param casUuid The ID of the CAS alert to which to bind this transporter's aural alert.
     * @param casPriority The priority level of the CAS alert to which to bind this transporter's aural alert.
     * @param casSuffix The suffix, if any, of the CAS alert to which to bind this transporter's aural alert.
     * @param includeAcknowledged Whether to activate this transporter's aural alert when the bound CAS alert is
     * acknowledged.
     * @param casSystem The CAS system. If not defined, the initialization of the aural alert's state cannot be
     * guaranteed to be correct unless the transporter is created before the CAS alert can be activated.
     * @returns A new instance of CasAuralAlertTransporter.
     */
    private constructor();
    /**
     * Responds to when a CAS alert is displayed.
     * @param alert Data describing the displayed alert.
     */
    private onAlertDisplayed;
    /**
     * Responds to when a CAS alert is hidden.
     * @param alert Data describing the hidden alert.
     */
    private onAlertHidden;
    /**
     * Responds to when a CAS alert is acknowledged.
     * @param alert Data describing the acknowledged alert.
     */
    private onAlertAcknowledged;
    /**
     * Destroys this transporter. Once destroyed, it will no longer automatically manage the state of its aural alert.
     */
    destroy(): void;
    /**
     * Creates a new instance of CasAuralAlertTransporter, which will automatically activate and deactivate an aural
     * alert based on whether a bound CAS alert is being displayed as a message.
     * @param bus The event bus.
     * @param auralUuid The ID of the transporter's aural alert.
     * @param auralActivation A function which generates activation data for the transporter's aural alert. If the
     * function returns `undefined` or is itself not defined, the aural alert will be activated using its default
     * registered parameters.
     * @param casUuid The ID of the CAS alert to which to bind the transporter's aural alert.
     * @param casPriority The priority level of the CAS alert to which to bind the transporter's aural alert.
     * @param casSuffix The suffix, if any, of the CAS alert to which to bind the transporter's aural alert.
     * @param includeAcknowledged Whether to activate the transporter's aural alert when the bound CAS alert is
     * acknowledged.
     * @param casSystem The CAS system. If not defined, the transporter should be created before its bound CAS alert
     * can be activated. Otherwise the initialization of the aural alert's state cannot be guaranteed to be correct.
     * @returns A new instance of CasAuralAlertTransporter.
     */
    static create(bus: EventBus, auralUuid: string, auralActivation: (() => AuralAlertActivation | undefined) | undefined, casUuid: string, casPriority: AnnunciationType, casSuffix: string | undefined, includeAcknowledged: boolean, casSystem?: CasSystem): CasAuralAlertTransporter;
}

/**
 * A sound packet that can be played by {@link SoundServer}.
 */
declare type SoundPacket = {
    /** The key of this packet. Only one packet with any given key can be playing at a time. */
    key: string;
    /**
     * The sequence of sound atoms to play for this packet, as either a single ID or an array of IDs. Each atom is a
     * single sound file.
     */
    sequence: string | readonly string[];
    /** Whether this packet should loop from the beginning when its sequence is finished playing. */
    continuous: boolean;
    /**
     * The amount of time, in milliseconds, after this packet starts playing at which to forcibly stop this packet. This
     * value is required in case any sound atoms could not be played or sim does not notify the sound server that a sound
     * atom has stopped playing. It is recommended to set this value to be at least several seconds longer than the
     * expected length of this packet's entire sequence. If this packet is continuous, the timeout is reset with each
     * loop. Defaults to 10000 milliseconds.
     */
    timeout?: number;
};
/**
 * Events published by {@link SoundServer}.
 */
interface SoundServerEvents {
    /** Whether the sound server is initialized. The sound server will only respond to commands when it has been initialized. */
    sound_server_initialized: boolean;
    /** A sound packet has started playing. The event data is the key of the packet. */
    sound_server_packet_started: string;
    /** A sound packet has finished playing. The event data is the key of the packet. */
    sound_server_packet_ended: string;
}
/**
 * Events used to send commands to a {@link SoundServer}.
 */
interface SoundServerControlEvents {
    /**
     * Requests a sound packet to be played if there is no existing packet with the same key currently being played.
     */
    sound_server_play: Readonly<SoundPacket>;
    /**
     * Requests a sound packet to be queued. If there is no existing packet with the same key currently being played, the
     * packet will begin playing immediately. Otherwise, the new packet will begin playing after the existing packet and
     * any other queued packets with the same key are finished playing.
     */
    sound_server_queue: Readonly<SoundPacket>;
    /**
     * Requests a sound packet to be played at the earliest opportunity. If there is no existing packet with the same key
     * currently being played, the packet will begin playing immediately. Otherwise, the existing packet will be stopped
     * the next time one of its sound atoms finishes playing, any queued packets with the same key will be discarded, and
     * the new packet will begin playing at that time.
     */
    sound_server_interrupt: Readonly<SoundPacket>;
    /**
     * Requests that a continuous sound packet stop playing instead of looping the next time its sequence finishes. The
     * event data should be the key of the packet to stop. This also prevents any queued packets with the same key from
     * playing.
     */
    sound_server_stop: string;
    /**
     * Requests that a sound packet stop playing at the earliest opportunity (the next time one of its sound atoms
     * finishes playing). The event data should be the key of the packet to kill. This also prevents any queued packets
     * with the same key from playing.
     */
    sound_server_kill: string;
    /**
     * Requests that all currently playing continuous sound packets stop playing instead of looping the next time their
     * sequences finish. This also clears all queued packets.
     */
    sound_server_stop_all: void;
    /**
     * Requests that all currently playing sound packets stop playing at the earliest opportunity (the next time one of
     * their sound atoms finishes playing). This also clears all queued packets.
     */
    sound_server_kill_all: void;
    /**
     * Requests a single sound atom to be played non-continuously. The event data should be the ID of the sound atom to
     * play. Publishing this command is an alias for publishing a `sound_server_play` command with the packet:
     * `{ key: id, sequence: id, continuous: false }`.
     */
    sound_server_play_sound: string;
    /**
     * Requests a single sound atom to be played continuously. The event data should be the ID of the sound atom to play.
     * Publishing this command is an alias for publishing a `sound_server_play` command with the packet:
     * `{ key: id, sequence: id, continuous: true }`.
     */
    sound_server_start_sound: string;
    /**
     * Requests that a continuous sound packet stop playing instead of looping the next time its sequence finishes. The
     * event data should be the key of the packet to stop. This command is an alias for `sound_server_stop`.
     */
    sound_server_stop_sound: string;
}
/**
 * A server which plays and manages sounds. Commands to start or stop playing sounds can be sent to the server via the
 * event bus.
 *
 * The server plays sounds as _packets_. Each sound packet consists of a string key and zero or more _sound atoms_ that
 * are played in sequence. Each sound atom represents a single playable sound file from within the sim. Sound packets
 * can be played as a one-shot or be looped continuously. Only one packet with a given key can be played at a time.
 * Queueing of packets with the same key is supported.
 */
declare class SoundServer {
    private readonly bus;
    static readonly DEFAULT_TIMEOUT = 10000;
    private readonly controlSub;
    private readonly publisher;
    private readonly active;
    private readonly queued;
    /**
     * Creates a new instance of SoundServer.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Waits until the sim has entered the in-game state and initializes this server. Once initialized, this server will
     * respond to commands over the event bus.
     */
    private init;
    /**
     * A callback method that responds to when the sim notifies the JS instrument that a sound file has stopped playing.
     * This method needs to be manually called for `SoundServer` to function properly.
     * @param id The ID of the sound file that stopped playing.
     */
    onSoundEnd(id: Name_Z): void;
    /**
     * Plays a sound packet if and only if there is no currently playing packet with the same key.
     * @param packet The packet to play.
     */
    private playPacket;
    /**
     * Plays a sound packet at the earliest opportunity. If there is no currently playing packet with the same key, it
     * will begin playing immediately. Otherwise, all queued packets with the same key are cleared, the existing packet
     * will be stopped the next time one of its sound atoms finishes playing, and the new packet will begin playing at
     * that time.
     * @param packet The packet to play.
     */
    private interruptPacket;
    /**
     * Queues a sound packet. The queued packet will immediately start playing if there is no currently playing packet
     * with the same key. Otherwise it will be queued to play once all currently playing and previously queued packets
     * with the same key have finished playing.
     * @param packet The packet to queue.
     */
    private queuePacket;
    /**
     * Stops a continuous packet from looping the next time its sequence finishes and clears any packets queued behind
     * it.
     * @param key The key of the packet to stop.
     */
    private stopPacket;
    /**
     * Stops a packet from playing the next time one of its sound atoms finishes playing and clears any packets queued
     * behind it.
     * @param key The key of the packet to kill.
     */
    private killPacket;
    /**
     * Stops all currently playing continuous packets from looping the next time their sequences finish and clears all
     * queued packets.
     */
    private stopAllPackets;
    /**
     * Stops all packets from playing the next time one of their sound atoms finishes playing and clears all queued
     * packets.
     */
    private killAllPackets;
    /**
     * Plays a non-continuous sound packet consisting of a single sound atom and whose key matches the ID of the sound
     * atom.
     * @param id The ID of the sound atom to play.
     */
    private playSound;
    /**
     * Plays a continuous sound packet consisting of a single sound atom and whose key matches the ID of the sound atom.
     * @param id The ID of the sound atom to play.
     */
    private startSound;
    /**
     * Starts playing a packet from the beginning of its sequence.
     * @param entry The entry of the packet to start playing.
     */
    private startPacket;
    /**
     * Attempts to advance a packet to the next sound atom in its sequence. If the end of the sequence is reached, the
     * packet will loop to the beginning if it is continuous. Otherwise it will finish playing.
     * @param entry The entry of the packet to advance.
     */
    private advancePacket;
    /**
     * Finishes playing a packet and automatically starts playing the packet queued behind the finished packet, if one
     * exists.
     * @param entry The entry of the packet to finish.
     */
    private cleanupPacket;
    /**
     * Gets a sound atom sequence as an array of `Name_Z` objects from a sound packet.
     * @param packet The packet defining the sound atom sequence.
     * @returns The sound atom sequence defined by a packet, as an array of `Name_Z` objects.
     */
    private static getSoundSequence;
}
/**
 * A controller which provides a convenient interface with which to send commands to {@link SoundServer}.
 */
declare class SoundServerController {
    private readonly publisher;
    private readonly subscriber;
    /**
     * Creates a new instance of SoundServerController.
     * @param bus The event bus.
     */
    constructor(bus: EventBus);
    /**
     * Waits for the sound server to finish initialization.
     * @returns A Promise which fulfills with a value of `true` when the sound server finishes initialization.
     */
    awaitInitialized(): Promise<boolean>;
    /**
     * Requests a sound packet to be played if there is no existing packet with the same key currently being played.
     * @param packet The sound packet to play.
     */
    play(packet: Readonly<SoundPacket>): void;
    /**
     * Requests a sound packet to be queued. If there is no existing packet with the same key currently being played, the
     * packet will begin playing immediately. Otherwise, the new packet will begin playing after the existing packet and
     * any other queued packets with the same key are finished playing.
     * @param packet The sound packet to queue.
     */
    queue(packet: Readonly<SoundPacket>): void;
    /**
     * Requests a sound packet to be played at the earliest opportunity. If there is no existing packet with the same key
     * currently being played, the packet will begin playing immediately. Otherwise, the existing packet will be stopped
     * the next time one of its sound atoms finishes playing, any queued packets with the same key will be discarded, and
     * the new packet will begin playing at that time.
     * @param packet The sound packet to play.
     */
    interrupt(packet: Readonly<SoundPacket>): void;
    /**
     * Requests that a continuous sound packet stop playing instead of looping the next time its sequence finishes. This
     * also prevents any queued packets with the same key from
     * playing.
     * @param key The key of the sound packet to stop.
     */
    stop(key: string): void;
    /**
     * Requests that a sound packet stop playing at the earliest opportunity (the next time one of its sound atoms
     * finishes playing). This also prevents any queued packets with the same key from playing.
     * @param key The key of the sound packet to kill.
     */
    kill(key: string): void;
    /**
     * Requests that all currently playing continuous sound packets stop playing instead of looping the next time their
     * sequences finish. This also clears all queued packets.
     */
    stopAll(): void;
    /**
     * Requests that all currently playing sound packets stop playing at the earliest opportunity (the next time one of
     * their sound atoms finishes playing). This also clears all queued packets.
     */
    killAll(): void;
    /**
     * Requests a single sound atom to be played non-continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: false })`.
     * @param id The ID of the sound atom to play.
     */
    playSound(id: string): void;
    /**
     * Requests a single sound atom to be played continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: true })`.
     * @param id The ID of the sound atom to play.
     */
    startSound(id: string): void;
}

/** Collection of string utility functions. */
declare class StringUtils {
    static readonly DIRECT_TO = "\u00D0";
    static readonly DEGREE = "\u00B0";
    static readonly EN_DASH = "\u2013";
    private static readonly ZERO_REGEX;
    private static readonly TRIM_START_REGEX;
    private static readonly TRIM_END_REGEX;
    /**
     * Replaces all `'0'` characters in a string with the slashed zero character.
     * @param text The string to convert.
     * @returns A string identical to the input string except with all `'0'` characters converted to the slashed zero
     * character.
     */
    static useZeroSlash(text: string): string;
    /**
     * Removes leading whitespace and line terminator characters from a string.
     * @param str The string to trim.
     * @returns A new string representing `str` with all leading whitespace and line terminator characters removed.
     */
    static trimStart(str: string): string;
    /**
     * Removes trailing whitespace and line terminator characters from a string.
     * @param str The string to trim.
     * @returns A new string representing `str` with all trailing whitespace and line terminator characters removed.
     */
    static trimEnd(str: string): string;
}

/**
 * A utility class for generating Promises that wait for certain conditions before they are fulfilled.
 */
declare class Wait {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    static awaitDelay(delay: number): Promise<void>;
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    static awaitCondition(predicate: () => boolean, interval?: number, timeout?: number): Promise<void>;
    /**
     * Waits for a notification from a {@link Subscribable}, with an optional condition to end the wait based on the value
     * of the subscribable.
     * @param subscribable The subscribable to wait for.
     * @param predicate A function which evaluates whether the value of the subscribable satisfies the condition for the
     * wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive a notification from the subscribable at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the subscribable when a notification is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitSubscribable<T>(subscribable: Subscribable<T>, predicate?: (value: T) => boolean, initialCheck?: boolean, timeout?: number): Promise<T>;
    /**
     * Waits for an event from a {@link Consumer}, with an optional condition to end the wait based on the value of the
     * consumed event.
     * @param consumer The event consumer to wait for.
     * @param predicate A function which evaluates whether the value of the consumed event satisfies the condition for
     * the wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive an event from the event consumer at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the consumed event when an event is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitConsumer<T>(consumer: Consumer<T>, predicate?: (value: T) => boolean, initialCheck?: boolean, timeout?: number): Promise<T>;
    /**
     * Waits for an event from a {@link ReadonlySubEvent}, with an optional condition to end the wait based on the sender
     * and data of the event.
     * @param event The event to wait for.
     * @param predicate A function which evaluates whether the sender and data of the event satisfy the condition for
     * the wait to end. If not defined, any sender/data is considered satisfactory.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the data of the event when an event is received with a sender and data
     * that satisfy the condition for the wait to end.
     */
    static awaitSubEvent<SenderType, DataType>(event: ReadonlySubEvent<SenderType, DataType>, predicate?: (data: DataType, sender: SenderType) => boolean, timeout?: number): Promise<DataType>;
}

/** Utility functions for working with UUIDs. */
declare class UUID {
    /**
     * A function to generate a spec-compliand v4 UUID in a 32-bit safe way.
     * @returns A UUID in standard 8-4-4-4-12 notation.
     */
    static GenerateUuid(): string;
    /**
     * Take a number and return its hexadecimal representation.
     * @param bits The bytes to format.
     * @returns The input bits as a hexadecimal string.
     */
    private static bytesToHexString;
}

/** The value retured when we add a item to the collection. */
declare type CollectionComponentItemRef = string;
/**
 * The props for a CollectionComponent.
 */
interface CollectionComponentProps extends ComponentProps {
    /** The element ID to use. */
    id: string;
}
/**
 * A component that lets you add and remove children.
 */
declare class CollectionComponent<P extends CollectionComponentProps> extends DisplayComponent<P> {
    private items;
    private itemCounter;
    /**
     * Add a new child element.
     * @param node A VNode to add to the container.
     * @returns An identifier for the added element.
     */
    addItem(node: VNode): CollectionComponentItemRef;
    /**
     * Remove a child element.
     * @param id The ID of the child to remove.
     */
    removeItem(id: CollectionComponentItemRef): void;
    /**
     * Insert a child before an element.
     * @param node The node to insert
     * @param before The element to insert before.
     * @returns An identifier for the added element.
     */
    insertBefore(node: VNode, before: CollectionComponentItemRef): CollectionComponentItemRef;
    /**
     * Insert a child after an element.
     * @param node The node to insert
     * @param after The element to insert after.
     * @returns An identifier for the added element.
     */
    insertAfter(node: VNode, after: CollectionComponentItemRef): CollectionComponentItemRef;
    /**
     * Render the element.
     * @returns A VNode.
     */
    render(): VNode;
}

/**
 * An interface to be implemented by instrument classes.
 */
interface FsInstrument {
    /**
     * A reference to the BaseInstrument loaded by the sim
     */
    readonly instrument: BaseInstrument;
    Update(): void;
    onInteractionEvent(_args: Array<string>): void;
    onFlightStart(): void;
    onGameStateChanged(oldState: GameState, newState: GameState): void;
    onSoundEnd(soundEventId: Name_Z): void;
}
/**
 * A class that wraps the actual instrumenet implementation and handles the sim's vcockpit lifecycle.
 */
declare abstract class FsBaseInstrument<T extends FsInstrument> extends BaseInstrument {
    protected fsInstrument: T;
    /**
     * The instrument template ID.
     * @returns The instrument template ID.
     */
    abstract get templateID(): string;
    /**
     * Called during connectedCallback to construct the actual instrument class.
     */
    abstract constructInstrument(): T;
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback(): void;
    /**
     * Update method called by BaseInstrument
     */
    protected Update(): void;
    /** @inheritdoc */
    onInteractionEvent(_args: Array<string>): void;
    /** @inheritdoc */
    protected onGameStateChanged(oldState: GameState, newState: GameState): void;
    /** @inheritdoc */
    onFlightStart(): void;
    /** @inheritdoc */
    onSoundEnd(soundEventId: Name_Z): void;
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive(): boolean;
}

export { APAltCapDirector, APAltCapDirectorCaptureFunc, APAltDirector, APAltitudeModes, APBackCourseDirector, APBackCourseDirectorOptions, APConfig, APDirectors, APEvents, APFLCDirector, APFPADirector, APFPADirectorOptions, APGPDirector, APGSDirector, APGSDirectorOptions, APHdgDirector, APHdgDirectorOptions, APHdgHoldDirector, APLateralModes, APLockType, APLvlDirector, APModePressEvent, APModeType, APNavDirector, APNavDirectorInterceptFunc, APNavDirectorOptions, APPitchDirector, APRadioNavInstrument, APRollDirector, APRollDirectorOptions, APStateManager, APStates, APTogaPitchDirector, APTrkDirector, APTrkHoldDirector, APVNavPathDirector, APVSDirector, APValues, APVerticalModes, AbstractAutothrottle, AbstractFlightPathLegCalculator, AbstractFlightPathLegRenderer, AbstractFlightPathPlanRenderer, AbstractFmcPage, AbstractMapTextLabel, AbstractMapTextLabelOptions, AbstractMapTrafficIntruderIcon, AbstractMapWaypointIcon, AbstractMapWaypointIconOptions, AbstractNearestSubscription, AbstractNumberUnitDisplay, AbstractNumberUnitDisplayProps, AbstractSubscribable, AbstractSubscribableArray, AbstractSubscribableSet, AbstractTcasIntruder, AbstractTransformingPathStream, AbstractUnit, AbstractWaypoint, ActiveLegType, ActiveOrUpcomingLegPredictions, AdaptiveNearestContext, AdaptiveNearestSubscription, AdcEvents, AdcPublisher, AdditionalApproachType, AdfRadioDataEvents, AdfRadioIndex, AdfRadioTuneEvents, Adsb, AdsbEvents, AdsbOperatingMode, AeroMath, AffineTransformPathStream, AhrsEvents, AhrsPublisher, AirportClass, AirportClassMask, AirportFacility, AirportPrivateType, AirportRunway, AirportUtils, Airspace, AirspaceSearcher, AirspaceType, Airway, AirwayBuilder, AirwayObject, AirwaySegment, AirwayStatus, AirwayType, AliasedUserSettingManager, AltitudeConstraintAdvanced, AltitudeConstraintDetails, AltitudeConstraintSimple, AltitudeRestrictionType, AltitudeSelectEvents, AltitudeSelectManager, AltitudeSelectManagerOptions, Animator, AnimatorEasingFunc, Annunciation, AnnunciationType, AntiIceEngineIndexedEvents, AntiIceEngineIndexedTopics, AntiIceEvents, AntiIceNonIndexedEvents, AntiIcePublisher, ApproachGuidanceMode, ApproachProcedure, ApproachTransition, ApproachUtils, ArcToFixLegCalculator, ArcTurnController, ArraySubject, ArrayTaskQueue, ArrayType, ArrayUtils, ArrivalProcedure, AuralAlertActivation, AuralAlertControlEvents, AuralAlertDefinition, AuralAlertEvents, AuralAlertRegistrationManager, AuralAlertSystem, AuralAlertSystemXmlAdapter, Autopilot, AutopilotInstrument, AutothrottleEvents, AutothrottleOptions, AutothrottlePidParams, AutothrottleTargetMode, AutothrottleThrottle, AutothrottleThrottleIndex, AutothrottleThrottleInfo, AvionicsPlugin, AvionicsSystem, AvionicsSystemState, AvionicsSystemStateEvent, BacklightLevelController, BackplanePublisher, BaseAdcEvents, BaseAhrsEvents, BaseControlSurfacesEvents, BaseFlightPathVector, BaseFuelSystemEvents, BaseInstrumentPublisher, BaseLegPredictions, BasePublisher, BasicAvionicsSystem, BasicConsumer, BasicFacilityWaypoint, BasicNavAngleSubject, BasicNavAngleUnit, BearingDirection, BearingDistance, BearingIdent, BearingIsLoc, BearingSource, BearingValidity, BinaryHeap, Binding, BingComponent, BingComponentProps, BinomialHeap, BitFlags, BlurReconciliation, BottomTargetPathCalculator, BoundaryAltitudeType, BoundaryFacility, BoundaryType, BoundaryVector, BoundaryVectorType, BrakeEvents, BrakeSimvarPublisher, CasActiveMessage, CasAlertDefinition, CasAlertEventData, CasAlertKey, CasAlertTransporter, CasAuralAlertTransporter, CasEvents, CasRegistrationManager, CasStateEvents, CasSystem, CasSystemLegacyAdapter, CdiDeviation, CircleInterceptBuilder, CircleInterceptLegCalculator, CircleInterceptPathInfo, CircleIntersection, CircleVector, CircleVectorBuilder, ClippedPathStream, Clock, ClockEvents, ClockPublisher, CollectionComponent, CollectionComponentItemRef, CollectionComponentProps, ComRadioIndex, ComRadioTuneEvents, ComSpacing, ComSpacingChangeEvent, CombinedSubject, CombinedSubscribableInputs, CompiledMapSystem, ComponentProps, CompositeLogicXMLHost, CompositeLogicXMLValueType, CompoundUnit, CompoundableUnit, ComputedSubject, ConnectCirclesBuilder, Consumer, ConsumerSubject, ConsumerValue, Context, ContextRecord, ContextSubcriptions, ContextTypes, ContextUnion, ControlEvents, ControlPublisher, ControlSurfacesEvents, ControlSurfacesPublisher, ControllerRecord, ControllerUnion, CourseToAltitudeLegCalculator, CourseToDmeLegCalculator, CourseToFixLegCalculator, CourseToInterceptLegCalculator, CourseToManualLegCalculator, CourseToRadialLegCalculator, CssMatrixTransform, CssRotate3dTransform, CssRotateTransform, CssScale3dTransform, CssScaleTransform, CssScaleXTransform, CssScaleYTransform, CssScaleZTransform, CssTransform, CssTransformBuilder, CssTransformChain, CssTransformSubject, CssTranslate3dTransform, CssTranslateTransform, CssTranslateXTransform, CssTranslateYTransform, CssTranslateZTransform, CustomFlightPathLegRenderer, CustomWaypoint, DataInterface, DataStore, DateTimeFormatter, DateTimeFormatterOptions, DebounceTimer, DefaultFacilityWaypointCache, DefaultLodBoundaryCache, DefaultMapSystemContext, DefaultTcasAdvisoryDataProvider, DefaultTcasIntruder, DefaultUserSettingManager, DefaultXmlAuralAlertParser, DeltaPacer, DepartureProcedure, DigitScroller, DigitScrollerProps, DirectToData, DirectToFixLegCalculator, DirectToPointBuilder, DirectorState, DisplayComponent, DisplayComponentFactory, DisplayField, DisplayFieldOptions, DmeState, DmsFormatter, DmsFormatter2, DurationDisplay, DurationDisplayDelim, DurationDisplayFormat, DurationDisplayOptions, DurationDisplayProps, DurationFormatter, EISPublisher, Easing, EditableField, EditableFieldOptions, ElectricalEvents, ElectricalPublisher, EmptyDirector, EmptyRecord, EngineEvents, EnrouteTransition, EventBus, EventBusMetaEvents, EventRepublisher, EventSubscriber, EventTypes, ExpSmoother, ExtendedApproachType, ExtractSubjectType, ExtractSubjectTypes, FSComponent, Facility, FacilityFrequency, FacilityFrequencyType, FacilityILSFrequency, FacilityLoader, FacilityRepository, FacilityRepositoryEvents, FacilitySearchType, FacilitySearchTypeLatLon, FacilityType, FacilityTypeMap, FacilityTypeSearchType, FacilityUtils, FacilityWaypoint, FacilityWaypointCache, FacilityWaypointUtils, FadecEvents, FamilyOfUnit, FilteredMappedSubscribableArray, FixToDmeLegCalculator, FixTypeFlags, FlattenArray, FlattenArrayToDepth, FlightPathAirplaneSpeedMode, FlightPathBankAngleBreakpoints, FlightPathCalculator, FlightPathCalculatorControlEvents, FlightPathCalculatorOptions, FlightPathLegCalculator, FlightPathLegLineRenderer, FlightPathLegLineStyle, FlightPathLegLineStyleSelector, FlightPathLegPatternRenderer, FlightPathLegPatternStyle, FlightPathLegPatternStyleSelector, FlightPathLegRenderPart, FlightPathPlanRenderOrder, FlightPathRenderStyle, FlightPathState, FlightPathTurnCalculator, FlightPathUtils, FlightPathVector, FlightPathVectorFlags, FlightPathVectorLineRenderer, FlightPathVectorPatternRenderer, FlightPathVectorStyle, FlightPathWaypoint, FlightPlan, FlightPlanActiveLegEvent, FlightPlanCalculatedEvent, FlightPlanCopiedEvent, FlightPlanDirectToDataEvent, FlightPlanDisplayBuilder, FlightPlanIndicationEvent, FlightPlanLeg, FlightPlanLegEvent, FlightPlanLegIterator, FlightPlanOriginDestEvent, FlightPlanPredictor, FlightPlanPredictorConfiguration, FlightPlanPredictorUtils, FlightPlanProcedureDetailsEvent, FlightPlanRequestEvent, FlightPlanResponseEvent, FlightPlanSegment, FlightPlanSegmentEvent, FlightPlanSegmentType, FlightPlanUserDataEvent, FlightPlanUtils, FlightPlanner, FlightPlannerEvents, FlightTimerControlEvents, FlightTimerEvents, FlightTimerInstrument, FlightTimerMode, FlightTimerPublisher, FmcColumnInformation, FmcComponent, FmcComponentOptions, FmcDirection, FmcListUtility, FmcOutputRow, FmcOutputTemplate, FmcPageFactory, FmcPageLifecyclePolicy, FmcPagingEvents, FmcRenderCallback, FmcRenderTemplate, FmcRenderTemplateColumn, FmcRenderTemplateRow, FmcRenderer, FmcRendererOptions, FmcRouter, FmcScratchpad, FmcScratchpadOptions, FmcScreen, FmcScreenOptions, FocusPosition, Formatter, Fragment, FragmentFactory, FrequencyBank, FrequencyChangeEvent, FsBaseInstrument, FsInstrument, FuelSystemEvents, FuelSystemSimVarPublisher, GNSSEvents, GNSSPublisher, GPSEphemeris, GPSEphemerisRecords, GPSEpoch, GPSSVClock, GPSSatComputer, GPSSatComputerEvents, GPSSatellite, GPSSatelliteState, GPSSystemSBASState, GPSSystemState, GameStateProvider, GameVarPublisher, GaugeColumnGroupProps, GaugeColumnProps, GeoCircle, GeoCircleLineRenderer, GeoCirclePathRenderer, GeoCirclePatternRenderer, GeoCircleResampler, GeoCircleResamplerArcVector, GeoCircleResamplerHandler, GeoCircleResamplerLineVector, GeoCircleResamplerStartVector, GeoCircleResamplerVector, GeoKdTree, GeoKdTreeSearchFilter, GeoKdTreeSearchVisitor, GeoPoint, GeoPointInterface, GeoPointReadOnly, GeoPointSubject, GeoProjection, GeoProjectionPathStream, GeoProjectionPathStreamStack, GeodesicResampler, GeodesicResamplerHandler, GlidePathCalculator, Glideslope, GpsBoolean, GpsSynchronizer, GreatCircleBuilder, HEvent, HEventPublisher, Handler, HandlerSubscription, HardwareControlListProps, HardwareUiControl, HardwareUiControlList, HardwareUiControlProps, HoldEntryType, HoldLegCalculator, HoldMaxSpeedRule, HoldUtils, HorizonCanvasLayer, HorizonCanvasLayerCanvasInstance, HorizonCanvasLayerCanvasInstanceClass, HorizonCanvasLayerProps, HorizonComponent, HorizonComponentProps, HorizonLayer, HorizonLayerProps, HorizonProjection, HorizonProjectionChangeListener, HorizonProjectionChangeType, HorizonProjectionParameters, HorizonSyncedCanvasLayer, HydraulicsEvents, HydraulicsPublisher, ICAO, IcaoSearch, IcaoSearchFilter, IdentChangeEvent, ImageCache, IndexedEventType, IndexedNavSourceSetting, InputAcceleration, InputAccelerationSettings, Instrument, InstrumentBackplane, InstrumentEvents, InterceptGreatCircleToPointBuilder, IntersectionFacility, IntersectionFacilityUtils, IntersectionType, IntervalPacer, IteratorCursor, JetAutothrottle, JetFadec, JetFadecEngineState, JetFadecMode, JetFadecThrottleInfo, JetFadecThrottleInfoInternal, JoinGreatCircleToPointBuilder, KdTree, KdTreeSearchFilter, KdTreeSearchVisitor, KeyEventData, KeyEventManager, KeyEvents, LNavDataEvents, LNavDataSimVarEvents, LNavDataSimVarPublisher, LNavDataVars, LNavDirector, LNavDirectorInterceptFunc, LNavDirectorOptions, LNavEvents, LNavSimVarPublisher, LNavTrackingState, LNavTransitionMode, LNavUtils, LNavVars, LatLonDisplay, LatLonDisplayProps, LatLonInterface, LatLongInterface, LayerRecord, LayerUnion, LegCalculations, LegDefinition, LegDefinitionFlags, LegEventType, LegPredictions, LegStyleHandler, LegTurnDirection, LegType, LegWaypointHandler, LerpLookupTable, LerpVectorLookupTable, LerpVectorLookupTableBreakpoint, LineSelectKeyEvent, LinearServo, Localizer, LocalizerFrequency, LodBoundary, LodBoundaryCache, LodBoundaryShape, LodBoundaryVector, LogicHandler, Lookahead, MSFSAPStates, MagVar, MapAbstractAirspaceRenderer, MapAbstractNearestWaypointsLayerProps, MapAirspaceLayer, MapAirspaceLayerModules, MapAirspaceLayerProps, MapAirspaceModule, MapAirspaceRenderManager, MapAirspaceRenderer, MapAirspaceShowTypes, MapAltitudeArcLayer, MapAltitudeArcLayerModules, MapAltitudeArcLayerProps, MapAltitudeArcModule, MapAutopilotPropsModule, MapBinding, MapBindingsController, MapBingLayer, MapBingLayerProps, MapBlankWaypointIcon, MapCachedCanvasLayer, MapCachedCanvasLayerCanvasInstance, MapCachedCanvasLayerCanvasInstanceClass, MapCachedCanvasLayerProps, MapCachedCanvasLayerReference, MapCachedCanvasLayerTransform, MapCanvasLayer, MapCanvasLayerCanvasInstance, MapCanvasLayerCanvasInstanceClass, MapCanvasLayerProps, MapClockUpdateController, MapClockUpdateControllerContext, MapComponent, MapComponentProps, MapCullableLocationTextLabel, MapCullableTextLabel, MapCullableTextLabelManager, MapCullableTextLayer, MapDataIntegrityModule, MapFieldOfView, MapFieldOfViewCalculator, MapFlightPlanController, MapFlightPlanControllerContext, MapFlightPlanControllerModules, MapFlightPlanModule, MapFollowAirplaneController, MapFollowAirplaneControllerContext, MapFollowAirplaneControllerModules, MapFollowAirplaneModule, MapGenericLayer, MapGenericLayerProps, MapIndexedRangeModule, MapLabeledRingLabel, MapLabeledRingLayer, MapLayer, MapLayerProps, MapLineLayer, MapLineLayerProps, MapLocationTextLabel, MapLocationTextLabelOptions, MapModel, MapMultiLineAirspaceRenderer, MapMultiLineAirspaceShape, MapMultiTransformedBinding, MapNearestWaypointsLayer, MapNearestWaypointsLayerSearch, MapNearestWaypointsLayerSearchTypes, MapOwnAirplaneIconModule, MapOwnAirplaneIconOrientation, MapOwnAirplaneIconOrientationController, MapOwnAirplaneIconOrientationControllerModules, MapOwnAirplaneLayer, MapOwnAirplaneLayerModules, MapOwnAirplaneLayerProps, MapOwnAirplanePropsController, MapOwnAirplanePropsControllerModules, MapOwnAirplanePropsKey, MapOwnAirplanePropsModule, MapProjection, MapProjectionChangeListener, MapProjectionChangeType, MapProjectionParameters, MapRangeModule, MapRotation, MapRotationController, MapRotationControllerContext, MapRotationControllerModules, MapRotationModule, MapSimpleBinding, MapSingleLineAirspaceRenderer, MapSyncedCanvasLayer, MapSystemBuilder, MapSystemComponent, MapSystemComponentProps, MapSystemContext, MapSystemController, MapSystemCustomBuilder, MapSystemFlightPlanLayer, MapSystemFlightPlanLayerModules, MapSystemFlightPlanLayerProps, MapSystemGenericController, MapSystemGenericControllerCallbacks, MapSystemIconFactory, MapSystemKeys, MapSystemLabelFactory, MapSystemLegRenderer, MapSystemPlanRenderer, MapSystemTrafficLayer, MapSystemTrafficLayerModules, MapSystemTrafficLayerProps, MapSystemUtils, MapSystemWaypointRoles, MapSystemWaypointsLayer, MapSystemWaypointsLayerModules, MapSystemWaypointsLayerProps, MapSystemWaypointsRenderer, MapTerrainColorsModule, MapTextLabel, MapTextLayerProps, MapTrafficAlertLevelVisibility, MapTrafficIntruderIcon, MapTrafficIntruderIconFactory, MapTrafficModule, MapTransformedBinding, MapWaypoint, MapWaypointDisplayModule, MapWaypointIcon, MapWaypointImageIcon, MapWaypointRenderRoleDef, MapWaypointRenderRoleSelector, MapWaypointRenderer, MapWaypointRendererEntry, MapWaypointRendererIconFactory, MapWaypointRendererLabelFactory, MapWaypointRendererType, MapWaypointSpriteIcon, MapWxrModule, MappedSubject, MappedSubscribable, MappedSubscribableInputs, MappedUserSettingManager, MarkerBeaconState, MarkerBeaconTuneEvents, MathUtils, MercatorProjection, Metar, MetarCloudLayer, MetarCloudLayerCoverage, MetarCloudLayerType, MetarPhenomenon, MetarPhenomenonIntensity, MetarPhenomenonType, MetarVisibilityUnits, MetarWindSpeedUnits, MetricAltitudeSelectSetting, MetricAltitudeSettingsManager, MinimumsControlEvents, MinimumsEvents, MinimumsManager, MinimumsMode, MinimumsSimVarEvents, MinimumsSimVarPublisher, MockEventTypes, ModuleRecord, ModuleUnion, MutableGeoProjection, MutableMapContext, MutableSubscribable, MutableSubscribableInputType, MutableSubscribableSet, NavAngleUnit, NavAngleUnitFamily, NavAngleUnitReferenceNorth, NavComConfig, NavComInstrument, NavComSimVarPublisher, NavComSimVars, NavEvents, NavMagneticVariation, NavMath, NavProcSimVarPublisher, NavProcSimVars, NavProcessor, NavProcessorConfig, NavRadioDataEvents, NavRadioEvents, NavRadioIndex, NavRadioTuneEvents, NavSource, NavSourceId, NavSourceType, NavToNavManager, NdbFacility, NdbType, NearestAirportSearchSession, NearestAirportSubscription, NearestBoundarySearchSession, NearestContext, NearestIntersectionSearchSession, NearestIntersectionSubscription, NearestLodBoundarySearchResults, NearestLodBoundarySearchSession, NearestNdbSubscription, NearestRepoFacilitySearchSession, NearestSearchResults, NearestSearchSession, NearestSubscription, NearestSubscriptionFacilityType, NearestUsrSubscription, NearestVorSearchSession, NearestVorSubscription, NeverNull, NoPathLegCalculator, NodeInstance, NodeReference, NullAirspaceRenderer, NullPathStream, NumberFormatter, NumberFormatterOptions, NumberUnit, NumberUnitInterface, NumberUnitReadOnly, NumberUnitSubject, ObjectSubject, ObjectSubjectHandler, ObsDirector, ObsSetting, OneWayRunway, OriginDestChangeType, OrthographicProjection, PageConstructor, PageLinkField, PassThroughPathStream, PassedLegPredictions, PathPattern, PathStream, PatternPathStream, PidController, PitotEvents, PitotIndexedEvents, PitotIndexedTopics, PitotNonIndexedEvents, PitotPublisher, PlanEvents, PlanSubjects, PlaneDirector, PluginSystem, PowerCommand, PressurizationEvents, PressurizationPublisher, Procedure, ProcedureDetails, ProcedureTurnBuilder, ProcedureTurnLegCalculator, PublishPacer, Publisher, Radio, RadioEvents, RadioFrequencyFormatter, RadioType, RadioUtils, RadiusToFixLegCalculator, RandomNumberPublisher, RawFormatter, RawValidator, ReadonlyFloat64Array, ReadonlySubEvent, ReadonlyTransform2D, ReadonlyTransform3D, ReadonlyTransformPerspective, RenderPosition, RequiredControllerContext, RequiredControllerLayers, RequiredControllerModules, RequiredCustomBuilderContext, RequiredCustomBuilderLayers, RequiredCustomBuilderModules, RequiredLayerModules, ResourceConsumer, ResourceHeap, ResourceModerator, RnavTypeFlags, RunwayFacility, RunwayLightingType, RunwaySurfaceCategory, RunwaySurfaceType, RunwayTransition, RunwayUtils, SBASGroupName, SVGUtils, ScreenStateEvent, ScrollDirection, ScrollUtils, SearchTypeMap, SearchableFacilityTypes, SegmentEventType, SessionTypeMap, SetSubject, SetVnavDirectToData, SimVarDefinition, SimVarPublisher, SimVarPublisherEntry, SimVarValueType, SimpleFmcRenderer, SimpleFmcRendererOptions, SimpleMovingAverage, SimpleUnit, SmoothingPathCalculator, SmoothingPathCalculatorOptions, SortedArray, SortedMappedSubscribableArray, SoundPacket, SoundServer, SoundServerControlEvents, SoundServerController, SoundServerEvents, SpeedCommand, SpeedConstraint, SpeedConstraintDetails, SpeedRestrictionType, SpeedUnit, StallWarningEvents, StallWarningPublisher, StringUtils, SubEvent, SubEventInterface, Subject, Subscribable, SubscribableArray, SubscribableArrayEventType, SubscribableArrayHandler, SubscribableMapFunctions, SubscribablePipe, SubscribableSet, SubscribableSetEventType, SubscribableSetHandler, SubscribableSetPipe, SubscribableType, SubscribableUtils, Subscription, SvgPathStream, SwitchLabel, SwitchLabelOptions, SynVisComponent, SynVisProps, SystemAlertEvents, SystemAlertManager, SystemAlertPublisher, SystemPowerKey, Table3D, TacanUtils, Task, TaskQueue, Tcas, TcasAdvisoryDataProvider, TcasAdvisoryParameters, TcasAlertLevel, TcasEvents, TcasIISensitivity, TcasIISensitivityParameters, TcasIntruder, TcasOperatingMode, TcasResolutionAdvisoryFlags, TcasResolutionAdvisoryHost, TcasResolutionAdvisoryOptions, TcasResolutionAdvisoryType, TcasSensitivity, TcasSensitivityParameters, TcasTcaParameters, TcasTcaPrediction, TemperatureSource, TemperatureSystem, TextInputField, TextInputFieldOptions, ThrottleLeverManager, ThrottledTaskQueueHandler, ThrottledTaskQueueProcess, ToSubscribable, TocBocDetails, TodBodDetails, ToggleLabel, ToggleLabelOptions, TrackFromFixLegCalculator, TrackToFixLegCalculator, TrafficContact, TrafficEvents, TrafficInstrument, TrafficInstrumentOptions, TrafficOffScaleOobOptions, Transform2D, Transform3D, TransformPerspective, TransformingPathStream, TransformingPathStreamStack, TurbopropAutothrottle, TurnToCourseBuilder, TurnToFixLegCalculator, TurnToJoinGreatCircleAtPointBuilder, TurnToJoinGreatCircleBuilder, TwoWayBinding, UUID, UiControlEventHandler, UiControlEventHandlers, UiControlPropEventHandlers, Unit, UnitFamily, UnitOfNumber, UnitType, UserFacility, UserFacilityType, UserFacilityUtils, UserSetting, UserSettingDefinition, UserSettingFromRecord, UserSettingManager, UserSettingManagerEntry, UserSettingManagerInitData, UserSettingManagerSyncData, UserSettingManagerSyncEvents, UserSettingMap, UserSettingRecord, UserSettingSaveManager, UserSettingValue, UserSettingValueFilter, VNavAltCaptureType, VNavAvailability, VNavConstraint, VNavControlEventPublisher, VNavControlEvents, VNavDataEventPublisher, VNavDataEvents, VNavEvents, VNavLeg, VNavManager, VNavPathCalculator, VNavPathMode, VNavPlanSegment, VNavSimVarPublisher, VNavState, VNavUtils, VNavVars, VNavWaypoint, VNode, Validator, Vec2Math, Vec2Subject, Vec3Math, Vec3Subject, VecNMath, VecNSubject, Vector, VectorStyleHandler, VectorTurnDirection, VerticalData, VerticalFlightPhase, VerticalFlightPlan, VirtualThrottleLeverEvents, VisualFacility, VorClass, VorFacility, VorToFrom, VorToFromSetting, VorType, Wait, Warning, WarningManager, WarningType, Waypoint, WaypointDisplayBuilder, WaypointTypes, WeightBalanceEvents, WeightBalanceSimvarPublisher, WildcardHandler, WxrMode, XMLAnnunciationFactory, XMLCircularGaugeCursor, XMLCircularGaugeProps, XMLCircularGaugeStyle, XMLCircularGaugeValuePos, XMLCylinderGaugeProps, XMLCylinderGaugeStyle, XMLDoubleHorizontalGaugeProps, XMLDoubleHorizontalGaugeStyle, XMLDoubleHorizontalGaugeValuePos, XMLDoubleVerticalGaugeProps, XMLDoubleVerticalGaugeStyle, XMLExtendedGaugeConfig, XMLFunction, XMLGaugeColorLine, XMLGaugeColorZone, XMLGaugeConfigFactory, XMLGaugeProps, XMLGaugeReferenceBug, XMLGaugeReferenceBugStyle, XMLGaugeSpec, XMLGaugeStyle, XMLGaugeType, XMLHorizontalGaugeProps, XMLHorizontalGaugeStyle, XMLHorizontalGaugeValuePos, XMLHostedLogicGauge, XMLTextColumnProps, XMLTextElementProps, XMLVerticalGaugeProps, XMLVerticalGaugeStyle, XMLVerticalGaugeValuePos, XMLWarningFactory, XPDRInstrument, XPDRMode, XPDRSimVarEvents, XPDRSimVarPublisher, XmlAuralAlertCasDefinition, XmlAuralAlertDefinition, XmlAuralAlertLogicDefinition, XmlAuralAlertParser, registerPlugin };
